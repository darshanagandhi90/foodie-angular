/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/enum_transformer", ["require", "exports", "typescript", "tsickle/src/transformer_util"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @fileoverview Transforms TypeScript enum declarations to Closure enum declarations, which
     * look like:
     *
     *     /.. @enum {number} ./
     *     const Foo = {BAR: 0, BAZ: 1, ...};
     *     export {Foo};  // even if originally exported on one line.
     *
     * This declares an enum type for Closure Compiler (and Closure JS users of this TS code).
     * Splitting the enum into declaration and export is required so that local references to the
     * type resolve ("@type {Foo}").
     */
    const ts = require("typescript");
    const transformer_util_1 = require("tsickle/src/transformer_util");
    /** isInNamespace returns true if any of node's ancestors is a namespace (ModuleDeclaration). */
    function isInNamespace(node) {
        // Must use the original node because node might have already been transformed, with node.parent
        // no longer being set.
        let parent = ts.getOriginalNode(node).parent;
        while (parent) {
            if (parent.kind === ts.SyntaxKind.ModuleDeclaration) {
                return true;
            }
            parent = parent.parent;
        }
        return false;
    }
    /**
     * getEnumMemberType computes the type of an enum member by inspecting its initializer expression.
     */
    function getEnumMemberType(typeChecker, member) {
        // Enum members without initialization have type 'number'
        if (!member.initializer) {
            return 'number';
        }
        const type = typeChecker.getTypeAtLocation(member.initializer);
        // Note: checking against 'NumberLike' instead of just 'Number' means this code
        // handles both
        //   MEMBER = 3,  // TypeFlags.NumberLiteral
        // and
        //   MEMBER = someFunction(),  // TypeFlags.Number
        if (type.flags & ts.TypeFlags.NumberLike) {
            return 'number';
        }
        // If the value is not a number, it must be a string.
        // TypeScript does not allow enum members to have any other type.
        return 'string';
    }
    /**
     * getEnumType computes the Closure type of an enum, by iterating through the members and gathering
     * their types.
     */
    function getEnumType(typeChecker, enumDecl) {
        let hasNumber = false;
        let hasString = false;
        for (const member of enumDecl.members) {
            const type = getEnumMemberType(typeChecker, member);
            if (type === 'string') {
                hasString = true;
            }
            else if (type === 'number') {
                hasNumber = true;
            }
        }
        if (hasNumber && hasString) {
            return '?'; // Closure's new type inference doesn't support enums of unions.
        }
        else if (hasNumber) {
            return 'number';
        }
        else if (hasString) {
            return 'string';
        }
        else {
            // Perhaps an empty enum?
            return '?';
        }
    }
    exports.getEnumType = getEnumType;
    /**
     * Transformer factory for the enum transformer. See fileoverview for details.
     */
    function enumTransformer(typeChecker, diagnostics) {
        return (context) => {
            function visitor(node) {
                if (!ts.isEnumDeclaration(node))
                    return ts.visitEachChild(node, visitor, context);
                // TODO(martinprobst): The enum transformer does not work for enums embedded in namespaces,
                // because TS does not support splitting export and declaration ("export {Foo};") in
                // namespaces. tsickle's emit for namespaces is unintelligible for Closure in any case, so
                // this is left to fix for another day.
                if (isInNamespace(node))
                    return ts.visitEachChild(node, visitor, context);
                // TypeScript does not emit any code for ambient enums, so early exit here to prevent the code
                // below from producing runtime values for an ambient structure.
                if (transformer_util_1.isAmbient(node))
                    return ts.visitEachChild(node, visitor, context);
                const isExported = transformer_util_1.hasModifierFlag(node, ts.ModifierFlags.Export);
                const enumType = getEnumType(typeChecker, node);
                const values = [];
                let enumIndex = 0;
                for (const member of node.members) {
                    let enumValue;
                    if (member.initializer) {
                        const enumConstValue = typeChecker.getConstantValue(member);
                        if (typeof enumConstValue === 'number') {
                            enumIndex = enumConstValue + 1;
                            enumValue = ts.createLiteral(enumConstValue);
                        }
                        else if (typeof enumConstValue === 'string') {
                            // tsickle does not care about string enum values. However TypeScript expects compile
                            // time constant enum values to be replaced with their constant expression, and e.g.
                            // doesn't emit imports for modules referenced in them. Because tsickle replaces the
                            // enum with an object literal, i.e. handles the enum transform, it must thus also do
                            // the const value substitution for strings.
                            enumValue = ts.createLiteral(enumConstValue);
                        }
                        else {
                            // Non-numeric enum value (string or an expression).
                            // Emit this initializer expression as-is.
                            // Note: if the member's initializer expression refers to another
                            // value within the enum (e.g. something like
                            //   enum Foo {
                            //     Field1,
                            //     Field2 = Field1 + something(),
                            //   }
                            // Then when we emit the initializer we produce invalid code because
                            // on the Closure side the reference to Field1 has to be namespaced,
                            // e.g. written "Foo.Field1 + something()".
                            // Hopefully this doesn't come up often -- if the enum instead has
                            // something like
                            //     Field2 = Field1 + 3,
                            // then it's still a constant expression and we inline the constant
                            // value in the above branch of this "if" statement.
                            enumValue = visitor(member.initializer);
                        }
                    }
                    else {
                        enumValue = ts.createLiteral(enumIndex);
                        enumIndex++;
                    }
                    values.push(ts.setOriginalNode(ts.setTextRange(ts.createPropertyAssignment(member.name, enumValue), member), member));
                }
                const varDecl = ts.createVariableDeclaration(node.name, /* type */ undefined, ts.createObjectLiteral(ts.setTextRange(ts.createNodeArray(values, true), node.members), true));
                const varDeclStmt = ts.setOriginalNode(ts.setTextRange(ts.createVariableStatement(
                /* modifiers */ undefined, ts.createVariableDeclarationList([varDecl], 
                /* create a const var */ ts.NodeFlags.Const)), node), node);
                const comment = {
                    kind: ts.SyntaxKind.MultiLineCommentTrivia,
                    text: `* @enum {${enumType}} `,
                    hasTrailingNewLine: true,
                    pos: -1,
                    end: -1
                };
                ts.setSyntheticLeadingComments(varDeclStmt, [comment]);
                const name = node.name.getText();
                const resultNodes = [varDeclStmt];
                if (isExported) {
                    // Create a separate export {...} statement, so that the enum name can be used in local
                    // type annotations within the file.
                    resultNodes.push(ts.createExportDeclaration(undefined, undefined, ts.createNamedExports([ts.createExportSpecifier(undefined, name)])));
                }
                if (transformer_util_1.hasModifierFlag(node, ts.ModifierFlags.Const)) {
                    // By TypeScript semantics, const enums disappear after TS compilation.
                    // We still need to generate the runtime value above to make Closure Compiler's type system
                    // happy and allow refering to enums from JS code, but we should at least not emit string
                    // value mappings.
                    return resultNodes;
                }
                // Emit the reverse mapping of foo[foo.BAR] = 'BAR'; lines for number enum members
                for (const member of node.members) {
                    const memberName = member.name;
                    const memberType = getEnumMemberType(typeChecker, member);
                    if (memberType !== 'number')
                        continue;
                    // TypeScript enum members can have Identifier names or String names.
                    // We need to emit slightly different code to support these two syntaxes:
                    let nameExpr;
                    let memberAccess;
                    if (ts.isIdentifier(memberName)) {
                        // Foo[Foo.ABC] = "ABC";
                        nameExpr = transformer_util_1.createSingleQuoteStringLiteral(memberName.text);
                        // Make sure to create a clean, new identifier, so comments do not get emitted twice.
                        const ident = ts.createIdentifier(transformer_util_1.getIdentifierText(memberName));
                        memberAccess = ts.createPropertyAccess(ts.createIdentifier(name), ident);
                    }
                    else {
                        // Foo[Foo["A B C"]] = "A B C"; or Foo[Foo[expression]] = expression;
                        nameExpr = ts.isComputedPropertyName(memberName) ? memberName.expression : memberName;
                        memberAccess = ts.createElementAccess(ts.createIdentifier(name), nameExpr);
                    }
                    resultNodes.push(ts.createStatement(ts.createAssignment(ts.createElementAccess(ts.createIdentifier(name), memberAccess), nameExpr)));
                }
                return resultNodes;
            }
            return (sf) => visitor(sf);
        };
    }
    exports.enumTransformer = enumTransformer;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW51bV90cmFuc2Zvcm1lci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9lbnVtX3RyYW5zZm9ybWVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRzs7Ozs7Ozs7Ozs7O0lBRUg7Ozs7Ozs7Ozs7O09BV0c7SUFFSCxpQ0FBaUM7SUFFakMsbUVBQWlIO0lBRWpILGdHQUFnRztJQUNoRyxTQUFTLGFBQWEsQ0FBQyxJQUFhO1FBQ2xDLGdHQUFnRztRQUNoRyx1QkFBdUI7UUFDdkIsSUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUM7UUFDN0MsT0FBTyxNQUFNLEVBQUU7WUFDYixJQUFJLE1BQU0sQ0FBQyxJQUFJLEtBQUssRUFBRSxDQUFDLFVBQVUsQ0FBQyxpQkFBaUIsRUFBRTtnQkFDbkQsT0FBTyxJQUFJLENBQUM7YUFDYjtZQUNELE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO1NBQ3hCO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7O09BRUc7SUFDSCxTQUFTLGlCQUFpQixDQUFDLFdBQTJCLEVBQUUsTUFBcUI7UUFDM0UseURBQXlEO1FBQ3pELElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxFQUFFO1lBQ3ZCLE9BQU8sUUFBUSxDQUFDO1NBQ2pCO1FBQ0QsTUFBTSxJQUFJLEdBQUcsV0FBVyxDQUFDLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUMvRCwrRUFBK0U7UUFDL0UsZUFBZTtRQUNmLDRDQUE0QztRQUM1QyxNQUFNO1FBQ04sa0RBQWtEO1FBQ2xELElBQUksSUFBSSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRTtZQUN4QyxPQUFPLFFBQVEsQ0FBQztTQUNqQjtRQUNELHFEQUFxRDtRQUNyRCxpRUFBaUU7UUFDakUsT0FBTyxRQUFRLENBQUM7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QUMsT0FBTyxDQUFDLEVBQUUsQ0FBa0IsQ0FBQztRQUM3RCxDQUFDLENBQUM7SUFDSixDQUFDO0lBbklELDBDQW1JQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRyYW5zZm9ybXMgVHlwZVNjcmlwdCBlbnVtIGRlY2xhcmF0aW9ucyB0byBDbG9zdXJlIGVudW0gZGVjbGFyYXRpb25zLCB3aGljaFxuICogbG9vayBsaWtlOlxuICpcbiAqICAgICAvLi4gQGVudW0ge251bWJlcn0gLi9cbiAqICAgICBjb25zdCBGb28gPSB7QkFSOiAwLCBCQVo6IDEsIC4uLn07XG4gKiAgICAgZXhwb3J0IHtGb299OyAgLy8gZXZlbiBpZiBvcmlnaW5hbGx5IGV4cG9ydGVkIG9uIG9uZSBsaW5lLlxuICpcbiAqIFRoaXMgZGVjbGFyZXMgYW4gZW51bSB0eXBlIGZvciBDbG9zdXJlIENvbXBpbGVyIChhbmQgQ2xvc3VyZSBKUyB1c2VycyBvZiB0aGlzIFRTIGNvZGUpLlxuICogU3BsaXR0aW5nIHRoZSBlbnVtIGludG8gZGVjbGFyYXRpb24gYW5kIGV4cG9ydCBpcyByZXF1aXJlZCBzbyB0aGF0IGxvY2FsIHJlZmVyZW5jZXMgdG8gdGhlXG4gKiB0eXBlIHJlc29sdmUgKFwiQHR5cGUge0Zvb31cIikuXG4gKi9cblxuaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmltcG9ydCB7Y3JlYXRlU2luZ2xlUXVvdGVTdHJpbmdMaXRlcmFsLCBnZXRJZGVudGlmaWVyVGV4dCwgaGFzTW9kaWZpZXJGbGFnLCBpc0FtYmllbnR9IGZyb20gJy4vdHJhbnNmb3JtZXJfdXRpbCc7XG5cbi8qKiBpc0luTmFtZXNwYWNlIHJldHVybnMgdHJ1ZSBpZiBhbnkgb2Ygbm9kZSdzIGFuY2VzdG9ycyBpcyBhIG5hbWVzcGFjZSAoTW9kdWxlRGVjbGFyYXRpb24pLiAqL1xuZnVuY3Rpb24gaXNJbk5hbWVzcGFjZShub2RlOiB0cy5Ob2RlKSB7XG4gIC8vIE11c3QgdXNlIHRoZSBvcmlnaW5hbCBub2RlIGJlY2F1c2Ugbm9kZSBtaWdodCBoYXZlIGFscmVhZHkgYmVlbiB0cmFuc2Zvcm1lZCwgd2l0aCBub2RlLnBhcmVudFxuICAvLyBubyBsb25nZXIgYmVpbmcgc2V0LlxuICBsZXQgcGFyZW50ID0gdHMuZ2V0T3JpZ2luYWxOb2RlKG5vZGUpLnBhcmVudDtcbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQua2luZCA9PT0gdHMuU3ludGF4S2luZC5Nb2R1bGVEZWNsYXJhdGlvbikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIGdldEVudW1NZW1iZXJUeXBlIGNvbXB1dGVzIHRoZSB0eXBlIG9mIGFuIGVudW0gbWVtYmVyIGJ5IGluc3BlY3RpbmcgaXRzIGluaXRpYWxpemVyIGV4cHJlc3Npb24uXG4gKi9cbmZ1bmN0aW9uIGdldEVudW1NZW1iZXJUeXBlKHR5cGVDaGVja2VyOiB0cy5UeXBlQ2hlY2tlciwgbWVtYmVyOiB0cy5FbnVtTWVtYmVyKTogJ251bWJlcid8J3N0cmluZycge1xuICAvLyBFbnVtIG1lbWJlcnMgd2l0aG91dCBpbml0aWFsaXphdGlvbiBoYXZlIHR5cGUgJ251bWJlcidcbiAgaWYgKCFtZW1iZXIuaW5pdGlhbGl6ZXIpIHtcbiAgICByZXR1cm4gJ251bWJlcic7XG4gIH1cbiAgY29uc3QgdHlwZSA9IHR5cGVDaGVja2VyLmdldFR5cGVBdExvY2F0aW9uKG1lbWJlci5pbml0aWFsaXplcik7XG4gIC8vIE5vdGU6IGNoZWNraW5nIGFnYWluc3QgJ051bWJlckxpa2UnIGluc3RlYWQgb2YganVzdCAnTnVtYmVyJyBtZWFucyB0aGlzIGNvZGVcbiAgLy8gaGFuZGxlcyBib3RoXG4gIC8vICAgTUVNQkVSID0gMywgIC8vIFR5cGVGbGFncy5OdW1iZXJMaXRlcmFsXG4gIC8vIGFuZFxuICAvLyAgIE1FTUJFUiA9IHNvbWVGdW5jdGlvbigpLCAgLy8gVHlwZUZsYWdzLk51bWJlclxuICBpZiAodHlwZS5mbGFncyAmIHRzLlR5cGVGbGFncy5OdW1iZXJMaWtlKSB7XG4gICAgcmV0dXJuICdudW1iZXInO1xuICB9XG4gIC8vIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBudW1iZXIsIGl0IG11c3QgYmUgYSBzdHJpbmcuXG4gIC8vIFR5cGVTY3JpcHQgZG9lcyBub3QgYWxsb3cgZW51bSBtZW1iZXJzIHRvIGhhdmUgYW55IG90aGVyIHR5cGUuXG4gIHJldHVybiAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBnZXRFbnVtVHlwZSBjb21wdXRlcyB0aGUgQ2xvc3VyZSB0eXBlIG9mIGFuIGVudW0sIGJ5IGl0ZXJhdGluZyB0aHJvdWdoIHRoZSBtZW1iZXJzIGFuZCBnYXRoZXJpbmdcbiAqIHRoZWlyIHR5cGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RW51bVR5cGUodHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyLCBlbnVtRGVjbDogdHMuRW51bURlY2xhcmF0aW9uKTogJ251bWJlcid8XG4gICAgJ3N0cmluZyd8Jz8nIHtcbiAgbGV0IGhhc051bWJlciA9IGZhbHNlO1xuICBsZXQgaGFzU3RyaW5nID0gZmFsc2U7XG4gIGZvciAoY29uc3QgbWVtYmVyIG9mIGVudW1EZWNsLm1lbWJlcnMpIHtcbiAgICBjb25zdCB0eXBlID0gZ2V0RW51bU1lbWJlclR5cGUodHlwZUNoZWNrZXIsIG1lbWJlcik7XG4gICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBoYXNTdHJpbmcgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGhhc051bWJlciA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChoYXNOdW1iZXIgJiYgaGFzU3RyaW5nKSB7XG4gICAgcmV0dXJuICc/JzsgIC8vIENsb3N1cmUncyBuZXcgdHlwZSBpbmZlcmVuY2UgZG9lc24ndCBzdXBwb3J0IGVudW1zIG9mIHVuaW9ucy5cbiAgfSBlbHNlIGlmIChoYXNOdW1iZXIpIHtcbiAgICByZXR1cm4gJ251bWJlcic7XG4gIH0gZWxzZSBpZiAoaGFzU3RyaW5nKSB7XG4gICAgcmV0dXJuICdzdHJpbmcnO1xuICB9IGVsc2Uge1xuICAgIC8vIFBlcmhhcHMgYW4gZW1wdHkgZW51bT9cbiAgICByZXR1cm4gJz8nO1xuICB9XG59XG5cbi8qKlxuICogVHJhbnNmb3JtZXIgZmFjdG9yeSBmb3IgdGhlIGVudW0gdHJhbnNmb3JtZXIuIFNlZSBmaWxlb3ZlcnZpZXcgZm9yIGRldGFpbHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnVtVHJhbnNmb3JtZXIodHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyLCBkaWFnbm9zdGljczogdHMuRGlhZ25vc3RpY1tdKTpcbiAgICAoY29udGV4dDogdHMuVHJhbnNmb3JtYXRpb25Db250ZXh0KSA9PiB0cy5UcmFuc2Zvcm1lcjx0cy5Tb3VyY2VGaWxlPiB7XG4gIHJldHVybiAoY29udGV4dDogdHMuVHJhbnNmb3JtYXRpb25Db250ZXh0KSA9PiB7XG4gICAgZnVuY3Rpb24gdmlzaXRvcjxUIGV4dGVuZHMgdHMuTm9kZT4obm9kZTogVCk6IFR8dHMuTm9kZVtdIHtcbiAgICAgIGlmICghdHMuaXNFbnVtRGVjbGFyYXRpb24obm9kZSkpIHJldHVybiB0cy52aXNpdEVhY2hDaGlsZChub2RlLCB2aXNpdG9yLCBjb250ZXh0KTtcblxuICAgICAgLy8gVE9ETyhtYXJ0aW5wcm9ic3QpOiBUaGUgZW51bSB0cmFuc2Zvcm1lciBkb2VzIG5vdCB3b3JrIGZvciBlbnVtcyBlbWJlZGRlZCBpbiBuYW1lc3BhY2VzLFxuICAgICAgLy8gYmVjYXVzZSBUUyBkb2VzIG5vdCBzdXBwb3J0IHNwbGl0dGluZyBleHBvcnQgYW5kIGRlY2xhcmF0aW9uIChcImV4cG9ydCB7Rm9vfTtcIikgaW5cbiAgICAgIC8vIG5hbWVzcGFjZXMuIHRzaWNrbGUncyBlbWl0IGZvciBuYW1lc3BhY2VzIGlzIHVuaW50ZWxsaWdpYmxlIGZvciBDbG9zdXJlIGluIGFueSBjYXNlLCBzb1xuICAgICAgLy8gdGhpcyBpcyBsZWZ0IHRvIGZpeCBmb3IgYW5vdGhlciBkYXkuXG4gICAgICBpZiAoaXNJbk5hbWVzcGFjZShub2RlKSkgcmV0dXJuIHRzLnZpc2l0RWFjaENoaWxkKG5vZGUsIHZpc2l0b3IsIGNvbnRleHQpO1xuXG4gICAgICAvLyBUeXBlU2NyaXB0IGRvZXMgbm90IGVtaXQgYW55IGNvZGUgZm9yIGFtYmllbnQgZW51bXMsIHNvIGVhcmx5IGV4aXQgaGVyZSB0byBwcmV2ZW50IHRoZSBjb2RlXG4gICAgICAvLyBiZWxvdyBmcm9tIHByb2R1Y2luZyBydW50aW1lIHZhbHVlcyBmb3IgYW4gYW1iaWVudCBzdHJ1Y3R1cmUuXG4gICAgICBpZiAoaXNBbWJpZW50KG5vZGUpKSByZXR1cm4gdHMudmlzaXRFYWNoQ2hpbGQobm9kZSwgdmlzaXRvciwgY29udGV4dCk7XG5cbiAgICAgIGNvbnN0IGlzRXhwb3J0ZWQgPSBoYXNNb2RpZmllckZsYWcobm9kZSwgdHMuTW9kaWZpZXJGbGFncy5FeHBvcnQpO1xuICAgICAgY29uc3QgZW51bVR5cGUgPSBnZXRFbnVtVHlwZSh0eXBlQ2hlY2tlciwgbm9kZSk7XG5cbiAgICAgIGNvbnN0IHZhbHVlczogdHMuUHJvcGVydHlBc3NpZ25tZW50W10gPSBbXTtcbiAgICAgIGxldCBlbnVtSW5kZXggPSAwO1xuICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2Ygbm9kZS5tZW1iZXJzKSB7XG4gICAgICAgIGxldCBlbnVtVmFsdWU6IHRzLkV4cHJlc3Npb247XG4gICAgICAgIGlmIChtZW1iZXIuaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgICBjb25zdCBlbnVtQ29uc3RWYWx1ZSA9IHR5cGVDaGVja2VyLmdldENvbnN0YW50VmFsdWUobWVtYmVyKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGVudW1Db25zdFZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZW51bUluZGV4ID0gZW51bUNvbnN0VmFsdWUgKyAxO1xuICAgICAgICAgICAgZW51bVZhbHVlID0gdHMuY3JlYXRlTGl0ZXJhbChlbnVtQ29uc3RWYWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZW51bUNvbnN0VmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyB0c2lja2xlIGRvZXMgbm90IGNhcmUgYWJvdXQgc3RyaW5nIGVudW0gdmFsdWVzLiBIb3dldmVyIFR5cGVTY3JpcHQgZXhwZWN0cyBjb21waWxlXG4gICAgICAgICAgICAvLyB0aW1lIGNvbnN0YW50IGVudW0gdmFsdWVzIHRvIGJlIHJlcGxhY2VkIHdpdGggdGhlaXIgY29uc3RhbnQgZXhwcmVzc2lvbiwgYW5kIGUuZy5cbiAgICAgICAgICAgIC8vIGRvZXNuJ3QgZW1pdCBpbXBvcnRzIGZvciBtb2R1bGVzIHJlZmVyZW5jZWQgaW4gdGhlbS4gQmVjYXVzZSB0c2lja2xlIHJlcGxhY2VzIHRoZVxuICAgICAgICAgICAgLy8gZW51bSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLCBpLmUuIGhhbmRsZXMgdGhlIGVudW0gdHJhbnNmb3JtLCBpdCBtdXN0IHRodXMgYWxzbyBkb1xuICAgICAgICAgICAgLy8gdGhlIGNvbnN0IHZhbHVlIHN1YnN0aXR1dGlvbiBmb3Igc3RyaW5ncy5cbiAgICAgICAgICAgIGVudW1WYWx1ZSA9IHRzLmNyZWF0ZUxpdGVyYWwoZW51bUNvbnN0VmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBOb24tbnVtZXJpYyBlbnVtIHZhbHVlIChzdHJpbmcgb3IgYW4gZXhwcmVzc2lvbikuXG4gICAgICAgICAgICAvLyBFbWl0IHRoaXMgaW5pdGlhbGl6ZXIgZXhwcmVzc2lvbiBhcy1pcy5cbiAgICAgICAgICAgIC8vIE5vdGU6IGlmIHRoZSBtZW1iZXIncyBpbml0aWFsaXplciBleHByZXNzaW9uIHJlZmVycyB0byBhbm90aGVyXG4gICAgICAgICAgICAvLyB2YWx1ZSB3aXRoaW4gdGhlIGVudW0gKGUuZy4gc29tZXRoaW5nIGxpa2VcbiAgICAgICAgICAgIC8vICAgZW51bSBGb28ge1xuICAgICAgICAgICAgLy8gICAgIEZpZWxkMSxcbiAgICAgICAgICAgIC8vICAgICBGaWVsZDIgPSBGaWVsZDEgKyBzb21ldGhpbmcoKSxcbiAgICAgICAgICAgIC8vICAgfVxuICAgICAgICAgICAgLy8gVGhlbiB3aGVuIHdlIGVtaXQgdGhlIGluaXRpYWxpemVyIHdlIHByb2R1Y2UgaW52YWxpZCBjb2RlIGJlY2F1c2VcbiAgICAgICAgICAgIC8vIG9uIHRoZSBDbG9zdXJlIHNpZGUgdGhlIHJlZmVyZW5jZSB0byBGaWVsZDEgaGFzIHRvIGJlIG5hbWVzcGFjZWQsXG4gICAgICAgICAgICAvLyBlLmcuIHdyaXR0ZW4gXCJGb28uRmllbGQxICsgc29tZXRoaW5nKClcIi5cbiAgICAgICAgICAgIC8vIEhvcGVmdWxseSB0aGlzIGRvZXNuJ3QgY29tZSB1cCBvZnRlbiAtLSBpZiB0aGUgZW51bSBpbnN0ZWFkIGhhc1xuICAgICAgICAgICAgLy8gc29tZXRoaW5nIGxpa2VcbiAgICAgICAgICAgIC8vICAgICBGaWVsZDIgPSBGaWVsZDEgKyAzLFxuICAgICAgICAgICAgLy8gdGhlbiBpdCdzIHN0aWxsIGEgY29uc3RhbnQgZXhwcmVzc2lvbiBhbmQgd2UgaW5saW5lIHRoZSBjb25zdGFudFxuICAgICAgICAgICAgLy8gdmFsdWUgaW4gdGhlIGFib3ZlIGJyYW5jaCBvZiB0aGlzIFwiaWZcIiBzdGF0ZW1lbnQuXG4gICAgICAgICAgICBlbnVtVmFsdWUgPSB2aXNpdG9yKG1lbWJlci5pbml0aWFsaXplcikgYXMgdHMuRXhwcmVzc2lvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW51bVZhbHVlID0gdHMuY3JlYXRlTGl0ZXJhbChlbnVtSW5kZXgpO1xuICAgICAgICAgIGVudW1JbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlcy5wdXNoKHRzLnNldE9yaWdpbmFsTm9kZShcbiAgICAgICAgICAgIHRzLnNldFRleHRSYW5nZSh0cy5jcmVhdGVQcm9wZXJ0eUFzc2lnbm1lbnQobWVtYmVyLm5hbWUsIGVudW1WYWx1ZSksIG1lbWJlciksIG1lbWJlcikpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB2YXJEZWNsID0gdHMuY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbihcbiAgICAgICAgICBub2RlLm5hbWUsIC8qIHR5cGUgKi8gdW5kZWZpbmVkLFxuICAgICAgICAgIHRzLmNyZWF0ZU9iamVjdExpdGVyYWwoXG4gICAgICAgICAgICAgIHRzLnNldFRleHRSYW5nZSh0cy5jcmVhdGVOb2RlQXJyYXkodmFsdWVzLCB0cnVlKSwgbm9kZS5tZW1iZXJzKSwgdHJ1ZSkpO1xuICAgICAgY29uc3QgdmFyRGVjbFN0bXQgPSB0cy5zZXRPcmlnaW5hbE5vZGUoXG4gICAgICAgICAgdHMuc2V0VGV4dFJhbmdlKFxuICAgICAgICAgICAgICB0cy5jcmVhdGVWYXJpYWJsZVN0YXRlbWVudChcbiAgICAgICAgICAgICAgICAgIC8qIG1vZGlmaWVycyAqLyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICB0cy5jcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uTGlzdChcbiAgICAgICAgICAgICAgICAgICAgICBbdmFyRGVjbF0sXG4gICAgICAgICAgICAgICAgICAgICAgLyogY3JlYXRlIGEgY29uc3QgdmFyICovIHRzLk5vZGVGbGFncy5Db25zdCkpLFxuICAgICAgICAgICAgICBub2RlKSxcbiAgICAgICAgICBub2RlKTtcbiAgICAgIGNvbnN0IGNvbW1lbnQ6IHRzLlN5bnRoZXNpemVkQ29tbWVudCA9IHtcbiAgICAgICAga2luZDogdHMuU3ludGF4S2luZC5NdWx0aUxpbmVDb21tZW50VHJpdmlhLFxuICAgICAgICB0ZXh0OiBgKiBAZW51bSB7JHtlbnVtVHlwZX19IGAsXG4gICAgICAgIGhhc1RyYWlsaW5nTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgcG9zOiAtMSxcbiAgICAgICAgZW5kOiAtMVxuICAgICAgfTtcbiAgICAgIHRzLnNldFN5bnRoZXRpY0xlYWRpbmdDb21tZW50cyh2YXJEZWNsU3RtdCwgW2NvbW1lbnRdKTtcblxuICAgICAgY29uc3QgbmFtZSA9IG5vZGUubmFtZS5nZXRUZXh0KCk7XG4gICAgICBjb25zdCByZXN1bHROb2RlczogdHMuTm9kZVtdID0gW3ZhckRlY2xTdG10XTtcbiAgICAgIGlmIChpc0V4cG9ydGVkKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIHNlcGFyYXRlIGV4cG9ydCB7Li4ufSBzdGF0ZW1lbnQsIHNvIHRoYXQgdGhlIGVudW0gbmFtZSBjYW4gYmUgdXNlZCBpbiBsb2NhbFxuICAgICAgICAvLyB0eXBlIGFubm90YXRpb25zIHdpdGhpbiB0aGUgZmlsZS5cbiAgICAgICAgcmVzdWx0Tm9kZXMucHVzaCh0cy5jcmVhdGVFeHBvcnREZWNsYXJhdGlvbihcbiAgICAgICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgdHMuY3JlYXRlTmFtZWRFeHBvcnRzKFt0cy5jcmVhdGVFeHBvcnRTcGVjaWZpZXIodW5kZWZpbmVkLCBuYW1lKV0pKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNNb2RpZmllckZsYWcobm9kZSwgdHMuTW9kaWZpZXJGbGFncy5Db25zdCkpIHtcbiAgICAgICAgLy8gQnkgVHlwZVNjcmlwdCBzZW1hbnRpY3MsIGNvbnN0IGVudW1zIGRpc2FwcGVhciBhZnRlciBUUyBjb21waWxhdGlvbi5cbiAgICAgICAgLy8gV2Ugc3RpbGwgbmVlZCB0byBnZW5lcmF0ZSB0aGUgcnVudGltZSB2YWx1ZSBhYm92ZSB0byBtYWtlIENsb3N1cmUgQ29tcGlsZXIncyB0eXBlIHN5c3RlbVxuICAgICAgICAvLyBoYXBweSBhbmQgYWxsb3cgcmVmZXJpbmcgdG8gZW51bXMgZnJvbSBKUyBjb2RlLCBidXQgd2Ugc2hvdWxkIGF0IGxlYXN0IG5vdCBlbWl0IHN0cmluZ1xuICAgICAgICAvLyB2YWx1ZSBtYXBwaW5ncy5cbiAgICAgICAgcmV0dXJuIHJlc3VsdE5vZGVzO1xuICAgICAgfVxuXG4gICAgICAvLyBFbWl0IHRoZSByZXZlcnNlIG1hcHBpbmcgb2YgZm9vW2Zvby5CQVJdID0gJ0JBUic7IGxpbmVzIGZvciBudW1iZXIgZW51bSBtZW1iZXJzXG4gICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiBub2RlLm1lbWJlcnMpIHtcbiAgICAgICAgY29uc3QgbWVtYmVyTmFtZSA9IG1lbWJlci5uYW1lO1xuICAgICAgICBjb25zdCBtZW1iZXJUeXBlID0gZ2V0RW51bU1lbWJlclR5cGUodHlwZUNoZWNrZXIsIG1lbWJlcik7XG4gICAgICAgIGlmIChtZW1iZXJUeXBlICE9PSAnbnVtYmVyJykgY29udGludWU7XG5cbiAgICAgICAgLy8gVHlwZVNjcmlwdCBlbnVtIG1lbWJlcnMgY2FuIGhhdmUgSWRlbnRpZmllciBuYW1lcyBvciBTdHJpbmcgbmFtZXMuXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZW1pdCBzbGlnaHRseSBkaWZmZXJlbnQgY29kZSB0byBzdXBwb3J0IHRoZXNlIHR3byBzeW50YXhlczpcbiAgICAgICAgbGV0IG5hbWVFeHByOiB0cy5FeHByZXNzaW9uO1xuICAgICAgICBsZXQgbWVtYmVyQWNjZXNzOiB0cy5FeHByZXNzaW9uO1xuICAgICAgICBpZiAodHMuaXNJZGVudGlmaWVyKG1lbWJlck5hbWUpKSB7XG4gICAgICAgICAgLy8gRm9vW0Zvby5BQkNdID0gXCJBQkNcIjtcbiAgICAgICAgICBuYW1lRXhwciA9IGNyZWF0ZVNpbmdsZVF1b3RlU3RyaW5nTGl0ZXJhbChtZW1iZXJOYW1lLnRleHQpO1xuICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0byBjcmVhdGUgYSBjbGVhbiwgbmV3IGlkZW50aWZpZXIsIHNvIGNvbW1lbnRzIGRvIG5vdCBnZXQgZW1pdHRlZCB0d2ljZS5cbiAgICAgICAgICBjb25zdCBpZGVudCA9IHRzLmNyZWF0ZUlkZW50aWZpZXIoZ2V0SWRlbnRpZmllclRleHQobWVtYmVyTmFtZSkpO1xuICAgICAgICAgIG1lbWJlckFjY2VzcyA9IHRzLmNyZWF0ZVByb3BlcnR5QWNjZXNzKHRzLmNyZWF0ZUlkZW50aWZpZXIobmFtZSksIGlkZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBGb29bRm9vW1wiQSBCIENcIl1dID0gXCJBIEIgQ1wiOyBvciBGb29bRm9vW2V4cHJlc3Npb25dXSA9IGV4cHJlc3Npb247XG4gICAgICAgICAgbmFtZUV4cHIgPSB0cy5pc0NvbXB1dGVkUHJvcGVydHlOYW1lKG1lbWJlck5hbWUpID8gbWVtYmVyTmFtZS5leHByZXNzaW9uIDogbWVtYmVyTmFtZTtcbiAgICAgICAgICBtZW1iZXJBY2Nlc3MgPSB0cy5jcmVhdGVFbGVtZW50QWNjZXNzKHRzLmNyZWF0ZUlkZW50aWZpZXIobmFtZSksIG5hbWVFeHByKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHROb2Rlcy5wdXNoKHRzLmNyZWF0ZVN0YXRlbWVudCh0cy5jcmVhdGVBc3NpZ25tZW50KFxuICAgICAgICAgICAgdHMuY3JlYXRlRWxlbWVudEFjY2Vzcyh0cy5jcmVhdGVJZGVudGlmaWVyKG5hbWUpLCBtZW1iZXJBY2Nlc3MpLCBuYW1lRXhwcikpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHROb2RlcztcbiAgICB9XG5cbiAgICByZXR1cm4gKHNmOiB0cy5Tb3VyY2VGaWxlKSA9PiB2aXNpdG9yKHNmKSBhcyB0cy5Tb3VyY2VGaWxlO1xuICB9O1xufVxuIl19