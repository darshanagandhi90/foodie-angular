/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/externs", ["require", "exports", "typescript", "tsickle/src/annotator_host", "tsickle/src/enum_transformer", "tsickle/src/googmodule", "tsickle/src/jsdoc", "tsickle/src/jsdoc_transformer", "tsickle/src/module_type_translator", "tsickle/src/path", "tsickle/src/transformer_util", "tsickle/src/type_translator"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @fileoverview Externs creates Closure Compiler #externs definitions from the
     * ambient declarations in a TypeScript file.
     *
     * (Note that we cannot write the "@" form of the externs tag, even in comments,
     * because the compiler greps for it in source files(!).  So we write #externs
     * instead.)
     *
     * For example, a
     *   declare interface Foo { bar: string; }
     *
     * Would generate a
     *   /.. #externs ./
     *   /.. @record ./
     *   var Foo = function() {};
     *   /.. @type {string} ./
     *   Foo.prototype.bar;
     *
     * The generated externs indicate to Closure Compiler that symbols are external
     * to the optimization process, i.e. they are provided by outside code. That
     * most importantly means they must not be renamed or removed.
     *
     * A major difficulty here is that TypeScript supports module-scoped external
     * symbols; `.d.ts` files can contain `export`s and `import` other files.
     * Closure Compiler does not have such a concept, so tsickle must emulate the
     * behaviour. It does so by following this scheme:
     *
     * 1. non-module .d.ts produces global symbols
     * 2. module .d.ts produce symbols namespaced to the module, by creating a
     *    mangled name matching the current file's path. tsickle expects outside
     *    code (e.g. build system integration or manually written code) to contain a
     *    goog.module/provide that references the mangled path.
     * 3. declarations in `.ts` files produce types that can be separately emitted
     *    in e.g. an `externs.js`, using `getGeneratedExterns` below.
     *    1. non-exported symbols produce global types, because that's what users
     *       expect and it matches TypeScripts emit, which just references `Foo` for
     *       a locally declared symbol `Foo` in a module. Arguably these should be
     *       wrapped in `declare global { ... }`.
     *    2. exported symbols are scoped to the `.ts` file by prefixing them with a
     *       mangled name. Exported types are re-exported from the JavaScript
     *       `goog.module`, allowing downstream code to reference them. This has the
     *       same problem regarding ambient values as above, it is unclear where the
     *       value symbol would be defined, so for the time being this is
     *       unsupported.
     *
     * The effect of this is that:
     * - symbols in a module (i.e. not globals) are generally scoped to the local
     *   module using a mangled name, preventing symbol collisions on the Closure
     *   side.
     * - importing code can unconditionally refer to and import any symbol defined
     *   in a module `X` as `path.to.module.X`, regardless of whether the defining
     *   location is a `.d.ts` file or a `.ts` file, and regardless whether the
     *   symbol is ambient (assuming there's an appropriate shim).
     * - if there is a shim present, tsickle avoids emitting the Closure namespace
     *   itself, expecting the shim to provide the namespace and initialize it to a
     *   symbol that provides the right value at runtime (i.e. the implementation of
     *   whatever third party library the .d.ts describes).
     */
    const ts = require("typescript");
    const annotator_host_1 = require("tsickle/src/annotator_host");
    const enum_transformer_1 = require("tsickle/src/enum_transformer");
    const googmodule_1 = require("tsickle/src/googmodule");
    const jsdoc = require("tsickle/src/jsdoc");
    const jsdoc_transformer_1 = require("tsickle/src/jsdoc_transformer");
    const module_type_translator_1 = require("tsickle/src/module_type_translator");
    const path = require("tsickle/src/path");
    const transformer_util_1 = require("tsickle/src/transformer_util");
    const type_translator_1 = require("tsickle/src/type_translator");
    /**
     * Symbols that are already declared as externs in Closure, that should
     * be avoided by tsickle's "declare ..." => externs.js conversion.
     */
    const CLOSURE_EXTERNS_BLACKLIST = [
        'exports',
        'global',
        'module',
        // ErrorConstructor is the interface of the Error object itself.
        // tsickle detects that this is part of the TypeScript standard library
        // and assumes it's part of the Closure standard library, but this
        // assumption is wrong for ErrorConstructor.  To properly handle this
        // we'd somehow need to map methods defined on the ErrorConstructor
        // interface into properties on Closure's Error object, but for now it's
        // simpler to just blacklist it.
        'ErrorConstructor',
        'Symbol',
        'WorkerGlobalScope',
    ];
    /**
     * The header to be used in generated externs.  This is not included in the output of
     * generateExterns() because generateExterns() works one file at a time, and typically you create
     * one externs file from the entire compilation unit.
     *
     * Suppressions:
     * - duplicate: because externs might duplicate re-opened definitions from other JS files.
     * - checkTypes: Closure's type system does not match TS'.
     * - undefinedNames: code below tries to be careful not to overwrite previously emitted definitions,
     *   but on the flip side might accidentally miss definitions.
     */
    const EXTERNS_HEADER = `/**
 * @${''}externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
`;
    /**
     * Concatenate all generated externs definitions together into a string, including a file comment
     * header.
     *
     * @param rootDir Project root.  Emitted comments will reference paths relative to this root.
     *    This param is effectively required, but made optional here until Angular is fixed.
     */
    function getGeneratedExterns(externs, rootDir = '') {
        let allExterns = EXTERNS_HEADER;
        for (const fileName of Object.keys(externs)) {
            allExterns += `// externs from ${path.relative(rootDir, fileName)}:\n`;
            allExterns += externs[fileName];
        }
        return allExterns;
    }
    exports.getGeneratedExterns = getGeneratedExterns;
    /**
     * isInGlobalAugmentation returns true if declaration is the immediate child of a 'declare global'
     * block.
     */
    function isInGlobalAugmentation(declaration) {
        // declare global { ... } creates a ModuleDeclaration containing a ModuleBlock containing the
        // declaration, with the ModuleDeclaration having the GlobalAugmentation flag set.
        if (!declaration.parent || !declaration.parent.parent)
            return false;
        return (declaration.parent.parent.flags & ts.NodeFlags.GlobalAugmentation) !== 0;
    }
    /**
     * generateExterns generates extern definitions for all ambient declarations in the given source
     * file. It returns a string representation of the Closure JavaScript, not including the initial
     * comment with \@fileoverview and #externs (see above for that).
     */
    function generateExterns(typeChecker, sourceFile, host, moduleResolutionHost, options) {
        let output = '';
        const diagnostics = [];
        const isDts = transformer_util_1.isDtsFileName(sourceFile.fileName);
        const isExternalModule = ts.isExternalModule(sourceFile);
        const mtt = new module_type_translator_1.ModuleTypeTranslator(sourceFile, typeChecker, host, diagnostics, /*isForExterns*/ true);
        // .d.ts files declare symbols. The code below translates these into a form understood by Closure
        // Compiler, converting the type syntax, but also converting symbol names into a form accessible
        // to Closure Compiler.
        // Like regular .ts files, .d.ts can be either scripts or modules. Scripts declare symbols in the
        // global namespace, which has the same semantics in Closure and TypeScript, so the code below
        // emits those with the same name.
        // Modules however declare symbols scoped to the module that can be exported. Closure has no
        // concept of externs that are non-global, so tsickle needs to mangle the symbol names, both at
        // their declaration and at their use site.
        // This mangling happens by wrapping all declared symbols in a namespace based on the file name.
        // This namespace is then essentially the exports object for the ambient module (externs in
        // Closure terms). This namespace is called `moduleNamespace` below:
        let moduleNamespace = '';
        if (isExternalModule) {
            moduleNamespace = annotator_host_1.moduleNameAsIdentifier(host, sourceFile.fileName);
        }
        // Symbols are generated starting in rootNamespace. For script .d.ts with global symbols, this is
        // the empty string. For most module `.d.ts` files, this is the mangled namespace object. The
        // remaining special case are `.d.ts` files containing an `export = something;` statement. In
        // these, the effective exports object, i.e. the object containing the symbols that importing code
        // receives, is different from the main module scope.
        // tsickle handles the `export =` case by generating symbols in a different namespace (escaped
        // with a `_`) below, and then assigning whatever is actually exported into the `moduleNamespace`
        // below.
        let rootNamespace = moduleNamespace;
        // There can only be one export =, and if there is one, there cannot be any other exports.
        const exportAssignment = sourceFile.statements.find(ts.isExportAssignment);
        const hasExportEquals = exportAssignment && exportAssignment.isExportEquals;
        if (hasExportEquals) {
            // If so, move all generated symbols into a different sub-namespace, so that later on we can
            // control what exactly goes on the actual exported namespace.
            rootNamespace = rootNamespace + '_';
        }
        for (const stmt of sourceFile.statements) {
            if (!isDts && !transformer_util_1.hasModifierFlag(stmt, ts.ModifierFlags.Ambient)) {
                continue;
            }
            visitor(stmt, []);
        }
        /**
         * Convert a qualified name from a .d.ts file or declaration context into a mangled identifier.
         * E.g. for a qualified name in `export = someName;` or `import = someName;`.
         * If `someName` is `declare global { namespace someName {...} }`, tsickle must not qualify access
         * to it with the mangled module namespace as it is emitted in the global namespace. Similarly, if
         * the symbol is declared in a non-module context, it must not be mangled.
         */
        function qualifiedNameToMangledIdentifier(name) {
            const entityName = transformer_util_1.getEntityNameText(name);
            let symbol = typeChecker.getSymbolAtLocation(name);
            if (symbol) {
                // If this is an aliased name (e.g. from an import), use the alias to refer to it.
                if (symbol.flags & ts.SymbolFlags.Alias) {
                    symbol = typeChecker.getAliasedSymbol(symbol);
                }
                const alias = mtt.symbolsToAliasedNames.get(symbol);
                if (alias)
                    return alias;
                const isGlobalSymbol = symbol && symbol.declarations && symbol.declarations.some(d => {
                    if (isInGlobalAugmentation(d))
                        return true;
                    // If the declaration's source file is not a module, it must be global.
                    // If it is a module, the identifier must be local to this file, or handled above via the
                    // alias.
                    return !ts.isExternalModule(d.getSourceFile());
                });
                if (isGlobalSymbol)
                    return entityName;
            }
            return rootNamespace + '.' + entityName;
        }
        if (output && isExternalModule) {
            // If tsickle generated any externs and this is an external module, prepend the namespace
            // declaration for it.
            output = `/** @const */\nvar ${rootNamespace} = {};\n` + output;
            let exportedNamespace = rootNamespace;
            if (exportAssignment && hasExportEquals) {
                if (ts.isIdentifier(exportAssignment.expression) ||
                    ts.isQualifiedName(exportAssignment.expression)) {
                    // E.g. export = someName;
                    // If someName is "declare global { namespace someName {...} }", tsickle must not qualify
                    // access to it with module namespace as it is emitted in the global namespace.
                    exportedNamespace = qualifiedNameToMangledIdentifier(exportAssignment.expression);
                }
                else {
                    transformer_util_1.reportDiagnostic(diagnostics, exportAssignment.expression, `export = expression must be a qualified name, got ${ts.SyntaxKind[exportAssignment.expression.kind]}.`);
                }
                // Assign the actually exported namespace object (which lives somewhere under rootNamespace)
                // into the module's namespace.
                emit(`/**\n * export = ${exportAssignment.expression.getText()}\n * @const\n */\n`);
                emit(`var ${moduleNamespace} = ${exportedNamespace};\n`);
            }
            if (isDts && host.provideExternalModuleDtsNamespace) {
                // In a non-shimmed module, create a global namespace. This exists purely for backwards
                // compatiblity, in the medium term all code using tsickle should always use `goog.module`s,
                // so global names should not be neccessary.
                for (const nsExport of sourceFile.statements.filter(ts.isNamespaceExportDeclaration)) {
                    const namespaceName = transformer_util_1.getIdentifierText(nsExport.name);
                    emit(`// export as namespace ${namespaceName}\n`);
                    writeVariableStatement(namespaceName, [], exportedNamespace);
                }
            }
        }
        return { output, diagnostics };
        function emit(str) {
            output += str;
        }
        /**
         * isFirstDeclaration returns true if decl is the first declaration
         * of its symbol.  E.g. imagine
         *   interface Foo { x: number; }
         *   interface Foo { y: number; }
         * we only want to emit the "\@record" for Foo on the first one.
         *
         * The exception are variable declarations, which - in externs - do not assign a value:
         *   /.. \@type {...} ./
         *   var someVariable;
         *   /.. \@type {...} ./
         *   someNamespace.someVariable;
         * If a later declaration wants to add additional properties on someVariable, tsickle must still
         * emit an assignment into the object, as it's otherwise absent.
         */
        function isFirstValueDeclaration(decl) {
            if (!decl.name)
                return true;
            const sym = typeChecker.getSymbolAtLocation(decl.name);
            if (!sym.declarations || sym.declarations.length < 2)
                return true;
            const earlierDecls = sym.declarations.slice(0, sym.declarations.indexOf(decl));
            // Either there are no earlier declarations, or all of them are variables (see above). tsickle
            // emits a value for all other declaration kinds (function for functions, classes, interfaces,
            // {} object for namespaces).
            return earlierDecls.length === 0 || earlierDecls.every(ts.isVariableDeclaration);
        }
        /** Writes the actual variable statement of a Closure variable declaration. */
        function writeVariableStatement(name, namespace, value) {
            const qualifiedName = namespace.concat([name]).join('.');
            if (namespace.length === 0)
                emit(`var `);
            emit(qualifiedName);
            if (value)
                emit(` = ${value}`);
            emit(';\n');
        }
        /**
         * Writes a Closure variable declaration, i.e. the variable statement with a leading JSDoc
         * comment making it a declaration.
         */
        function writeVariableDeclaration(decl, namespace) {
            if (decl.name.kind === ts.SyntaxKind.Identifier) {
                const name = transformer_util_1.getIdentifierText(decl.name);
                if (CLOSURE_EXTERNS_BLACKLIST.indexOf(name) >= 0)
                    return;
                emit(jsdoc.toString([{ tagName: 'type', type: mtt.typeToClosure(decl) }]));
                emit('\n');
                writeVariableStatement(name, namespace);
            }
            else {
                errorUnimplementedKind(decl.name, 'externs for variable');
            }
        }
        /**
         * Emits a JSDoc declaration that merges the signatures of the given function declaration (for
         * overloads), and returns the parameter names chosen.
         */
        function emitFunctionType(decls, extraTags = []) {
            const { tags, parameterNames } = mtt.getFunctionTypeJSDoc(decls, extraTags);
            emit('\n');
            emit(jsdoc.toString(tags));
            return parameterNames;
        }
        function writeFunction(name, params, namespace) {
            const paramsStr = params.join(', ');
            if (namespace.length > 0) {
                let fqn = namespace.join('.');
                if (name.kind === ts.SyntaxKind.Identifier) {
                    fqn += '.'; // computed names include [ ] in their getText() representation.
                }
                fqn += name.getText();
                emit(`${fqn} = function(${paramsStr}) {};\n`);
            }
            else {
                if (name.kind !== ts.SyntaxKind.Identifier) {
                    transformer_util_1.reportDiagnostic(diagnostics, name, 'Non-namespaced computed name in externs');
                }
                emit(`function ${name.getText()}(${paramsStr}) {}\n`);
            }
        }
        function writeEnum(decl, namespace) {
            // E.g. /** @enum {number} */ var COUNTRY = {US: 1, CA: 1};
            const name = transformer_util_1.getIdentifierText(decl.name);
            let members = '';
            const enumType = enum_transformer_1.getEnumType(typeChecker, decl);
            // Closure enums members must have a value of the correct type, but the actual value does not
            // matter in externs.
            const initializer = enumType === 'string' ? `''` : 1;
            for (const member of decl.members) {
                let memberName;
                switch (member.name.kind) {
                    case ts.SyntaxKind.Identifier:
                        memberName = transformer_util_1.getIdentifierText(member.name);
                        break;
                    case ts.SyntaxKind.StringLiteral:
                        const text = member.name.text;
                        if (type_translator_1.isValidClosurePropertyName(text))
                            memberName = text;
                        break;
                    default:
                        break;
                }
                if (!memberName) {
                    members += `  /* TODO: ${ts.SyntaxKind[member.name.kind]}: ${jsdoc_transformer_1.escapeForComment(member.name.getText())} */\n`;
                    continue;
                }
                members += `  ${memberName}: ${initializer},\n`;
            }
            emit(`\n/** @enum {${enumType}} */\n`);
            writeVariableStatement(name, namespace, `{\n${members}}`);
        }
        function writeTypeAlias(decl, namespace) {
            const typeStr = mtt.typeToClosure(decl, undefined);
            emit(`\n/** @typedef {${typeStr}} */\n`);
            writeVariableStatement(transformer_util_1.getIdentifierText(decl.name), namespace);
        }
        function writeType(decl, namespace) {
            const name = decl.name;
            if (!name) {
                transformer_util_1.reportDiagnostic(diagnostics, decl, 'anonymous type in externs');
                return;
            }
            const typeName = namespace.concat([name.getText()]).join('.');
            if (CLOSURE_EXTERNS_BLACKLIST.indexOf(typeName) >= 0)
                return;
            if (isFirstValueDeclaration(decl)) {
                // Emit the 'function' that is actually the declaration of the interface
                // itself.  If it's a class, this function also must include the type
                // annotations of the constructor.
                let paramNames = [];
                const jsdocTags = [];
                let wroteJsDoc = false;
                jsdoc_transformer_1.maybeAddHeritageClauses(jsdocTags, mtt, decl);
                jsdoc_transformer_1.maybeAddTemplateClause(jsdocTags, decl);
                if (decl.kind === ts.SyntaxKind.ClassDeclaration) {
                    // TODO: it appears you can just write 'class Foo { ...' in externs.
                    // This code instead tries to translate it to a function.
                    jsdocTags.push({ tagName: 'constructor' }, { tagName: 'struct' });
                    const ctors = decl
                        .members.filter((m) => m.kind === ts.SyntaxKind.Constructor);
                    if (ctors.length) {
                        const firstCtor = ctors[0];
                        if (ctors.length > 1) {
                            paramNames = emitFunctionType(ctors, jsdocTags);
                        }
                        else {
                            paramNames = emitFunctionType([firstCtor], jsdocTags);
                        }
                        wroteJsDoc = true;
                    }
                }
                else {
                    // Otherwise it's an interface; tag it as structurally typed.
                    jsdocTags.push({ tagName: 'record' }, { tagName: 'struct' });
                }
                if (!wroteJsDoc)
                    emit(jsdoc.toString(jsdocTags));
                writeFunction(name, paramNames, namespace);
            }
            // Process everything except (MethodSignature|MethodDeclaration|Constructor)
            const methods = new Map();
            for (const member of decl.members) {
                switch (member.kind) {
                    case ts.SyntaxKind.PropertySignature:
                    case ts.SyntaxKind.PropertyDeclaration:
                        const prop = member;
                        if (prop.name.kind === ts.SyntaxKind.Identifier) {
                            let type = mtt.typeToClosure(prop);
                            if (prop.questionToken && type === '?') {
                                // An optional 'any' type translates to '?|undefined' in Closure.
                                type = '?|undefined';
                            }
                            emit(jsdoc.toString([{ tagName: 'type', type }]));
                            if (transformer_util_1.hasModifierFlag(prop, ts.ModifierFlags.Static)) {
                                emit(`\n${typeName}.${prop.name.getText()};\n`);
                            }
                            else {
                                emit(`\n${typeName}.prototype.${prop.name.getText()};\n`);
                            }
                            continue;
                        }
                        // TODO: For now property names other than Identifiers are not handled; e.g.
                        //    interface Foo { "123bar": number }
                        break;
                    case ts.SyntaxKind.MethodSignature:
                    case ts.SyntaxKind.MethodDeclaration:
                        const method = member;
                        const isStatic = transformer_util_1.hasModifierFlag(method, ts.ModifierFlags.Static);
                        const methodSignature = `${method.name.getText()}$$$${isStatic ? 'static' : 'instance'}`;
                        if (methods.has(methodSignature)) {
                            methods.get(methodSignature).push(method);
                        }
                        else {
                            methods.set(methodSignature, [method]);
                        }
                        continue;
                    case ts.SyntaxKind.Constructor:
                        continue; // Handled above.
                    default:
                        // Members can include things like index signatures, for e.g.
                        //   interface Foo { [key: string]: number; }
                        // For now, just skip it.
                        break;
                }
                // If we get here, the member wasn't handled in the switch statement.
                let memberName = namespace;
                if (member.name) {
                    memberName = memberName.concat([member.name.getText()]);
                }
                emit(`\n/* TODO: ${ts.SyntaxKind[member.kind]}: ${memberName.join('.')} */\n`);
            }
            // Handle method declarations/signatures separately, since we need to deal with overloads.
            for (const methodVariants of Array.from(methods.values())) {
                const firstMethodVariant = methodVariants[0];
                let parameterNames;
                if (methodVariants.length > 1) {
                    parameterNames = emitFunctionType(methodVariants);
                }
                else {
                    parameterNames = emitFunctionType([firstMethodVariant]);
                }
                const methodNamespace = namespace.concat([name.getText()]);
                // If the method is static, don't add the prototype.
                if (!transformer_util_1.hasModifierFlag(firstMethodVariant, ts.ModifierFlags.Static)) {
                    methodNamespace.push('prototype');
                }
                writeFunction(firstMethodVariant.name, parameterNames, methodNamespace);
            }
        }
        function writeExportDeclaration(exportDeclaration, namespace) {
            if (!exportDeclaration.exportClause) {
                emit(`\n// TODO(tsickle): export * declaration in ${debugLocationStr(exportDeclaration, namespace)}\n`);
                return;
            }
            for (const exportSpecifier of exportDeclaration.exportClause.elements) {
                // No need to do anything for properties exported under their original name.
                if (!exportSpecifier.propertyName)
                    continue;
                emit('/** @const */\n');
                writeVariableStatement(exportSpecifier.name.text, namespace, namespace.join('.') + '.' + exportSpecifier.propertyName.text);
            }
        }
        /**
         * Adds aliases for the symbols imported in the given declaration, so that their types get
         * printed as the fully qualified name, and not just as a reference to the local import alias.
         *
         * tsickle generates .js files that (at most) contain a `goog.provide`, but are not
         * `goog.module`s. These files cannot express an aliased import. However Closure Compiler allows
         * referencing types using fully qualified names in such files, so tsickle can resolve the
         * imported module URI and produce `path.to.module.Symbol` as an alias, and use that when
         * referencing the type.
         */
        function addImportAliases(decl) {
            let moduleUri;
            if (ts.isImportDeclaration(decl)) {
                moduleUri = decl.moduleSpecifier.text;
            }
            else if (ts.isExternalModuleReference(decl.moduleReference)) {
                // import foo = require('./bar');
                moduleUri = decl.moduleReference.expression.text;
            }
            else {
                // import foo = bar.baz.bam;
                // handled at call site.
                return;
            }
            if (ts.isImportEqualsDeclaration(decl)) {
                // import foo = require('./bar');
                addImportAlias(decl.name, moduleUri, undefined);
                return;
            }
            // Side effect import, like "import 'somepath';" declares no local aliases.
            if (!decl.importClause)
                return;
            if (decl.importClause.name) {
                // import name from ... -> map to .default on the module.name.
                addImportAlias(decl.importClause.name, moduleUri, 'default');
            }
            const namedBindings = decl.importClause.namedBindings;
            if (!namedBindings)
                return;
            if (ts.isNamespaceImport(namedBindings)) {
                // import * as name -> map directly to the module.name.
                addImportAlias(namedBindings.name, moduleUri, undefined);
            }
            if (ts.isNamedImports(namedBindings)) {
                // import {A as B}, map to module.name.A
                for (const namedBinding of namedBindings.elements) {
                    addImportAlias(namedBinding.name, moduleUri, namedBinding.name);
                }
            }
        }
        /**
         * Adds an import alias for the symbol defined at the given node. Creates an alias name based on
         * the given moduleName and (optionally) the name.
         */
        function addImportAlias(node, moduleUri, name) {
            let symbol = typeChecker.getSymbolAtLocation(node);
            if (!symbol) {
                transformer_util_1.reportDiagnostic(diagnostics, node, `named import has no symbol`);
                return;
            }
            if (symbol.flags & ts.SymbolFlags.Alias) {
                symbol = typeChecker.getAliasedSymbol(symbol);
            }
            const googNamespace = googmodule_1.extractGoogNamespaceImport(moduleUri);
            let aliasName;
            if (googNamespace) {
                aliasName = googNamespace;
            }
            else {
                // While type_translator does add the mangled prefix for ambient declarations, it only does so
                // for non-aliased (i.e. not imported) symbols. That's correct for its use in regular modules,
                // which will have a local symbol for the imported ambient symbol. However within an externs
                // file, there are no imports, so we need to make sure the alias already contains the correct
                // module name, which means the mangled module name in case of imports symbols.
                // This only applies to non-Closure ('goog:') imports.
                const isAmbientModuleDeclaration = symbol.declarations && symbol.declarations.some(d => transformer_util_1.isAmbient(d));
                const fullUri = googmodule_1.resolveModuleName(host, sourceFile.fileName, moduleUri);
                if (isAmbientModuleDeclaration) {
                    aliasName = annotator_host_1.moduleNameAsIdentifier(host, fullUri);
                }
                else {
                    aliasName = host.pathToModuleName(sourceFile.fileName, googmodule_1.resolveModuleName(host, sourceFile.fileName, fullUri));
                }
                if (typeof name === 'string') {
                    aliasName += '.' + name;
                }
                else if (name) {
                    aliasName += '.' + transformer_util_1.getIdentifierText(name);
                }
            }
            mtt.symbolsToAliasedNames.set(symbol, aliasName);
        }
        /**
         * Produces a compiler error that references the Node's kind. This is useful for the "else"
         * branch of code that is attempting to handle all possible input Node types, to ensure all cases
         * covered.
         */
        function errorUnimplementedKind(node, where) {
            transformer_util_1.reportDiagnostic(diagnostics, node, `${ts.SyntaxKind[node.kind]} not implemented in ${where}`);
        }
        /**
         * getNamespaceForLocalDeclaration returns the namespace that should be used for the given
         * declaration, deciding whether to namespace the symbol to the file or whether to create a
         * global name.
         *
         * The function covers these cases:
         * 1) a declaration in a .d.ts
         * 1a) where the .d.ts is an external module     --> namespace
         * 1b) where the .d.ts is not an external module --> global
         * 2) a declaration in a .ts file (all are treated as modules)
         * 2a) that is exported                          --> namespace
         * 2b) that is unexported                        --> global
         *
         * For 1), all symbols in .d.ts should generally be namespaced to the file to avoid collisions.
         * However .d.ts files that are not external modules do declare global names (1b).
         *
         * For 2), ambient declarations in .ts files must be namespaced, for the same collision reasons.
         * The exception is 2b), where in TypeScript, an unexported local "declare const x: string;"
         * creates a symbol that, when used locally, is emitted as just "x". That is, it behaves
         * like a variable declared in a 'declare global' block. Closure Compiler would fail the build if
         * there is no declaration for "x", so tsickle must generate a global external symbol, i.e.
         * without the namespace wrapper.
         */
        function getNamespaceForTopLevelDeclaration(declaration, namespace) {
            // Only use rootNamespace for top level symbols, any other namespacing (global names, nested
            // namespaces) is always kept.
            if (namespace.length !== 0)
                return namespace;
            // All names in a module (external) .d.ts file can only be accessed locally, so they always get
            // namespace prefixed.
            if (isDts && isExternalModule)
                return [rootNamespace];
            // Same for exported declarations in regular .ts files.
            if (transformer_util_1.hasModifierFlag(declaration, ts.ModifierFlags.Export))
                return [rootNamespace];
            // But local declarations in .ts files or .d.ts files (1b, 2b) are global, too.
            return [];
        }
        /**
         * Returns a string representation for the location: either the namespace, or, if empty, the
         * current source file name. This is intended to be included in the emit for warnings, so that
         * users can more easily find where a problematic definition is from.
         *
         * The code below does not use diagnostics to avoid breaking the build for harmless unhandled
         * cases.
         */
        function debugLocationStr(node, namespace) {
            // Use a regex to grab the filename without a path, to make the output stable
            // under bazel where sandboxes use different paths.
            return namespace.join('.') || node.getSourceFile().fileName.replace(/.*[/\\]/, '');
        }
        function visitor(node, namespace) {
            if (node.parent === sourceFile) {
                namespace = getNamespaceForTopLevelDeclaration(node, namespace);
            }
            switch (node.kind) {
                case ts.SyntaxKind.ModuleDeclaration:
                    const decl = node;
                    switch (decl.name.kind) {
                        case ts.SyntaxKind.Identifier:
                            if (decl.flags & ts.NodeFlags.GlobalAugmentation) {
                                // E.g. "declare global { ... }".  Reset to the outer namespace.
                                namespace = [];
                            }
                            else {
                                // E.g. "declare namespace foo {"
                                const name = transformer_util_1.getIdentifierText(decl.name);
                                if (isFirstValueDeclaration(decl)) {
                                    emit('/** @const */\n');
                                    writeVariableStatement(name, namespace, '{}');
                                }
                                namespace = namespace.concat(name);
                            }
                            if (decl.body)
                                visitor(decl.body, namespace);
                            break;
                        case ts.SyntaxKind.StringLiteral:
                            // E.g. "declare module 'foo' {" (note the quotes).
                            // We still want to emit externs for this module, but Closure doesn't provide a
                            // mechanism for module-scoped externs. Instead, we emit in a mangled namespace.
                            // The mangled namespace (after resolving files) matches the emit for an original module
                            // file, so effectively this augments any existing module.
                            const importName = decl.name.text;
                            const importedModuleName = googmodule_1.resolveModuleName({ moduleResolutionHost, options }, sourceFile.fileName, importName);
                            const mangled = annotator_host_1.moduleNameAsIdentifier(host, importedModuleName);
                            emit(`// Derived from: declare module "${importName}"\n`);
                            namespace = [mangled];
                            // Declare "mangled$name" if it's not declared already elsewhere.
                            if (isFirstValueDeclaration(decl)) {
                                emit('/** @const */\n');
                                writeVariableStatement(mangled, [], '{}');
                            }
                            // Declare the contents inside the "mangled$name".
                            if (decl.body)
                                visitor(decl.body, [mangled]);
                            break;
                        default:
                            errorUnimplementedKind(decl.name, 'externs generation of namespace');
                            break;
                    }
                    break;
                case ts.SyntaxKind.ModuleBlock:
                    const block = node;
                    for (const stmt of block.statements) {
                        visitor(stmt, namespace);
                    }
                    break;
                case ts.SyntaxKind.ImportEqualsDeclaration:
                    const importEquals = node;
                    const localName = transformer_util_1.getIdentifierText(importEquals.name);
                    if (importEquals.moduleReference.kind === ts.SyntaxKind.ExternalModuleReference) {
                        addImportAliases(importEquals);
                        break;
                    }
                    const qn = qualifiedNameToMangledIdentifier(importEquals.moduleReference);
                    // @const so that Closure Compiler understands this is an alias.
                    emit('/** @const */\n');
                    writeVariableStatement(localName, namespace, qn);
                    break;
                case ts.SyntaxKind.ClassDeclaration:
                case ts.SyntaxKind.InterfaceDeclaration:
                    writeType(node, namespace);
                    break;
                case ts.SyntaxKind.FunctionDeclaration:
                    const fnDecl = node;
                    const name = fnDecl.name;
                    if (!name) {
                        transformer_util_1.reportDiagnostic(diagnostics, fnDecl, 'anonymous function in externs');
                        break;
                    }
                    // Gather up all overloads of this function.
                    const sym = typeChecker.getSymbolAtLocation(name);
                    const decls = sym.declarations.filter(ts.isFunctionDeclaration);
                    // Only emit the first declaration of each overloaded function.
                    if (fnDecl !== decls[0])
                        break;
                    const params = emitFunctionType(decls);
                    writeFunction(name, params, namespace);
                    break;
                case ts.SyntaxKind.VariableStatement:
                    for (const decl of node.declarationList.declarations) {
                        writeVariableDeclaration(decl, namespace);
                    }
                    break;
                case ts.SyntaxKind.EnumDeclaration:
                    writeEnum(node, namespace);
                    break;
                case ts.SyntaxKind.TypeAliasDeclaration:
                    writeTypeAlias(node, namespace);
                    break;
                case ts.SyntaxKind.ImportDeclaration:
                    addImportAliases(node);
                    break;
                case ts.SyntaxKind.NamespaceExportDeclaration:
                case ts.SyntaxKind.ExportAssignment:
                    // Handled on the file level.
                    break;
                case ts.SyntaxKind.ExportDeclaration:
                    const exportDeclaration = node;
                    writeExportDeclaration(exportDeclaration, namespace);
                    break;
                default:
                    emit(`\n// TODO(tsickle): ${ts.SyntaxKind[node.kind]} in ${debugLocationStr(node, namespace)}\n`);
                    break;
            }
        }
    }
    exports.generateExterns = generateExterns;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXh0ZXJucy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9leHRlcm5zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRzs7Ozs7Ozs7Ozs7O0lBRUg7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXlERztJQUVILGlDQUFpQztJQUVqQywrREFBdUU7SUFDdkUsbUVBQStDO0lBQy9DLHVEQUEyRTtJQUMzRSwyQ0FBaUM7SUFDakMscUVBQXNHO0lBQ3RHLCtFQUE4RDtJQUM5RCx5Q0FBK0I7SUFDL0IsbUVBQXFJO0lBQ3JJLGlFQUE2RDtJQUU3RDs7O09BR0c7SUFDSCxNQUFNLHlCQUF5QixHQUEwQjtRQUN2RCxTQUFTO1FBQ1QsUUFBUTtRQUNSLFFBQVE7UUFDUixnRUFBZ0U7UUFDaEUsdUVBQXVFO1FBQ3ZFLGtFQUFrRTtRQUNsRSxxRUFBcUU7UUFDckUsbUVBQW1FO1FBQ25FLHdFQUF3RTtRQUN4RSxnQ0FBZ0M7UUFDaEMsa0JBQWtCO1FBQ2xCLFFBQVE7UUFDUixtQkFBbUI7S0FDcEIsQ0FBQztJQUdGOzs7Ozs7Ozs7O09BVUc7SUFDSCxNQUFNLGNBQWMsR0FBRztNQUNqQixFQUFFOzs7O0NBSVAsQ0FBQztJQUVGOzs7Ozs7T0FNRztJQUNILFNBQWdCLG1CQUFtQixDQUFDLE9BQXFDLEVBQUUsT0FBTyxHQUFHLEVBQUU7UUFDckYsSUFBSSxVQUFVLEdBQUcsY0FBYyxDQUFDO1FBQ2hDLEtBQUssTUFBTSxRQUFRLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUMzQyxVQUFVLElBQUksbUJBQW1CLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLFFBQVEsQ0FBQyxLQUFLLENBQUM7WUFDdkUsVUFBVSxJQUFJLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUNqQztRQUNELE9BQU8sVUFBVSxDQUFDO0lB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aEQsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDM0MsTUFBTTthQUNUO1FBQ0gsQ0FBQztJQUNILENBQUM7SUF6b0JELDBDQXlvQkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBFeHRlcm5zIGNyZWF0ZXMgQ2xvc3VyZSBDb21waWxlciAjZXh0ZXJucyBkZWZpbml0aW9ucyBmcm9tIHRoZVxuICogYW1iaWVudCBkZWNsYXJhdGlvbnMgaW4gYSBUeXBlU2NyaXB0IGZpbGUuXG4gKlxuICogKE5vdGUgdGhhdCB3ZSBjYW5ub3Qgd3JpdGUgdGhlIFwiQFwiIGZvcm0gb2YgdGhlIGV4dGVybnMgdGFnLCBldmVuIGluIGNvbW1lbnRzLFxuICogYmVjYXVzZSB0aGUgY29tcGlsZXIgZ3JlcHMgZm9yIGl0IGluIHNvdXJjZSBmaWxlcyghKS4gIFNvIHdlIHdyaXRlICNleHRlcm5zXG4gKiBpbnN0ZWFkLilcbiAqXG4gKiBGb3IgZXhhbXBsZSwgYVxuICogICBkZWNsYXJlIGludGVyZmFjZSBGb28geyBiYXI6IHN0cmluZzsgfVxuICpcbiAqIFdvdWxkIGdlbmVyYXRlIGFcbiAqICAgLy4uICNleHRlcm5zIC4vXG4gKiAgIC8uLiBAcmVjb3JkIC4vXG4gKiAgIHZhciBGb28gPSBmdW5jdGlvbigpIHt9O1xuICogICAvLi4gQHR5cGUge3N0cmluZ30gLi9cbiAqICAgRm9vLnByb3RvdHlwZS5iYXI7XG4gKlxuICogVGhlIGdlbmVyYXRlZCBleHRlcm5zIGluZGljYXRlIHRvIENsb3N1cmUgQ29tcGlsZXIgdGhhdCBzeW1ib2xzIGFyZSBleHRlcm5hbFxuICogdG8gdGhlIG9wdGltaXphdGlvbiBwcm9jZXNzLCBpLmUuIHRoZXkgYXJlIHByb3ZpZGVkIGJ5IG91dHNpZGUgY29kZS4gVGhhdFxuICogbW9zdCBpbXBvcnRhbnRseSBtZWFucyB0aGV5IG11c3Qgbm90IGJlIHJlbmFtZWQgb3IgcmVtb3ZlZC5cbiAqXG4gKiBBIG1ham9yIGRpZmZpY3VsdHkgaGVyZSBpcyB0aGF0IFR5cGVTY3JpcHQgc3VwcG9ydHMgbW9kdWxlLXNjb3BlZCBleHRlcm5hbFxuICogc3ltYm9sczsgYC5kLnRzYCBmaWxlcyBjYW4gY29udGFpbiBgZXhwb3J0YHMgYW5kIGBpbXBvcnRgIG90aGVyIGZpbGVzLlxuICogQ2xvc3VyZSBDb21waWxlciBkb2VzIG5vdCBoYXZlIHN1Y2ggYSBjb25jZXB0LCBzbyB0c2lja2xlIG11c3QgZW11bGF0ZSB0aGVcbiAqIGJlaGF2aW91ci4gSXQgZG9lcyBzbyBieSBmb2xsb3dpbmcgdGhpcyBzY2hlbWU6XG4gKlxuICogMS4gbm9uLW1vZHVsZSAuZC50cyBwcm9kdWNlcyBnbG9iYWwgc3ltYm9sc1xuICogMi4gbW9kdWxlIC5kLnRzIHByb2R1Y2Ugc3ltYm9scyBuYW1lc3BhY2VkIHRvIHRoZSBtb2R1bGUsIGJ5IGNyZWF0aW5nIGFcbiAqICAgIG1hbmdsZWQgbmFtZSBtYXRjaGluZyB0aGUgY3VycmVudCBmaWxlJ3MgcGF0aC4gdHNpY2tsZSBleHBlY3RzIG91dHNpZGVcbiAqICAgIGNvZGUgKGUuZy4gYnVpbGQgc3lzdGVtIGludGVncmF0aW9uIG9yIG1hbnVhbGx5IHdyaXR0ZW4gY29kZSkgdG8gY29udGFpbiBhXG4gKiAgICBnb29nLm1vZHVsZS9wcm92aWRlIHRoYXQgcmVmZXJlbmNlcyB0aGUgbWFuZ2xlZCBwYXRoLlxuICogMy4gZGVjbGFyYXRpb25zIGluIGAudHNgIGZpbGVzIHByb2R1Y2UgdHlwZXMgdGhhdCBjYW4gYmUgc2VwYXJhdGVseSBlbWl0dGVkXG4gKiAgICBpbiBlLmcuIGFuIGBleHRlcm5zLmpzYCwgdXNpbmcgYGdldEdlbmVyYXRlZEV4dGVybnNgIGJlbG93LlxuICogICAgMS4gbm9uLWV4cG9ydGVkIHN5bWJvbHMgcHJvZHVjZSBnbG9iYWwgdHlwZXMsIGJlY2F1c2UgdGhhdCdzIHdoYXQgdXNlcnNcbiAqICAgICAgIGV4cGVjdCBhbmQgaXQgbWF0Y2hlcyBUeXBlU2NyaXB0cyBlbWl0LCB3aGljaCBqdXN0IHJlZmVyZW5jZXMgYEZvb2AgZm9yXG4gKiAgICAgICBhIGxvY2FsbHkgZGVjbGFyZWQgc3ltYm9sIGBGb29gIGluIGEgbW9kdWxlLiBBcmd1YWJseSB0aGVzZSBzaG91bGQgYmVcbiAqICAgICAgIHdyYXBwZWQgaW4gYGRlY2xhcmUgZ2xvYmFsIHsgLi4uIH1gLlxuICogICAgMi4gZXhwb3J0ZWQgc3ltYm9scyBhcmUgc2NvcGVkIHRvIHRoZSBgLnRzYCBmaWxlIGJ5IHByZWZpeGluZyB0aGVtIHdpdGggYVxuICogICAgICAgbWFuZ2xlZCBuYW1lLiBFeHBvcnRlZCB0eXBlcyBhcmUgcmUtZXhwb3J0ZWQgZnJvbSB0aGUgSmF2YVNjcmlwdFxuICogICAgICAgYGdvb2cubW9kdWxlYCwgYWxsb3dpbmcgZG93bnN0cmVhbSBjb2RlIHRvIHJlZmVyZW5jZSB0aGVtLiBUaGlzIGhhcyB0aGVcbiAqICAgICAgIHNhbWUgcHJvYmxlbSByZWdhcmRpbmcgYW1iaWVudCB2YWx1ZXMgYXMgYWJvdmUsIGl0IGlzIHVuY2xlYXIgd2hlcmUgdGhlXG4gKiAgICAgICB2YWx1ZSBzeW1ib2wgd291bGQgYmUgZGVmaW5lZCwgc28gZm9yIHRoZSB0aW1lIGJlaW5nIHRoaXMgaXNcbiAqICAgICAgIHVuc3VwcG9ydGVkLlxuICpcbiAqIFRoZSBlZmZlY3Qgb2YgdGhpcyBpcyB0aGF0OlxuICogLSBzeW1ib2xzIGluIGEgbW9kdWxlIChpLmUuIG5vdCBnbG9iYWxzKSBhcmUgZ2VuZXJhbGx5IHNjb3BlZCB0byB0aGUgbG9jYWxcbiAqICAgbW9kdWxlIHVzaW5nIGEgbWFuZ2xlZCBuYW1lLCBwcmV2ZW50aW5nIHN5bWJvbCBjb2xsaXNpb25zIG9uIHRoZSBDbG9zdXJlXG4gKiAgIHNpZGUuXG4gKiAtIGltcG9ydGluZyBjb2RlIGNhbiB1bmNvbmRpdGlvbmFsbHkgcmVmZXIgdG8gYW5kIGltcG9ydCBhbnkgc3ltYm9sIGRlZmluZWRcbiAqICAgaW4gYSBtb2R1bGUgYFhgIGFzIGBwYXRoLnRvLm1vZHVsZS5YYCwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSBkZWZpbmluZ1xuICogICBsb2NhdGlvbiBpcyBhIGAuZC50c2AgZmlsZSBvciBhIGAudHNgIGZpbGUsIGFuZCByZWdhcmRsZXNzIHdoZXRoZXIgdGhlXG4gKiAgIHN5bWJvbCBpcyBhbWJpZW50IChhc3N1bWluZyB0aGVyZSdzIGFuIGFwcHJvcHJpYXRlIHNoaW0pLlxuICogLSBpZiB0aGVyZSBpcyBhIHNoaW0gcHJlc2VudCwgdHNpY2tsZSBhdm9pZHMgZW1pdHRpbmcgdGhlIENsb3N1cmUgbmFtZXNwYWNlXG4gKiAgIGl0c2VsZiwgZXhwZWN0aW5nIHRoZSBzaGltIHRvIHByb3ZpZGUgdGhlIG5hbWVzcGFjZSBhbmQgaW5pdGlhbGl6ZSBpdCB0byBhXG4gKiAgIHN5bWJvbCB0aGF0IHByb3ZpZGVzIHRoZSByaWdodCB2YWx1ZSBhdCBydW50aW1lIChpLmUuIHRoZSBpbXBsZW1lbnRhdGlvbiBvZlxuICogICB3aGF0ZXZlciB0aGlyZCBwYXJ0eSBsaWJyYXJ5IHRoZSAuZC50cyBkZXNjcmliZXMpLlxuICovXG5cbmltcG9ydCAqIGFzIHRzIGZyb20gJ3R5cGVzY3JpcHQnO1xuXG5pbXBvcnQge0Fubm90YXRvckhvc3QsIG1vZHVsZU5hbWVBc0lkZW50aWZpZXJ9IGZyb20gJy4vYW5ub3RhdG9yX2hvc3QnO1xuaW1wb3J0IHtnZXRFbnVtVHlwZX0gZnJvbSAnLi9lbnVtX3RyYW5zZm9ybWVyJztcbmltcG9ydCB7ZXh0cmFjdEdvb2dOYW1lc3BhY2VJbXBvcnQsIHJlc29sdmVNb2R1bGVOYW1lfSBmcm9tICcuL2dvb2dtb2R1bGUnO1xuaW1wb3J0ICogYXMganNkb2MgZnJvbSAnLi9qc2RvYyc7XG5pbXBvcnQge2VzY2FwZUZvckNvbW1lbnQsIG1heWJlQWRkSGVyaXRhZ2VDbGF1c2VzLCBtYXliZUFkZFRlbXBsYXRlQ2xhdXNlfSBmcm9tICcuL2pzZG9jX3RyYW5zZm9ybWVyJztcbmltcG9ydCB7TW9kdWxlVHlwZVRyYW5zbGF0b3J9IGZyb20gJy4vbW9kdWxlX3R5cGVfdHJhbnNsYXRvcic7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJy4vcGF0aCc7XG5pbXBvcnQge2dldEVudGl0eU5hbWVUZXh0LCBnZXRJZGVudGlmaWVyVGV4dCwgaGFzTW9kaWZpZXJGbGFnLCBpc0FtYmllbnQsIGlzRHRzRmlsZU5hbWUsIHJlcG9ydERpYWdub3N0aWN9IGZyb20gJy4vdHJhbnNmb3JtZXJfdXRpbCc7XG5pbXBvcnQge2lzVmFsaWRDbG9zdXJlUHJvcGVydHlOYW1lfSBmcm9tICcuL3R5cGVfdHJhbnNsYXRvcic7XG5cbi8qKlxuICogU3ltYm9scyB0aGF0IGFyZSBhbHJlYWR5IGRlY2xhcmVkIGFzIGV4dGVybnMgaW4gQ2xvc3VyZSwgdGhhdCBzaG91bGRcbiAqIGJlIGF2b2lkZWQgYnkgdHNpY2tsZSdzIFwiZGVjbGFyZSAuLi5cIiA9PiBleHRlcm5zLmpzIGNvbnZlcnNpb24uXG4gKi9cbmNvbnN0IENMT1NVUkVfRVhURVJOU19CTEFDS0xJU1Q6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPiA9IFtcbiAgJ2V4cG9ydHMnLFxuICAnZ2xvYmFsJyxcbiAgJ21vZHVsZScsXG4gIC8vIEVycm9yQ29uc3RydWN0b3IgaXMgdGhlIGludGVyZmFjZSBvZiB0aGUgRXJyb3Igb2JqZWN0IGl0c2VsZi5cbiAgLy8gdHNpY2tsZSBkZXRlY3RzIHRoYXQgdGhpcyBpcyBwYXJ0IG9mIHRoZSBUeXBlU2NyaXB0IHN0YW5kYXJkIGxpYnJhcnlcbiAgLy8gYW5kIGFzc3VtZXMgaXQncyBwYXJ0IG9mIHRoZSBDbG9zdXJlIHN0YW5kYXJkIGxpYnJhcnksIGJ1dCB0aGlzXG4gIC8vIGFzc3VtcHRpb24gaXMgd3JvbmcgZm9yIEVycm9yQ29uc3RydWN0b3IuICBUbyBwcm9wZXJseSBoYW5kbGUgdGhpc1xuICAvLyB3ZSdkIHNvbWVob3cgbmVlZCB0byBtYXAgbWV0aG9kcyBkZWZpbmVkIG9uIHRoZSBFcnJvckNvbnN0cnVjdG9yXG4gIC8vIGludGVyZmFjZSBpbnRvIHByb3BlcnRpZXMgb24gQ2xvc3VyZSdzIEVycm9yIG9iamVjdCwgYnV0IGZvciBub3cgaXQnc1xuICAvLyBzaW1wbGVyIHRvIGp1c3QgYmxhY2tsaXN0IGl0LlxuICAnRXJyb3JDb25zdHJ1Y3RvcicsXG4gICdTeW1ib2wnLFxuICAnV29ya2VyR2xvYmFsU2NvcGUnLFxuXTtcblxuXG4vKipcbiAqIFRoZSBoZWFkZXIgdG8gYmUgdXNlZCBpbiBnZW5lcmF0ZWQgZXh0ZXJucy4gIFRoaXMgaXMgbm90IGluY2x1ZGVkIGluIHRoZSBvdXRwdXQgb2ZcbiAqIGdlbmVyYXRlRXh0ZXJucygpIGJlY2F1c2UgZ2VuZXJhdGVFeHRlcm5zKCkgd29ya3Mgb25lIGZpbGUgYXQgYSB0aW1lLCBhbmQgdHlwaWNhbGx5IHlvdSBjcmVhdGVcbiAqIG9uZSBleHRlcm5zIGZpbGUgZnJvbSB0aGUgZW50aXJlIGNvbXBpbGF0aW9uIHVuaXQuXG4gKlxuICogU3VwcHJlc3Npb25zOlxuICogLSBkdXBsaWNhdGU6IGJlY2F1c2UgZXh0ZXJucyBtaWdodCBkdXBsaWNhdGUgcmUtb3BlbmVkIGRlZmluaXRpb25zIGZyb20gb3RoZXIgSlMgZmlsZXMuXG4gKiAtIGNoZWNrVHlwZXM6IENsb3N1cmUncyB0eXBlIHN5c3RlbSBkb2VzIG5vdCBtYXRjaCBUUycuXG4gKiAtIHVuZGVmaW5lZE5hbWVzOiBjb2RlIGJlbG93IHRyaWVzIHRvIGJlIGNhcmVmdWwgbm90IHRvIG92ZXJ3cml0ZSBwcmV2aW91c2x5IGVtaXR0ZWQgZGVmaW5pdGlvbnMsXG4gKiAgIGJ1dCBvbiB0aGUgZmxpcCBzaWRlIG1pZ2h0IGFjY2lkZW50YWxseSBtaXNzIGRlZmluaXRpb25zLlxuICovXG5jb25zdCBFWFRFUk5TX0hFQURFUiA9IGAvKipcbiAqIEAkeycnfWV4dGVybnNcbiAqIEBzdXBwcmVzcyB7ZHVwbGljYXRlLGNoZWNrVHlwZXN9XG4gKi9cbi8vIE5PVEU6IGdlbmVyYXRlZCBieSB0c2lja2xlLCBkbyBub3QgZWRpdC5cbmA7XG5cbi8qKlxuICogQ29uY2F0ZW5hdGUgYWxsIGdlbmVyYXRlZCBleHRlcm5zIGRlZmluaXRpb25zIHRvZ2V0aGVyIGludG8gYSBzdHJpbmcsIGluY2x1ZGluZyBhIGZpbGUgY29tbWVudFxuICogaGVhZGVyLlxuICpcbiAqIEBwYXJhbSByb290RGlyIFByb2plY3Qgcm9vdC4gIEVtaXR0ZWQgY29tbWVudHMgd2lsbCByZWZlcmVuY2UgcGF0aHMgcmVsYXRpdmUgdG8gdGhpcyByb290LlxuICogICAgVGhpcyBwYXJhbSBpcyBlZmZlY3RpdmVseSByZXF1aXJlZCwgYnV0IG1hZGUgb3B0aW9uYWwgaGVyZSB1bnRpbCBBbmd1bGFyIGlzIGZpeGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2VuZXJhdGVkRXh0ZXJucyhleHRlcm5zOiB7W2ZpbGVOYW1lOiBzdHJpbmddOiBzdHJpbmd9LCByb290RGlyID0gJycpOiBzdHJpbmcge1xuICBsZXQgYWxsRXh0ZXJucyA9IEVYVEVSTlNfSEVBREVSO1xuICBmb3IgKGNvbnN0IGZpbGVOYW1lIG9mIE9iamVjdC5rZXlzKGV4dGVybnMpKSB7XG4gICAgYWxsRXh0ZXJucyArPSBgLy8gZXh0ZXJucyBmcm9tICR7cGF0aC5yZWxhdGl2ZShyb290RGlyLCBmaWxlTmFtZSl9OlxcbmA7XG4gICAgYWxsRXh0ZXJucyArPSBleHRlcm5zW2ZpbGVOYW1lXTtcbiAgfVxuICByZXR1cm4gYWxsRXh0ZXJucztcbn1cblxuLyoqXG4gKiBpc0luR2xvYmFsQXVnbWVudGF0aW9uIHJldHVybnMgdHJ1ZSBpZiBkZWNsYXJhdGlvbiBpcyB0aGUgaW1tZWRpYXRlIGNoaWxkIG9mIGEgJ2RlY2xhcmUgZ2xvYmFsJ1xuICogYmxvY2suXG4gKi9cbmZ1bmN0aW9uIGlzSW5HbG9iYWxBdWdtZW50YXRpb24oZGVjbGFyYXRpb246IHRzLkRlY2xhcmF0aW9uKTogYm9vbGVhbiB7XG4gIC8vIGRlY2xhcmUgZ2xvYmFsIHsgLi4uIH0gY3JlYXRlcyBhIE1vZHVsZURlY2xhcmF0aW9uIGNvbnRhaW5pbmcgYSBNb2R1bGVCbG9jayBjb250YWluaW5nIHRoZVxuICAvLyBkZWNsYXJhdGlvbiwgd2l0aCB0aGUgTW9kdWxlRGVjbGFyYXRpb24gaGF2aW5nIHRoZSBHbG9iYWxBdWdtZW50YXRpb24gZmxhZyBzZXQuXG4gIGlmICghZGVjbGFyYXRpb24ucGFyZW50IHx8ICFkZWNsYXJhdGlvbi5wYXJlbnQucGFyZW50KSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAoZGVjbGFyYXRpb24ucGFyZW50LnBhcmVudC5mbGFncyAmIHRzLk5vZGVGbGFncy5HbG9iYWxBdWdtZW50YXRpb24pICE9PSAwO1xufVxuXG4vKipcbiAqIGdlbmVyYXRlRXh0ZXJucyBnZW5lcmF0ZXMgZXh0ZXJuIGRlZmluaXRpb25zIGZvciBhbGwgYW1iaWVudCBkZWNsYXJhdGlvbnMgaW4gdGhlIGdpdmVuIHNvdXJjZVxuICogZmlsZS4gSXQgcmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQ2xvc3VyZSBKYXZhU2NyaXB0LCBub3QgaW5jbHVkaW5nIHRoZSBpbml0aWFsXG4gKiBjb21tZW50IHdpdGggXFxAZmlsZW92ZXJ2aWV3IGFuZCAjZXh0ZXJucyAoc2VlIGFib3ZlIGZvciB0aGF0KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlRXh0ZXJucyhcbiAgICB0eXBlQ2hlY2tlcjogdHMuVHlwZUNoZWNrZXIsIHNvdXJjZUZpbGU6IHRzLlNvdXJjZUZpbGUsIGhvc3Q6IEFubm90YXRvckhvc3QsXG4gICAgbW9kdWxlUmVzb2x1dGlvbkhvc3Q6IHRzLk1vZHVsZVJlc29sdXRpb25Ib3N0LFxuICAgIG9wdGlvbnM6IHRzLkNvbXBpbGVyT3B0aW9ucyk6IHtvdXRwdXQ6IHN0cmluZywgZGlhZ25vc3RpY3M6IHRzLkRpYWdub3N0aWNbXX0ge1xuICBsZXQgb3V0cHV0ID0gJyc7XG4gIGNvbnN0IGRpYWdub3N0aWNzOiB0cy5EaWFnbm9zdGljW10gPSBbXTtcbiAgY29uc3QgaXNEdHMgPSBpc0R0c0ZpbGVOYW1lKHNvdXJjZUZpbGUuZmlsZU5hbWUpO1xuICBjb25zdCBpc0V4dGVybmFsTW9kdWxlID0gdHMuaXNFeHRlcm5hbE1vZHVsZShzb3VyY2VGaWxlKTtcblxuICBjb25zdCBtdHQgPVxuICAgICAgbmV3IE1vZHVsZVR5cGVUcmFuc2xhdG9yKHNvdXJjZUZpbGUsIHR5cGVDaGVja2VyLCBob3N0LCBkaWFnbm9zdGljcywgLyppc0ZvckV4dGVybnMqLyB0cnVlKTtcblxuICAvLyAuZC50cyBmaWxlcyBkZWNsYXJlIHN5bWJvbHMuIFRoZSBjb2RlIGJlbG93IHRyYW5zbGF0ZXMgdGhlc2UgaW50byBhIGZvcm0gdW5kZXJzdG9vZCBieSBDbG9zdXJlXG4gIC8vIENvbXBpbGVyLCBjb252ZXJ0aW5nIHRoZSB0eXBlIHN5bnRheCwgYnV0IGFsc28gY29udmVydGluZyBzeW1ib2wgbmFtZXMgaW50byBhIGZvcm0gYWNjZXNzaWJsZVxuICAvLyB0byBDbG9zdXJlIENvbXBpbGVyLlxuXG4gIC8vIExpa2UgcmVndWxhciAudHMgZmlsZXMsIC5kLnRzIGNhbiBiZSBlaXRoZXIgc2NyaXB0cyBvciBtb2R1bGVzLiBTY3JpcHRzIGRlY2xhcmUgc3ltYm9scyBpbiB0aGVcbiAgLy8gZ2xvYmFsIG5hbWVzcGFjZSwgd2hpY2ggaGFzIHRoZSBzYW1lIHNlbWFudGljcyBpbiBDbG9zdXJlIGFuZCBUeXBlU2NyaXB0LCBzbyB0aGUgY29kZSBiZWxvd1xuICAvLyBlbWl0cyB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUuXG5cbiAgLy8gTW9kdWxlcyBob3dldmVyIGRlY2xhcmUgc3ltYm9scyBzY29wZWQgdG8gdGhlIG1vZHVsZSB0aGF0IGNhbiBiZSBleHBvcnRlZC4gQ2xvc3VyZSBoYXMgbm9cbiAgLy8gY29uY2VwdCBvZiBleHRlcm5zIHRoYXQgYXJlIG5vbi1nbG9iYWwsIHNvIHRzaWNrbGUgbmVlZHMgdG8gbWFuZ2xlIHRoZSBzeW1ib2wgbmFtZXMsIGJvdGggYXRcbiAgLy8gdGhlaXIgZGVjbGFyYXRpb24gYW5kIGF0IHRoZWlyIHVzZSBzaXRlLlxuXG4gIC8vIFRoaXMgbWFuZ2xpbmcgaGFwcGVucyBieSB3cmFwcGluZyBhbGwgZGVjbGFyZWQgc3ltYm9scyBpbiBhIG5hbWVzcGFjZSBiYXNlZCBvbiB0aGUgZmlsZSBuYW1lLlxuICAvLyBUaGlzIG5hbWVzcGFjZSBpcyB0aGVuIGVzc2VudGlhbGx5IHRoZSBleHBvcnRzIG9iamVjdCBmb3IgdGhlIGFtYmllbnQgbW9kdWxlIChleHRlcm5zIGluXG4gIC8vIENsb3N1cmUgdGVybXMpLiBUaGlzIG5hbWVzcGFjZSBpcyBjYWxsZWQgYG1vZHVsZU5hbWVzcGFjZWAgYmVsb3c6XG4gIGxldCBtb2R1bGVOYW1lc3BhY2UgPSAnJztcbiAgaWYgKGlzRXh0ZXJuYWxNb2R1bGUpIHtcbiAgICBtb2R1bGVOYW1lc3BhY2UgPSBtb2R1bGVOYW1lQXNJZGVudGlmaWVyKGhvc3QsIHNvdXJjZUZpbGUuZmlsZU5hbWUpO1xuICB9XG5cbiAgLy8gU3ltYm9scyBhcmUgZ2VuZXJhdGVkIHN0YXJ0aW5nIGluIHJvb3ROYW1lc3BhY2UuIEZvciBzY3JpcHQgLmQudHMgd2l0aCBnbG9iYWwgc3ltYm9scywgdGhpcyBpc1xuICAvLyB0aGUgZW1wdHkgc3RyaW5nLiBGb3IgbW9zdCBtb2R1bGUgYC5kLnRzYCBmaWxlcywgdGhpcyBpcyB0aGUgbWFuZ2xlZCBuYW1lc3BhY2Ugb2JqZWN0LiBUaGVcbiAgLy8gcmVtYWluaW5nIHNwZWNpYWwgY2FzZSBhcmUgYC5kLnRzYCBmaWxlcyBjb250YWluaW5nIGFuIGBleHBvcnQgPSBzb21ldGhpbmc7YCBzdGF0ZW1lbnQuIEluXG4gIC8vIHRoZXNlLCB0aGUgZWZmZWN0aXZlIGV4cG9ydHMgb2JqZWN0LCBpLmUuIHRoZSBvYmplY3QgY29udGFpbmluZyB0aGUgc3ltYm9scyB0aGF0IGltcG9ydGluZyBjb2RlXG4gIC8vIHJlY2VpdmVzLCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgbWFpbiBtb2R1bGUgc2NvcGUuXG4gIC8vIHRzaWNrbGUgaGFuZGxlcyB0aGUgYGV4cG9ydCA9YCBjYXNlIGJ5IGdlbmVyYXRpbmcgc3ltYm9scyBpbiBhIGRpZmZlcmVudCBuYW1lc3BhY2UgKGVzY2FwZWRcbiAgLy8gd2l0aCBhIGBfYCkgYmVsb3csIGFuZCB0aGVuIGFzc2lnbmluZyB3aGF0ZXZlciBpcyBhY3R1YWxseSBleHBvcnRlZCBpbnRvIHRoZSBgbW9kdWxlTmFtZXNwYWNlYFxuICAvLyBiZWxvdy5cbiAgbGV0IHJvb3ROYW1lc3BhY2UgPSBtb2R1bGVOYW1lc3BhY2U7XG4gIC8vIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBleHBvcnQgPSwgYW5kIGlmIHRoZXJlIGlzIG9uZSwgdGhlcmUgY2Fubm90IGJlIGFueSBvdGhlciBleHBvcnRzLlxuICBjb25zdCBleHBvcnRBc3NpZ25tZW50ID0gc291cmNlRmlsZS5zdGF0ZW1lbnRzLmZpbmQodHMuaXNFeHBvcnRBc3NpZ25tZW50KTtcbiAgY29uc3QgaGFzRXhwb3J0RXF1YWxzID0gZXhwb3J0QXNzaWdubWVudCAmJiBleHBvcnRBc3NpZ25tZW50LmlzRXhwb3J0RXF1YWxzO1xuICBpZiAoaGFzRXhwb3J0RXF1YWxzKSB7XG4gICAgLy8gSWYgc28sIG1vdmUgYWxsIGdlbmVyYXRlZCBzeW1ib2xzIGludG8gYSBkaWZmZXJlbnQgc3ViLW5hbWVzcGFjZSwgc28gdGhhdCBsYXRlciBvbiB3ZSBjYW5cbiAgICAvLyBjb250cm9sIHdoYXQgZXhhY3RseSBnb2VzIG9uIHRoZSBhY3R1YWwgZXhwb3J0ZWQgbmFtZXNwYWNlLlxuICAgIHJvb3ROYW1lc3BhY2UgPSByb290TmFtZXNwYWNlICsgJ18nO1xuICB9XG5cbiAgZm9yIChjb25zdCBzdG10IG9mIHNvdXJjZUZpbGUuc3RhdGVtZW50cykge1xuICAgIGlmICghaXNEdHMgJiYgIWhhc01vZGlmaWVyRmxhZyhzdG10IGFzIHRzLkRlY2xhcmF0aW9uU3RhdGVtZW50LCB0cy5Nb2RpZmllckZsYWdzLkFtYmllbnQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmlzaXRvcihzdG10LCBbXSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhIHF1YWxpZmllZCBuYW1lIGZyb20gYSAuZC50cyBmaWxlIG9yIGRlY2xhcmF0aW9uIGNvbnRleHQgaW50byBhIG1hbmdsZWQgaWRlbnRpZmllci5cbiAgICogRS5nLiBmb3IgYSBxdWFsaWZpZWQgbmFtZSBpbiBgZXhwb3J0ID0gc29tZU5hbWU7YCBvciBgaW1wb3J0ID0gc29tZU5hbWU7YC5cbiAgICogSWYgYHNvbWVOYW1lYCBpcyBgZGVjbGFyZSBnbG9iYWwgeyBuYW1lc3BhY2Ugc29tZU5hbWUgey4uLn0gfWAsIHRzaWNrbGUgbXVzdCBub3QgcXVhbGlmeSBhY2Nlc3NcbiAgICogdG8gaXQgd2l0aCB0aGUgbWFuZ2xlZCBtb2R1bGUgbmFtZXNwYWNlIGFzIGl0IGlzIGVtaXR0ZWQgaW4gdGhlIGdsb2JhbCBuYW1lc3BhY2UuIFNpbWlsYXJseSwgaWZcbiAgICogdGhlIHN5bWJvbCBpcyBkZWNsYXJlZCBpbiBhIG5vbi1tb2R1bGUgY29udGV4dCwgaXQgbXVzdCBub3QgYmUgbWFuZ2xlZC5cbiAgICovXG4gIGZ1bmN0aW9uIHF1YWxpZmllZE5hbWVUb01hbmdsZWRJZGVudGlmaWVyKG5hbWU6IHRzLklkZW50aWZpZXJ8dHMuUXVhbGlmaWVkTmFtZSkge1xuICAgIGNvbnN0IGVudGl0eU5hbWUgPSBnZXRFbnRpdHlOYW1lVGV4dChuYW1lKTtcbiAgICBsZXQgc3ltYm9sID0gdHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbihuYW1lKTtcbiAgICBpZiAoc3ltYm9sKSB7XG4gICAgICAvLyBJZiB0aGlzIGlzIGFuIGFsaWFzZWQgbmFtZSAoZS5nLiBmcm9tIGFuIGltcG9ydCksIHVzZSB0aGUgYWxpYXMgdG8gcmVmZXIgdG8gaXQuXG4gICAgICBpZiAoc3ltYm9sLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuQWxpYXMpIHtcbiAgICAgICAgc3ltYm9sID0gdHlwZUNoZWNrZXIuZ2V0QWxpYXNlZFN5bWJvbChzeW1ib2wpO1xuICAgICAgfVxuICAgICAgY29uc3QgYWxpYXMgPSBtdHQuc3ltYm9sc1RvQWxpYXNlZE5hbWVzLmdldChzeW1ib2wpO1xuICAgICAgaWYgKGFsaWFzKSByZXR1cm4gYWxpYXM7XG4gICAgICBjb25zdCBpc0dsb2JhbFN5bWJvbCA9IHN5bWJvbCAmJiBzeW1ib2wuZGVjbGFyYXRpb25zICYmIHN5bWJvbC5kZWNsYXJhdGlvbnMuc29tZShkID0+IHtcbiAgICAgICAgaWYgKGlzSW5HbG9iYWxBdWdtZW50YXRpb24oZCkpIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBJZiB0aGUgZGVjbGFyYXRpb24ncyBzb3VyY2UgZmlsZSBpcyBub3QgYSBtb2R1bGUsIGl0IG11c3QgYmUgZ2xvYmFsLlxuICAgICAgICAvLyBJZiBpdCBpcyBhIG1vZHVsZSwgdGhlIGlkZW50aWZpZXIgbXVzdCBiZSBsb2NhbCB0byB0aGlzIGZpbGUsIG9yIGhhbmRsZWQgYWJvdmUgdmlhIHRoZVxuICAgICAgICAvLyBhbGlhcy5cbiAgICAgICAgcmV0dXJuICF0cy5pc0V4dGVybmFsTW9kdWxlKGQuZ2V0U291cmNlRmlsZSgpKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGlzR2xvYmFsU3ltYm9sKSByZXR1cm4gZW50aXR5TmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIHJvb3ROYW1lc3BhY2UgKyAnLicgKyBlbnRpdHlOYW1lO1xuICB9XG5cbiAgaWYgKG91dHB1dCAmJiBpc0V4dGVybmFsTW9kdWxlKSB7XG4gICAgLy8gSWYgdHNpY2tsZSBnZW5lcmF0ZWQgYW55IGV4dGVybnMgYW5kIHRoaXMgaXMgYW4gZXh0ZXJuYWwgbW9kdWxlLCBwcmVwZW5kIHRoZSBuYW1lc3BhY2VcbiAgICAvLyBkZWNsYXJhdGlvbiBmb3IgaXQuXG4gICAgb3V0cHV0ID0gYC8qKiBAY29uc3QgKi9cXG52YXIgJHtyb290TmFtZXNwYWNlfSA9IHt9O1xcbmAgKyBvdXRwdXQ7XG5cbiAgICBsZXQgZXhwb3J0ZWROYW1lc3BhY2UgPSByb290TmFtZXNwYWNlO1xuICAgIGlmIChleHBvcnRBc3NpZ25tZW50ICYmIGhhc0V4cG9ydEVxdWFscykge1xuICAgICAgaWYgKHRzLmlzSWRlbnRpZmllcihleHBvcnRBc3NpZ25tZW50LmV4cHJlc3Npb24pIHx8XG4gICAgICAgICAgdHMuaXNRdWFsaWZpZWROYW1lKGV4cG9ydEFzc2lnbm1lbnQuZXhwcmVzc2lvbikpIHtcbiAgICAgICAgLy8gRS5nLiBleHBvcnQgPSBzb21lTmFtZTtcbiAgICAgICAgLy8gSWYgc29tZU5hbWUgaXMgXCJkZWNsYXJlIGdsb2JhbCB7IG5hbWVzcGFjZSBzb21lTmFtZSB7Li4ufSB9XCIsIHRzaWNrbGUgbXVzdCBub3QgcXVhbGlmeVxuICAgICAgICAvLyBhY2Nlc3MgdG8gaXQgd2l0aCBtb2R1bGUgbmFtZXNwYWNlIGFzIGl0IGlzIGVtaXR0ZWQgaW4gdGhlIGdsb2JhbCBuYW1lc3BhY2UuXG4gICAgICAgIGV4cG9ydGVkTmFtZXNwYWNlID0gcXVhbGlmaWVkTmFtZVRvTWFuZ2xlZElkZW50aWZpZXIoZXhwb3J0QXNzaWdubWVudC5leHByZXNzaW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcG9ydERpYWdub3N0aWMoXG4gICAgICAgICAgICBkaWFnbm9zdGljcywgZXhwb3J0QXNzaWdubWVudC5leHByZXNzaW9uLFxuICAgICAgICAgICAgYGV4cG9ydCA9IGV4cHJlc3Npb24gbXVzdCBiZSBhIHF1YWxpZmllZCBuYW1lLCBnb3QgJHtcbiAgICAgICAgICAgICAgICB0cy5TeW50YXhLaW5kW2V4cG9ydEFzc2lnbm1lbnQuZXhwcmVzc2lvbi5raW5kXX0uYCk7XG4gICAgICB9XG4gICAgICAvLyBBc3NpZ24gdGhlIGFjdHVhbGx5IGV4cG9ydGVkIG5hbWVzcGFjZSBvYmplY3QgKHdoaWNoIGxpdmVzIHNvbWV3aGVyZSB1bmRlciByb290TmFtZXNwYWNlKVxuICAgICAgLy8gaW50byB0aGUgbW9kdWxlJ3MgbmFtZXNwYWNlLlxuICAgICAgZW1pdChgLyoqXFxuICogZXhwb3J0ID0gJHtleHBvcnRBc3NpZ25tZW50LmV4cHJlc3Npb24uZ2V0VGV4dCgpfVxcbiAqIEBjb25zdFxcbiAqL1xcbmApO1xuICAgICAgZW1pdChgdmFyICR7bW9kdWxlTmFtZXNwYWNlfSA9ICR7ZXhwb3J0ZWROYW1lc3BhY2V9O1xcbmApO1xuICAgIH1cblxuICAgIGlmIChpc0R0cyAmJiBob3N0LnByb3ZpZGVFeHRlcm5hbE1vZHVsZUR0c05hbWVzcGFjZSkge1xuICAgICAgLy8gSW4gYSBub24tc2hpbW1lZCBtb2R1bGUsIGNyZWF0ZSBhIGdsb2JhbCBuYW1lc3BhY2UuIFRoaXMgZXhpc3RzIHB1cmVseSBmb3IgYmFja3dhcmRzXG4gICAgICAvLyBjb21wYXRpYmxpdHksIGluIHRoZSBtZWRpdW0gdGVybSBhbGwgY29kZSB1c2luZyB0c2lja2xlIHNob3VsZCBhbHdheXMgdXNlIGBnb29nLm1vZHVsZWBzLFxuICAgICAgLy8gc28gZ2xvYmFsIG5hbWVzIHNob3VsZCBub3QgYmUgbmVjY2Vzc2FyeS5cbiAgICAgIGZvciAoY29uc3QgbnNFeHBvcnQgb2Ygc291cmNlRmlsZS5zdGF0ZW1lbnRzLmZpbHRlcih0cy5pc05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uKSkge1xuICAgICAgICBjb25zdCBuYW1lc3BhY2VOYW1lID0gZ2V0SWRlbnRpZmllclRleHQobnNFeHBvcnQubmFtZSk7XG4gICAgICAgIGVtaXQoYC8vIGV4cG9ydCBhcyBuYW1lc3BhY2UgJHtuYW1lc3BhY2VOYW1lfVxcbmApO1xuICAgICAgICB3cml0ZVZhcmlhYmxlU3RhdGVtZW50KG5hbWVzcGFjZU5hbWUsIFtdLCBleHBvcnRlZE5hbWVzcGFjZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtvdXRwdXQsIGRpYWdub3N0aWNzfTtcblxuICBmdW5jdGlvbiBlbWl0KHN0cjogc3RyaW5nKSB7XG4gICAgb3V0cHV0ICs9IHN0cjtcbiAgfVxuXG4gIC8qKlxuICAgKiBpc0ZpcnN0RGVjbGFyYXRpb24gcmV0dXJucyB0cnVlIGlmIGRlY2wgaXMgdGhlIGZpcnN0IGRlY2xhcmF0aW9uXG4gICAqIG9mIGl0cyBzeW1ib2wuICBFLmcuIGltYWdpbmVcbiAgICogICBpbnRlcmZhY2UgRm9vIHsgeDogbnVtYmVyOyB9XG4gICAqICAgaW50ZXJmYWNlIEZvbyB7IHk6IG51bWJlcjsgfVxuICAgKiB3ZSBvbmx5IHdhbnQgdG8gZW1pdCB0aGUgXCJcXEByZWNvcmRcIiBmb3IgRm9vIG9uIHRoZSBmaXJzdCBvbmUuXG4gICAqXG4gICAqIFRoZSBleGNlcHRpb24gYXJlIHZhcmlhYmxlIGRlY2xhcmF0aW9ucywgd2hpY2ggLSBpbiBleHRlcm5zIC0gZG8gbm90IGFzc2lnbiBhIHZhbHVlOlxuICAgKiAgIC8uLiBcXEB0eXBlIHsuLi59IC4vXG4gICAqICAgdmFyIHNvbWVWYXJpYWJsZTtcbiAgICogICAvLi4gXFxAdHlwZSB7Li4ufSAuL1xuICAgKiAgIHNvbWVOYW1lc3BhY2Uuc29tZVZhcmlhYmxlO1xuICAgKiBJZiBhIGxhdGVyIGRlY2xhcmF0aW9uIHdhbnRzIHRvIGFkZCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgb24gc29tZVZhcmlhYmxlLCB0c2lja2xlIG11c3Qgc3RpbGxcbiAgICogZW1pdCBhbiBhc3NpZ25tZW50IGludG8gdGhlIG9iamVjdCwgYXMgaXQncyBvdGhlcndpc2UgYWJzZW50LlxuICAgKi9cbiAgZnVuY3Rpb24gaXNGaXJzdFZhbHVlRGVjbGFyYXRpb24oZGVjbDogdHMuRGVjbGFyYXRpb25TdGF0ZW1lbnQpOiBib29sZWFuIHtcbiAgICBpZiAoIWRlY2wubmFtZSkgcmV0dXJuIHRydWU7XG4gICAgY29uc3Qgc3ltID0gdHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbihkZWNsLm5hbWUpITtcbiAgICBpZiAoIXN5bS5kZWNsYXJhdGlvbnMgfHwgc3ltLmRlY2xhcmF0aW9ucy5sZW5ndGggPCAyKSByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBlYXJsaWVyRGVjbHMgPSBzeW0uZGVjbGFyYXRpb25zLnNsaWNlKDAsIHN5bS5kZWNsYXJhdGlvbnMuaW5kZXhPZihkZWNsKSk7XG4gICAgLy8gRWl0aGVyIHRoZXJlIGFyZSBubyBlYXJsaWVyIGRlY2xhcmF0aW9ucywgb3IgYWxsIG9mIHRoZW0gYXJlIHZhcmlhYmxlcyAoc2VlIGFib3ZlKS4gdHNpY2tsZVxuICAgIC8vIGVtaXRzIGEgdmFsdWUgZm9yIGFsbCBvdGhlciBkZWNsYXJhdGlvbiBraW5kcyAoZnVuY3Rpb24gZm9yIGZ1bmN0aW9ucywgY2xhc3NlcywgaW50ZXJmYWNlcyxcbiAgICAvLyB7fSBvYmplY3QgZm9yIG5hbWVzcGFjZXMpLlxuICAgIHJldHVybiBlYXJsaWVyRGVjbHMubGVuZ3RoID09PSAwIHx8IGVhcmxpZXJEZWNscy5ldmVyeSh0cy5pc1ZhcmlhYmxlRGVjbGFyYXRpb24pO1xuICB9XG5cbiAgLyoqIFdyaXRlcyB0aGUgYWN0dWFsIHZhcmlhYmxlIHN0YXRlbWVudCBvZiBhIENsb3N1cmUgdmFyaWFibGUgZGVjbGFyYXRpb24uICovXG4gIGZ1bmN0aW9uIHdyaXRlVmFyaWFibGVTdGF0ZW1lbnQobmFtZTogc3RyaW5nLCBuYW1lc3BhY2U6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPiwgdmFsdWU/OiBzdHJpbmcpIHtcbiAgICBjb25zdCBxdWFsaWZpZWROYW1lID0gbmFtZXNwYWNlLmNvbmNhdChbbmFtZV0pLmpvaW4oJy4nKTtcbiAgICBpZiAobmFtZXNwYWNlLmxlbmd0aCA9PT0gMCkgZW1pdChgdmFyIGApO1xuICAgIGVtaXQocXVhbGlmaWVkTmFtZSk7XG4gICAgaWYgKHZhbHVlKSBlbWl0KGAgPSAke3ZhbHVlfWApO1xuICAgIGVtaXQoJztcXG4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZXMgYSBDbG9zdXJlIHZhcmlhYmxlIGRlY2xhcmF0aW9uLCBpLmUuIHRoZSB2YXJpYWJsZSBzdGF0ZW1lbnQgd2l0aCBhIGxlYWRpbmcgSlNEb2NcbiAgICogY29tbWVudCBtYWtpbmcgaXQgYSBkZWNsYXJhdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIHdyaXRlVmFyaWFibGVEZWNsYXJhdGlvbihcbiAgICAgIGRlY2w6IHRzLlZhcmlhYmxlRGVjbGFyYXRpb24sIG5hbWVzcGFjZTogUmVhZG9ubHlBcnJheTxzdHJpbmc+KSB7XG4gICAgaWYgKGRlY2wubmFtZS5raW5kID09PSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXIpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBnZXRJZGVudGlmaWVyVGV4dChkZWNsLm5hbWUgYXMgdHMuSWRlbnRpZmllcik7XG4gICAgICBpZiAoQ0xPU1VSRV9FWFRFUk5TX0JMQUNLTElTVC5pbmRleE9mKG5hbWUpID49IDApIHJldHVybjtcbiAgICAgIGVtaXQoanNkb2MudG9TdHJpbmcoW3t0YWdOYW1lOiAndHlwZScsIHR5cGU6IG10dC50eXBlVG9DbG9zdXJlKGRlY2wpfV0pKTtcbiAgICAgIGVtaXQoJ1xcbicpO1xuICAgICAgd3JpdGVWYXJpYWJsZVN0YXRlbWVudChuYW1lLCBuYW1lc3BhY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvclVuaW1wbGVtZW50ZWRLaW5kKGRlY2wubmFtZSwgJ2V4dGVybnMgZm9yIHZhcmlhYmxlJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGEgSlNEb2MgZGVjbGFyYXRpb24gdGhhdCBtZXJnZXMgdGhlIHNpZ25hdHVyZXMgb2YgdGhlIGdpdmVuIGZ1bmN0aW9uIGRlY2xhcmF0aW9uIChmb3JcbiAgICogb3ZlcmxvYWRzKSwgYW5kIHJldHVybnMgdGhlIHBhcmFtZXRlciBuYW1lcyBjaG9zZW4uXG4gICAqL1xuICBmdW5jdGlvbiBlbWl0RnVuY3Rpb25UeXBlKGRlY2xzOiB0cy5GdW5jdGlvbkxpa2VEZWNsYXJhdGlvbltdLCBleHRyYVRhZ3M6IGpzZG9jLlRhZ1tdID0gW10pIHtcbiAgICBjb25zdCB7dGFncywgcGFyYW1ldGVyTmFtZXN9ID0gbXR0LmdldEZ1bmN0aW9uVHlwZUpTRG9jKGRlY2xzLCBleHRyYVRhZ3MpO1xuICAgIGVtaXQoJ1xcbicpO1xuICAgIGVtaXQoanNkb2MudG9TdHJpbmcodGFncykpO1xuICAgIHJldHVybiBwYXJhbWV0ZXJOYW1lcztcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyaXRlRnVuY3Rpb24obmFtZTogdHMuTm9kZSwgcGFyYW1zOiBzdHJpbmdbXSwgbmFtZXNwYWNlOiBSZWFkb25seUFycmF5PHN0cmluZz4pIHtcbiAgICBjb25zdCBwYXJhbXNTdHIgPSBwYXJhbXMuam9pbignLCAnKTtcbiAgICBpZiAobmFtZXNwYWNlLmxlbmd0aCA+IDApIHtcbiAgICAgIGxldCBmcW4gPSBuYW1lc3BhY2Uuam9pbignLicpO1xuICAgICAgaWYgKG5hbWUua2luZCA9PT0gdHMuU3ludGF4S2luZC5JZGVudGlmaWVyKSB7XG4gICAgICAgIGZxbiArPSAnLic7ICAvLyBjb21wdXRlZCBuYW1lcyBpbmNsdWRlIFsgXSBpbiB0aGVpciBnZXRUZXh0KCkgcmVwcmVzZW50YXRpb24uXG4gICAgICB9XG4gICAgICBmcW4gKz0gbmFtZS5nZXRUZXh0KCk7XG4gICAgICBlbWl0KGAke2Zxbn0gPSBmdW5jdGlvbigke3BhcmFtc1N0cn0pIHt9O1xcbmApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmFtZS5raW5kICE9PSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXIpIHtcbiAgICAgICAgcmVwb3J0RGlhZ25vc3RpYyhkaWFnbm9zdGljcywgbmFtZSwgJ05vbi1uYW1lc3BhY2VkIGNvbXB1dGVkIG5hbWUgaW4gZXh0ZXJucycpO1xuICAgICAgfVxuICAgICAgZW1pdChgZnVuY3Rpb24gJHtuYW1lLmdldFRleHQoKX0oJHtwYXJhbXNTdHJ9KSB7fVxcbmApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHdyaXRlRW51bShkZWNsOiB0cy5FbnVtRGVjbGFyYXRpb24sIG5hbWVzcGFjZTogUmVhZG9ubHlBcnJheTxzdHJpbmc+KSB7XG4gICAgLy8gRS5nLiAvKiogQGVudW0ge251bWJlcn0gKi8gdmFyIENPVU5UUlkgPSB7VVM6IDEsIENBOiAxfTtcbiAgICBjb25zdCBuYW1lID0gZ2V0SWRlbnRpZmllclRleHQoZGVjbC5uYW1lKTtcbiAgICBsZXQgbWVtYmVycyA9ICcnO1xuICAgIGNvbnN0IGVudW1UeXBlID0gZ2V0RW51bVR5cGUodHlwZUNoZWNrZXIsIGRlY2wpO1xuICAgIC8vIENsb3N1cmUgZW51bXMgbWVtYmVycyBtdXN0IGhhdmUgYSB2YWx1ZSBvZiB0aGUgY29ycmVjdCB0eXBlLCBidXQgdGhlIGFjdHVhbCB2YWx1ZSBkb2VzIG5vdFxuICAgIC8vIG1hdHRlciBpbiBleHRlcm5zLlxuICAgIGNvbnN0IGluaXRpYWxpemVyID0gZW51bVR5cGUgPT09ICdzdHJpbmcnID8gYCcnYCA6IDE7XG4gICAgZm9yIChjb25zdCBtZW1iZXIgb2YgZGVjbC5tZW1iZXJzKSB7XG4gICAgICBsZXQgbWVtYmVyTmFtZTogc3RyaW5nfHVuZGVmaW5lZDtcbiAgICAgIHN3aXRjaCAobWVtYmVyLm5hbWUua2luZCkge1xuICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuSWRlbnRpZmllcjpcbiAgICAgICAgICBtZW1iZXJOYW1lID0gZ2V0SWRlbnRpZmllclRleHQobWVtYmVyLm5hbWUgYXMgdHMuSWRlbnRpZmllcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5TdHJpbmdMaXRlcmFsOlxuICAgICAgICAgIGNvbnN0IHRleHQgPSAobWVtYmVyLm5hbWUgYXMgdHMuU3RyaW5nTGl0ZXJhbCkudGV4dDtcbiAgICAgICAgICBpZiAoaXNWYWxpZENsb3N1cmVQcm9wZXJ0eU5hbWUodGV4dCkpIG1lbWJlck5hbWUgPSB0ZXh0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKCFtZW1iZXJOYW1lKSB7XG4gICAgICAgIG1lbWJlcnMgKz0gYCAgLyogVE9ETzogJHt0cy5TeW50YXhLaW5kW21lbWJlci5uYW1lLmtpbmRdfTogJHtcbiAgICAgICAgICAgIGVzY2FwZUZvckNvbW1lbnQobWVtYmVyLm5hbWUuZ2V0VGV4dCgpKX0gKi9cXG5gO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG1lbWJlcnMgKz0gYCAgJHttZW1iZXJOYW1lfTogJHtpbml0aWFsaXplcn0sXFxuYDtcbiAgICB9XG5cbiAgICBlbWl0KGBcXG4vKiogQGVudW0geyR7ZW51bVR5cGV9fSAqL1xcbmApO1xuICAgIHdyaXRlVmFyaWFibGVTdGF0ZW1lbnQobmFtZSwgbmFtZXNwYWNlLCBge1xcbiR7bWVtYmVyc319YCk7XG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZVR5cGVBbGlhcyhkZWNsOiB0cy5UeXBlQWxpYXNEZWNsYXJhdGlvbiwgbmFtZXNwYWNlOiBSZWFkb25seUFycmF5PHN0cmluZz4pIHtcbiAgICBjb25zdCB0eXBlU3RyID0gbXR0LnR5cGVUb0Nsb3N1cmUoZGVjbCwgdW5kZWZpbmVkKTtcbiAgICBlbWl0KGBcXG4vKiogQHR5cGVkZWYgeyR7dHlwZVN0cn19ICovXFxuYCk7XG4gICAgd3JpdGVWYXJpYWJsZVN0YXRlbWVudChnZXRJZGVudGlmaWVyVGV4dChkZWNsLm5hbWUpLCBuYW1lc3BhY2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gd3JpdGVUeXBlKFxuICAgICAgZGVjbDogdHMuSW50ZXJmYWNlRGVjbGFyYXRpb258dHMuQ2xhc3NEZWNsYXJhdGlvbiwgbmFtZXNwYWNlOiBSZWFkb25seUFycmF5PHN0cmluZz4pIHtcbiAgICBjb25zdCBuYW1lID0gZGVjbC5uYW1lO1xuICAgIGlmICghbmFtZSkge1xuICAgICAgcmVwb3J0RGlhZ25vc3RpYyhkaWFnbm9zdGljcywgZGVjbCwgJ2Fub255bW91cyB0eXBlIGluIGV4dGVybnMnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdHlwZU5hbWUgPSBuYW1lc3BhY2UuY29uY2F0KFtuYW1lLmdldFRleHQoKV0pLmpvaW4oJy4nKTtcbiAgICBpZiAoQ0xPU1VSRV9FWFRFUk5TX0JMQUNLTElTVC5pbmRleE9mKHR5cGVOYW1lKSA+PSAwKSByZXR1cm47XG5cbiAgICBpZiAoaXNGaXJzdFZhbHVlRGVjbGFyYXRpb24oZGVjbCkpIHtcbiAgICAgIC8vIEVtaXQgdGhlICdmdW5jdGlvbicgdGhhdCBpcyBhY3R1YWxseSB0aGUgZGVjbGFyYXRpb24gb2YgdGhlIGludGVyZmFjZVxuICAgICAgLy8gaXRzZWxmLiAgSWYgaXQncyBhIGNsYXNzLCB0aGlzIGZ1bmN0aW9uIGFsc28gbXVzdCBpbmNsdWRlIHRoZSB0eXBlXG4gICAgICAvLyBhbm5vdGF0aW9ucyBvZiB0aGUgY29uc3RydWN0b3IuXG4gICAgICBsZXQgcGFyYW1OYW1lczogc3RyaW5nW10gPSBbXTtcbiAgICAgIGNvbnN0IGpzZG9jVGFnczoganNkb2MuVGFnW10gPSBbXTtcbiAgICAgIGxldCB3cm90ZUpzRG9jID0gZmFsc2U7XG4gICAgICBtYXliZUFkZEhlcml0YWdlQ2xhdXNlcyhqc2RvY1RhZ3MsIG10dCwgZGVjbCk7XG4gICAgICBtYXliZUFkZFRlbXBsYXRlQ2xhdXNlKGpzZG9jVGFncywgZGVjbCk7XG4gICAgICBpZiAoZGVjbC5raW5kID09PSB0cy5TeW50YXhLaW5kLkNsYXNzRGVjbGFyYXRpb24pIHtcbiAgICAgICAgLy8gVE9ETzogaXQgYXBwZWFycyB5b3UgY2FuIGp1c3Qgd3JpdGUgJ2NsYXNzIEZvbyB7IC4uLicgaW4gZXh0ZXJucy5cbiAgICAgICAgLy8gVGhpcyBjb2RlIGluc3RlYWQgdHJpZXMgdG8gdHJhbnNsYXRlIGl0IHRvIGEgZnVuY3Rpb24uXG4gICAgICAgIGpzZG9jVGFncy5wdXNoKHt0YWdOYW1lOiAnY29uc3RydWN0b3InfSwge3RhZ05hbWU6ICdzdHJ1Y3QnfSk7XG4gICAgICAgIGNvbnN0IGN0b3JzID0gKGRlY2wgYXMgdHMuQ2xhc3NEZWNsYXJhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLm1lbWJlcnMuZmlsdGVyKChtKSA9PiBtLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuQ29uc3RydWN0b3IpO1xuICAgICAgICBpZiAoY3RvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgZmlyc3RDdG9yOiB0cy5Db25zdHJ1Y3RvckRlY2xhcmF0aW9uID0gY3RvcnNbMF0gYXMgdHMuQ29uc3RydWN0b3JEZWNsYXJhdGlvbjtcbiAgICAgICAgICBpZiAoY3RvcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcGFyYW1OYW1lcyA9IGVtaXRGdW5jdGlvblR5cGUoY3RvcnMgYXMgdHMuQ29uc3RydWN0b3JEZWNsYXJhdGlvbltdLCBqc2RvY1RhZ3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJhbU5hbWVzID0gZW1pdEZ1bmN0aW9uVHlwZShbZmlyc3RDdG9yXSwganNkb2NUYWdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd3JvdGVKc0RvYyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSBpdCdzIGFuIGludGVyZmFjZTsgdGFnIGl0IGFzIHN0cnVjdHVyYWxseSB0eXBlZC5cbiAgICAgICAganNkb2NUYWdzLnB1c2goe3RhZ05hbWU6ICdyZWNvcmQnfSwge3RhZ05hbWU6ICdzdHJ1Y3QnfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXdyb3RlSnNEb2MpIGVtaXQoanNkb2MudG9TdHJpbmcoanNkb2NUYWdzKSk7XG4gICAgICB3cml0ZUZ1bmN0aW9uKG5hbWUsIHBhcmFtTmFtZXMsIG5hbWVzcGFjZSk7XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBldmVyeXRoaW5nIGV4Y2VwdCAoTWV0aG9kU2lnbmF0dXJlfE1ldGhvZERlY2xhcmF0aW9ufENvbnN0cnVjdG9yKVxuICAgIGNvbnN0IG1ldGhvZHMgPSBuZXcgTWFwPHN0cmluZywgdHMuTWV0aG9kRGVjbGFyYXRpb25bXT4oKTtcbiAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiBkZWNsLm1lbWJlcnMpIHtcbiAgICAgIHN3aXRjaCAobWVtYmVyLmtpbmQpIHtcbiAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlByb3BlcnR5U2lnbmF0dXJlOlxuICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuUHJvcGVydHlEZWNsYXJhdGlvbjpcbiAgICAgICAgICBjb25zdCBwcm9wID0gbWVtYmVyIGFzIHRzLlByb3BlcnR5U2lnbmF0dXJlO1xuICAgICAgICAgIGlmIChwcm9wLm5hbWUua2luZCA9PT0gdHMuU3ludGF4S2luZC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IG10dC50eXBlVG9DbG9zdXJlKHByb3ApO1xuICAgICAgICAgICAgaWYgKHByb3AucXVlc3Rpb25Ub2tlbiAmJiB0eXBlID09PSAnPycpIHtcbiAgICAgICAgICAgICAgLy8gQW4gb3B0aW9uYWwgJ2FueScgdHlwZSB0cmFuc2xhdGVzIHRvICc/fHVuZGVmaW5lZCcgaW4gQ2xvc3VyZS5cbiAgICAgICAgICAgICAgdHlwZSA9ICc/fHVuZGVmaW5lZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbWl0KGpzZG9jLnRvU3RyaW5nKFt7dGFnTmFtZTogJ3R5cGUnLCB0eXBlfV0pKTtcbiAgICAgICAgICAgIGlmIChoYXNNb2RpZmllckZsYWcocHJvcCwgdHMuTW9kaWZpZXJGbGFncy5TdGF0aWMpKSB7XG4gICAgICAgICAgICAgIGVtaXQoYFxcbiR7dHlwZU5hbWV9LiR7cHJvcC5uYW1lLmdldFRleHQoKX07XFxuYCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbWl0KGBcXG4ke3R5cGVOYW1lfS5wcm90b3R5cGUuJHtwcm9wLm5hbWUuZ2V0VGV4dCgpfTtcXG5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBUT0RPOiBGb3Igbm93IHByb3BlcnR5IG5hbWVzIG90aGVyIHRoYW4gSWRlbnRpZmllcnMgYXJlIG5vdCBoYW5kbGVkOyBlLmcuXG4gICAgICAgICAgLy8gICAgaW50ZXJmYWNlIEZvbyB7IFwiMTIzYmFyXCI6IG51bWJlciB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5NZXRob2RTaWduYXR1cmU6XG4gICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5NZXRob2REZWNsYXJhdGlvbjpcbiAgICAgICAgICBjb25zdCBtZXRob2QgPSBtZW1iZXIgYXMgdHMuTWV0aG9kRGVjbGFyYXRpb247XG4gICAgICAgICAgY29uc3QgaXNTdGF0aWMgPSBoYXNNb2RpZmllckZsYWcobWV0aG9kLCB0cy5Nb2RpZmllckZsYWdzLlN0YXRpYyk7XG4gICAgICAgICAgY29uc3QgbWV0aG9kU2lnbmF0dXJlID0gYCR7bWV0aG9kLm5hbWUuZ2V0VGV4dCgpfSQkJCR7aXNTdGF0aWMgPyAnc3RhdGljJyA6ICdpbnN0YW5jZSd9YDtcblxuICAgICAgICAgIGlmIChtZXRob2RzLmhhcyhtZXRob2RTaWduYXR1cmUpKSB7XG4gICAgICAgICAgICBtZXRob2RzLmdldChtZXRob2RTaWduYXR1cmUpIS5wdXNoKG1ldGhvZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZHMuc2V0KG1ldGhvZFNpZ25hdHVyZSwgW21ldGhvZF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkNvbnN0cnVjdG9yOlxuICAgICAgICAgIGNvbnRpbnVlOyAgLy8gSGFuZGxlZCBhYm92ZS5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBNZW1iZXJzIGNhbiBpbmNsdWRlIHRoaW5ncyBsaWtlIGluZGV4IHNpZ25hdHVyZXMsIGZvciBlLmcuXG4gICAgICAgICAgLy8gICBpbnRlcmZhY2UgRm9vIHsgW2tleTogc3RyaW5nXTogbnVtYmVyOyB9XG4gICAgICAgICAgLy8gRm9yIG5vdywganVzdCBza2lwIGl0LlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUsIHRoZSBtZW1iZXIgd2Fzbid0IGhhbmRsZWQgaW4gdGhlIHN3aXRjaCBzdGF0ZW1lbnQuXG4gICAgICBsZXQgbWVtYmVyTmFtZSA9IG5hbWVzcGFjZTtcbiAgICAgIGlmIChtZW1iZXIubmFtZSkge1xuICAgICAgICBtZW1iZXJOYW1lID0gbWVtYmVyTmFtZS5jb25jYXQoW21lbWJlci5uYW1lLmdldFRleHQoKV0pO1xuICAgICAgfVxuICAgICAgZW1pdChgXFxuLyogVE9ETzogJHt0cy5TeW50YXhLaW5kW21lbWJlci5raW5kXX06ICR7bWVtYmVyTmFtZS5qb2luKCcuJyl9ICovXFxuYCk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIG1ldGhvZCBkZWNsYXJhdGlvbnMvc2lnbmF0dXJlcyBzZXBhcmF0ZWx5LCBzaW5jZSB3ZSBuZWVkIHRvIGRlYWwgd2l0aCBvdmVybG9hZHMuXG4gICAgZm9yIChjb25zdCBtZXRob2RWYXJpYW50cyBvZiBBcnJheS5mcm9tKG1ldGhvZHMudmFsdWVzKCkpKSB7XG4gICAgICBjb25zdCBmaXJzdE1ldGhvZFZhcmlhbnQgPSBtZXRob2RWYXJpYW50c1swXTtcbiAgICAgIGxldCBwYXJhbWV0ZXJOYW1lczogc3RyaW5nW107XG4gICAgICBpZiAobWV0aG9kVmFyaWFudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBwYXJhbWV0ZXJOYW1lcyA9IGVtaXRGdW5jdGlvblR5cGUobWV0aG9kVmFyaWFudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1ldGVyTmFtZXMgPSBlbWl0RnVuY3Rpb25UeXBlKFtmaXJzdE1ldGhvZFZhcmlhbnRdKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1ldGhvZE5hbWVzcGFjZSA9IG5hbWVzcGFjZS5jb25jYXQoW25hbWUuZ2V0VGV4dCgpXSk7XG4gICAgICAvLyBJZiB0aGUgbWV0aG9kIGlzIHN0YXRpYywgZG9uJ3QgYWRkIHRoZSBwcm90b3R5cGUuXG4gICAgICBpZiAoIWhhc01vZGlmaWVyRmxhZyhmaXJzdE1ldGhvZFZhcmlhbnQsIHRzLk1vZGlmaWVyRmxhZ3MuU3RhdGljKSkge1xuICAgICAgICBtZXRob2ROYW1lc3BhY2UucHVzaCgncHJvdG90eXBlJyk7XG4gICAgICB9XG4gICAgICB3cml0ZUZ1bmN0aW9uKGZpcnN0TWV0aG9kVmFyaWFudC5uYW1lLCBwYXJhbWV0ZXJOYW1lcywgbWV0aG9kTmFtZXNwYWNlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZUV4cG9ydERlY2xhcmF0aW9uKFxuICAgICAgZXhwb3J0RGVjbGFyYXRpb246IHRzLkV4cG9ydERlY2xhcmF0aW9uLCBuYW1lc3BhY2U6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPikge1xuICAgIGlmICghZXhwb3J0RGVjbGFyYXRpb24uZXhwb3J0Q2xhdXNlKSB7XG4gICAgICBlbWl0KGBcXG4vLyBUT0RPKHRzaWNrbGUpOiBleHBvcnQgKiBkZWNsYXJhdGlvbiBpbiAke1xuICAgICAgICAgIGRlYnVnTG9jYXRpb25TdHIoZXhwb3J0RGVjbGFyYXRpb24sIG5hbWVzcGFjZSl9XFxuYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgZXhwb3J0U3BlY2lmaWVyIG9mIGV4cG9ydERlY2xhcmF0aW9uLmV4cG9ydENsYXVzZS5lbGVtZW50cykge1xuICAgICAgLy8gTm8gbmVlZCB0byBkbyBhbnl0aGluZyBmb3IgcHJvcGVydGllcyBleHBvcnRlZCB1bmRlciB0aGVpciBvcmlnaW5hbCBuYW1lLlxuICAgICAgaWYgKCFleHBvcnRTcGVjaWZpZXIucHJvcGVydHlOYW1lKSBjb250aW51ZTtcbiAgICAgIGVtaXQoJy8qKiBAY29uc3QgKi9cXG4nKTtcbiAgICAgIHdyaXRlVmFyaWFibGVTdGF0ZW1lbnQoXG4gICAgICAgICAgZXhwb3J0U3BlY2lmaWVyLm5hbWUudGV4dCwgbmFtZXNwYWNlLFxuICAgICAgICAgIG5hbWVzcGFjZS5qb2luKCcuJykgKyAnLicgKyBleHBvcnRTcGVjaWZpZXIucHJvcGVydHlOYW1lLnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFsaWFzZXMgZm9yIHRoZSBzeW1ib2xzIGltcG9ydGVkIGluIHRoZSBnaXZlbiBkZWNsYXJhdGlvbiwgc28gdGhhdCB0aGVpciB0eXBlcyBnZXRcbiAgICogcHJpbnRlZCBhcyB0aGUgZnVsbHkgcXVhbGlmaWVkIG5hbWUsIGFuZCBub3QganVzdCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgbG9jYWwgaW1wb3J0IGFsaWFzLlxuICAgKlxuICAgKiB0c2lja2xlIGdlbmVyYXRlcyAuanMgZmlsZXMgdGhhdCAoYXQgbW9zdCkgY29udGFpbiBhIGBnb29nLnByb3ZpZGVgLCBidXQgYXJlIG5vdFxuICAgKiBgZ29vZy5tb2R1bGVgcy4gVGhlc2UgZmlsZXMgY2Fubm90IGV4cHJlc3MgYW4gYWxpYXNlZCBpbXBvcnQuIEhvd2V2ZXIgQ2xvc3VyZSBDb21waWxlciBhbGxvd3NcbiAgICogcmVmZXJlbmNpbmcgdHlwZXMgdXNpbmcgZnVsbHkgcXVhbGlmaWVkIG5hbWVzIGluIHN1Y2ggZmlsZXMsIHNvIHRzaWNrbGUgY2FuIHJlc29sdmUgdGhlXG4gICAqIGltcG9ydGVkIG1vZHVsZSBVUkkgYW5kIHByb2R1Y2UgYHBhdGgudG8ubW9kdWxlLlN5bWJvbGAgYXMgYW4gYWxpYXMsIGFuZCB1c2UgdGhhdCB3aGVuXG4gICAqIHJlZmVyZW5jaW5nIHRoZSB0eXBlLlxuICAgKi9cbiAgZnVuY3Rpb24gYWRkSW1wb3J0QWxpYXNlcyhkZWNsOiB0cy5JbXBvcnREZWNsYXJhdGlvbnx0cy5JbXBvcnRFcXVhbHNEZWNsYXJhdGlvbikge1xuICAgIGxldCBtb2R1bGVVcmk6IHN0cmluZztcbiAgICBpZiAodHMuaXNJbXBvcnREZWNsYXJhdGlvbihkZWNsKSkge1xuICAgICAgbW9kdWxlVXJpID0gKGRlY2wubW9kdWxlU3BlY2lmaWVyIGFzIHRzLlN0cmluZ0xpdGVyYWwpLnRleHQ7XG4gICAgfSBlbHNlIGlmICh0cy5pc0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlKGRlY2wubW9kdWxlUmVmZXJlbmNlKSkge1xuICAgICAgLy8gaW1wb3J0IGZvbyA9IHJlcXVpcmUoJy4vYmFyJyk7XG4gICAgICBtb2R1bGVVcmkgPSAoZGVjbC5tb2R1bGVSZWZlcmVuY2UuZXhwcmVzc2lvbiBhcyB0cy5TdHJpbmdMaXRlcmFsKS50ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbXBvcnQgZm9vID0gYmFyLmJhei5iYW07XG4gICAgICAvLyBoYW5kbGVkIGF0IGNhbGwgc2l0ZS5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHMuaXNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbihkZWNsKSkge1xuICAgICAgLy8gaW1wb3J0IGZvbyA9IHJlcXVpcmUoJy4vYmFyJyk7XG4gICAgICBhZGRJbXBvcnRBbGlhcyhkZWNsLm5hbWUsIG1vZHVsZVVyaSwgdW5kZWZpbmVkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnQsIGxpa2UgXCJpbXBvcnQgJ3NvbWVwYXRoJztcIiBkZWNsYXJlcyBubyBsb2NhbCBhbGlhc2VzLlxuICAgIGlmICghZGVjbC5pbXBvcnRDbGF1c2UpIHJldHVybjtcblxuICAgIGlmIChkZWNsLmltcG9ydENsYXVzZS5uYW1lKSB7XG4gICAgICAvLyBpbXBvcnQgbmFtZSBmcm9tIC4uLiAtPiBtYXAgdG8gLmRlZmF1bHQgb24gdGhlIG1vZHVsZS5uYW1lLlxuICAgICAgYWRkSW1wb3J0QWxpYXMoZGVjbC5pbXBvcnRDbGF1c2UubmFtZSwgbW9kdWxlVXJpLCAnZGVmYXVsdCcpO1xuICAgIH1cbiAgICBjb25zdCBuYW1lZEJpbmRpbmdzID0gZGVjbC5pbXBvcnRDbGF1c2UubmFtZWRCaW5kaW5ncztcbiAgICBpZiAoIW5hbWVkQmluZGluZ3MpIHJldHVybjtcblxuICAgIGlmICh0cy5pc05hbWVzcGFjZUltcG9ydChuYW1lZEJpbmRpbmdzKSkge1xuICAgICAgLy8gaW1wb3J0ICogYXMgbmFtZSAtPiBtYXAgZGlyZWN0bHkgdG8gdGhlIG1vZHVsZS5uYW1lLlxuICAgICAgYWRkSW1wb3J0QWxpYXMobmFtZWRCaW5kaW5ncy5uYW1lLCBtb2R1bGVVcmksIHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgaWYgKHRzLmlzTmFtZWRJbXBvcnRzKG5hbWVkQmluZGluZ3MpKSB7XG4gICAgICAvLyBpbXBvcnQge0EgYXMgQn0sIG1hcCB0byBtb2R1bGUubmFtZS5BXG4gICAgICBmb3IgKGNvbnN0IG5hbWVkQmluZGluZyBvZiBuYW1lZEJpbmRpbmdzLmVsZW1lbnRzKSB7XG4gICAgICAgIGFkZEltcG9ydEFsaWFzKG5hbWVkQmluZGluZy5uYW1lLCBtb2R1bGVVcmksIG5hbWVkQmluZGluZy5uYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBpbXBvcnQgYWxpYXMgZm9yIHRoZSBzeW1ib2wgZGVmaW5lZCBhdCB0aGUgZ2l2ZW4gbm9kZS4gQ3JlYXRlcyBhbiBhbGlhcyBuYW1lIGJhc2VkIG9uXG4gICAqIHRoZSBnaXZlbiBtb2R1bGVOYW1lIGFuZCAob3B0aW9uYWxseSkgdGhlIG5hbWUuXG4gICAqL1xuICBmdW5jdGlvbiBhZGRJbXBvcnRBbGlhcyhub2RlOiB0cy5Ob2RlLCBtb2R1bGVVcmk6IHN0cmluZywgbmFtZTogdHMuSWRlbnRpZmllcnxzdHJpbmd8dW5kZWZpbmVkKSB7XG4gICAgbGV0IHN5bWJvbCA9IHR5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24obm9kZSk7XG4gICAgaWYgKCFzeW1ib2wpIHtcbiAgICAgIHJlcG9ydERpYWdub3N0aWMoZGlhZ25vc3RpY3MsIG5vZGUsIGBuYW1lZCBpbXBvcnQgaGFzIG5vIHN5bWJvbGApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3ltYm9sLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuQWxpYXMpIHtcbiAgICAgIHN5bWJvbCA9IHR5cGVDaGVja2VyLmdldEFsaWFzZWRTeW1ib2woc3ltYm9sKTtcbiAgICB9XG5cbiAgICBjb25zdCBnb29nTmFtZXNwYWNlID0gZXh0cmFjdEdvb2dOYW1lc3BhY2VJbXBvcnQobW9kdWxlVXJpKTtcbiAgICBsZXQgYWxpYXNOYW1lOiBzdHJpbmc7XG4gICAgaWYgKGdvb2dOYW1lc3BhY2UpIHtcbiAgICAgIGFsaWFzTmFtZSA9IGdvb2dOYW1lc3BhY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdoaWxlIHR5cGVfdHJhbnNsYXRvciBkb2VzIGFkZCB0aGUgbWFuZ2xlZCBwcmVmaXggZm9yIGFtYmllbnQgZGVjbGFyYXRpb25zLCBpdCBvbmx5IGRvZXMgc29cbiAgICAgIC8vIGZvciBub24tYWxpYXNlZCAoaS5lLiBub3QgaW1wb3J0ZWQpIHN5bWJvbHMuIFRoYXQncyBjb3JyZWN0IGZvciBpdHMgdXNlIGluIHJlZ3VsYXIgbW9kdWxlcyxcbiAgICAgIC8vIHdoaWNoIHdpbGwgaGF2ZSBhIGxvY2FsIHN5bWJvbCBmb3IgdGhlIGltcG9ydGVkIGFtYmllbnQgc3ltYm9sLiBIb3dldmVyIHdpdGhpbiBhbiBleHRlcm5zXG4gICAgICAvLyBmaWxlLCB0aGVyZSBhcmUgbm8gaW1wb3J0cywgc28gd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhlIGFsaWFzIGFscmVhZHkgY29udGFpbnMgdGhlIGNvcnJlY3RcbiAgICAgIC8vIG1vZHVsZSBuYW1lLCB3aGljaCBtZWFucyB0aGUgbWFuZ2xlZCBtb2R1bGUgbmFtZSBpbiBjYXNlIG9mIGltcG9ydHMgc3ltYm9scy5cbiAgICAgIC8vIFRoaXMgb25seSBhcHBsaWVzIHRvIG5vbi1DbG9zdXJlICgnZ29vZzonKSBpbXBvcnRzLlxuICAgICAgY29uc3QgaXNBbWJpZW50TW9kdWxlRGVjbGFyYXRpb24gPVxuICAgICAgICAgIHN5bWJvbC5kZWNsYXJhdGlvbnMgJiYgc3ltYm9sLmRlY2xhcmF0aW9ucy5zb21lKGQgPT4gaXNBbWJpZW50KGQpKTtcbiAgICAgIGNvbnN0IGZ1bGxVcmkgPSByZXNvbHZlTW9kdWxlTmFtZShob3N0LCBzb3VyY2VGaWxlLmZpbGVOYW1lLCBtb2R1bGVVcmkpO1xuICAgICAgaWYgKGlzQW1iaWVudE1vZHVsZURlY2xhcmF0aW9uKSB7XG4gICAgICAgIGFsaWFzTmFtZSA9IG1vZHVsZU5hbWVBc0lkZW50aWZpZXIoaG9zdCwgZnVsbFVyaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGlhc05hbWUgPSBob3N0LnBhdGhUb01vZHVsZU5hbWUoXG4gICAgICAgICAgICBzb3VyY2VGaWxlLmZpbGVOYW1lLCByZXNvbHZlTW9kdWxlTmFtZShob3N0LCBzb3VyY2VGaWxlLmZpbGVOYW1lLCBmdWxsVXJpKSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGFsaWFzTmFtZSArPSAnLicgKyBuYW1lO1xuICAgICAgfSBlbHNlIGlmIChuYW1lKSB7XG4gICAgICAgIGFsaWFzTmFtZSArPSAnLicgKyBnZXRJZGVudGlmaWVyVGV4dChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtdHQuc3ltYm9sc1RvQWxpYXNlZE5hbWVzLnNldChzeW1ib2wsIGFsaWFzTmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogUHJvZHVjZXMgYSBjb21waWxlciBlcnJvciB0aGF0IHJlZmVyZW5jZXMgdGhlIE5vZGUncyBraW5kLiBUaGlzIGlzIHVzZWZ1bCBmb3IgdGhlIFwiZWxzZVwiXG4gICAqIGJyYW5jaCBvZiBjb2RlIHRoYXQgaXMgYXR0ZW1wdGluZyB0byBoYW5kbGUgYWxsIHBvc3NpYmxlIGlucHV0IE5vZGUgdHlwZXMsIHRvIGVuc3VyZSBhbGwgY2FzZXNcbiAgICogY292ZXJlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGVycm9yVW5pbXBsZW1lbnRlZEtpbmQobm9kZTogdHMuTm9kZSwgd2hlcmU6IHN0cmluZykge1xuICAgIHJlcG9ydERpYWdub3N0aWMoZGlhZ25vc3RpY3MsIG5vZGUsIGAke3RzLlN5bnRheEtpbmRbbm9kZS5raW5kXX0gbm90IGltcGxlbWVudGVkIGluICR7d2hlcmV9YCk7XG4gIH1cblxuICAvKipcbiAgICogZ2V0TmFtZXNwYWNlRm9yTG9jYWxEZWNsYXJhdGlvbiByZXR1cm5zIHRoZSBuYW1lc3BhY2UgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgdGhlIGdpdmVuXG4gICAqIGRlY2xhcmF0aW9uLCBkZWNpZGluZyB3aGV0aGVyIHRvIG5hbWVzcGFjZSB0aGUgc3ltYm9sIHRvIHRoZSBmaWxlIG9yIHdoZXRoZXIgdG8gY3JlYXRlIGFcbiAgICogZ2xvYmFsIG5hbWUuXG4gICAqXG4gICAqIFRoZSBmdW5jdGlvbiBjb3ZlcnMgdGhlc2UgY2FzZXM6XG4gICAqIDEpIGEgZGVjbGFyYXRpb24gaW4gYSAuZC50c1xuICAgKiAxYSkgd2hlcmUgdGhlIC5kLnRzIGlzIGFuIGV4dGVybmFsIG1vZHVsZSAgICAgLS0+IG5hbWVzcGFjZVxuICAgKiAxYikgd2hlcmUgdGhlIC5kLnRzIGlzIG5vdCBhbiBleHRlcm5hbCBtb2R1bGUgLS0+IGdsb2JhbFxuICAgKiAyKSBhIGRlY2xhcmF0aW9uIGluIGEgLnRzIGZpbGUgKGFsbCBhcmUgdHJlYXRlZCBhcyBtb2R1bGVzKVxuICAgKiAyYSkgdGhhdCBpcyBleHBvcnRlZCAgICAgICAgICAgICAgICAgICAgICAgICAgLS0+IG5hbWVzcGFjZVxuICAgKiAyYikgdGhhdCBpcyB1bmV4cG9ydGVkICAgICAgICAgICAgICAgICAgICAgICAgLS0+IGdsb2JhbFxuICAgKlxuICAgKiBGb3IgMSksIGFsbCBzeW1ib2xzIGluIC5kLnRzIHNob3VsZCBnZW5lcmFsbHkgYmUgbmFtZXNwYWNlZCB0byB0aGUgZmlsZSB0byBhdm9pZCBjb2xsaXNpb25zLlxuICAgKiBIb3dldmVyIC5kLnRzIGZpbGVzIHRoYXQgYXJlIG5vdCBleHRlcm5hbCBtb2R1bGVzIGRvIGRlY2xhcmUgZ2xvYmFsIG5hbWVzICgxYikuXG4gICAqXG4gICAqIEZvciAyKSwgYW1iaWVudCBkZWNsYXJhdGlvbnMgaW4gLnRzIGZpbGVzIG11c3QgYmUgbmFtZXNwYWNlZCwgZm9yIHRoZSBzYW1lIGNvbGxpc2lvbiByZWFzb25zLlxuICAgKiBUaGUgZXhjZXB0aW9uIGlzIDJiKSwgd2hlcmUgaW4gVHlwZVNjcmlwdCwgYW4gdW5leHBvcnRlZCBsb2NhbCBcImRlY2xhcmUgY29uc3QgeDogc3RyaW5nO1wiXG4gICAqIGNyZWF0ZXMgYSBzeW1ib2wgdGhhdCwgd2hlbiB1c2VkIGxvY2FsbHksIGlzIGVtaXR0ZWQgYXMganVzdCBcInhcIi4gVGhhdCBpcywgaXQgYmVoYXZlc1xuICAgKiBsaWtlIGEgdmFyaWFibGUgZGVjbGFyZWQgaW4gYSAnZGVjbGFyZSBnbG9iYWwnIGJsb2NrLiBDbG9zdXJlIENvbXBpbGVyIHdvdWxkIGZhaWwgdGhlIGJ1aWxkIGlmXG4gICAqIHRoZXJlIGlzIG5vIGRlY2xhcmF0aW9uIGZvciBcInhcIiwgc28gdHNpY2tsZSBtdXN0IGdlbmVyYXRlIGEgZ2xvYmFsIGV4dGVybmFsIHN5bWJvbCwgaS5lLlxuICAgKiB3aXRob3V0IHRoZSBuYW1lc3BhY2Ugd3JhcHBlci5cbiAgICovXG4gIGZ1bmN0aW9uIGdldE5hbWVzcGFjZUZvclRvcExldmVsRGVjbGFyYXRpb24oXG4gICAgICBkZWNsYXJhdGlvbjogdHMuRGVjbGFyYXRpb24sIG5hbWVzcGFjZTogUmVhZG9ubHlBcnJheTxzdHJpbmc+KTogUmVhZG9ubHlBcnJheTxzdHJpbmc+IHtcbiAgICAvLyBPbmx5IHVzZSByb290TmFtZXNwYWNlIGZvciB0b3AgbGV2ZWwgc3ltYm9scywgYW55IG90aGVyIG5hbWVzcGFjaW5nIChnbG9iYWwgbmFtZXMsIG5lc3RlZFxuICAgIC8vIG5hbWVzcGFjZXMpIGlzIGFsd2F5cyBrZXB0LlxuICAgIGlmIChuYW1lc3BhY2UubGVuZ3RoICE9PSAwKSByZXR1cm4gbmFtZXNwYWNlO1xuICAgIC8vIEFsbCBuYW1lcyBpbiBhIG1vZHVsZSAoZXh0ZXJuYWwpIC5kLnRzIGZpbGUgY2FuIG9ubHkgYmUgYWNjZXNzZWQgbG9jYWxseSwgc28gdGhleSBhbHdheXMgZ2V0XG4gICAgLy8gbmFtZXNwYWNlIHByZWZpeGVkLlxuICAgIGlmIChpc0R0cyAmJiBpc0V4dGVybmFsTW9kdWxlKSByZXR1cm4gW3Jvb3ROYW1lc3BhY2VdO1xuICAgIC8vIFNhbWUgZm9yIGV4cG9ydGVkIGRlY2xhcmF0aW9ucyBpbiByZWd1bGFyIC50cyBmaWxlcy5cbiAgICBpZiAoaGFzTW9kaWZpZXJGbGFnKGRlY2xhcmF0aW9uLCB0cy5Nb2RpZmllckZsYWdzLkV4cG9ydCkpIHJldHVybiBbcm9vdE5hbWVzcGFjZV07XG4gICAgLy8gQnV0IGxvY2FsIGRlY2xhcmF0aW9ucyBpbiAudHMgZmlsZXMgb3IgLmQudHMgZmlsZXMgKDFiLCAyYikgYXJlIGdsb2JhbCwgdG9vLlxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciB0aGUgbG9jYXRpb246IGVpdGhlciB0aGUgbmFtZXNwYWNlLCBvciwgaWYgZW1wdHksIHRoZVxuICAgKiBjdXJyZW50IHNvdXJjZSBmaWxlIG5hbWUuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIGVtaXQgZm9yIHdhcm5pbmdzLCBzbyB0aGF0XG4gICAqIHVzZXJzIGNhbiBtb3JlIGVhc2lseSBmaW5kIHdoZXJlIGEgcHJvYmxlbWF0aWMgZGVmaW5pdGlvbiBpcyBmcm9tLlxuICAgKlxuICAgKiBUaGUgY29kZSBiZWxvdyBkb2VzIG5vdCB1c2UgZGlhZ25vc3RpY3MgdG8gYXZvaWQgYnJlYWtpbmcgdGhlIGJ1aWxkIGZvciBoYXJtbGVzcyB1bmhhbmRsZWRcbiAgICogY2FzZXMuXG4gICAqL1xuICBmdW5jdGlvbiBkZWJ1Z0xvY2F0aW9uU3RyKG5vZGU6IHRzLk5vZGUsIG5hbWVzcGFjZTogUmVhZG9ubHlBcnJheTxzdHJpbmc+KSB7XG4gICAgLy8gVXNlIGEgcmVnZXggdG8gZ3JhYiB0aGUgZmlsZW5hbWUgd2l0aG91dCBhIHBhdGgsIHRvIG1ha2UgdGhlIG91dHB1dCBzdGFibGVcbiAgICAvLyB1bmRlciBiYXplbCB3aGVyZSBzYW5kYm94ZXMgdXNlIGRpZmZlcmVudCBwYXRocy5cbiAgICByZXR1cm4gbmFtZXNwYWNlLmpvaW4oJy4nKSB8fCBub2RlLmdldFNvdXJjZUZpbGUoKS5maWxlTmFtZS5yZXBsYWNlKC8uKlsvXFxcXF0vLCAnJyk7XG4gIH1cblxuICBmdW5jdGlvbiB2aXNpdG9yKG5vZGU6IHRzLk5vZGUsIG5hbWVzcGFjZTogUmVhZG9ubHlBcnJheTxzdHJpbmc+KSB7XG4gICAgaWYgKG5vZGUucGFyZW50ID09PSBzb3VyY2VGaWxlKSB7XG4gICAgICBuYW1lc3BhY2UgPSBnZXROYW1lc3BhY2VGb3JUb3BMZXZlbERlY2xhcmF0aW9uKG5vZGUgYXMgdHMuRGVjbGFyYXRpb25TdGF0ZW1lbnQsIG5hbWVzcGFjZSk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChub2RlLmtpbmQpIHtcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5Nb2R1bGVEZWNsYXJhdGlvbjpcbiAgICAgICAgY29uc3QgZGVjbCA9IG5vZGUgYXMgdHMuTW9kdWxlRGVjbGFyYXRpb247XG4gICAgICAgIHN3aXRjaCAoZGVjbC5uYW1lLmtpbmQpIHtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuSWRlbnRpZmllcjpcbiAgICAgICAgICAgIGlmIChkZWNsLmZsYWdzICYgdHMuTm9kZUZsYWdzLkdsb2JhbEF1Z21lbnRhdGlvbikge1xuICAgICAgICAgICAgICAvLyBFLmcuIFwiZGVjbGFyZSBnbG9iYWwgeyAuLi4gfVwiLiAgUmVzZXQgdG8gdGhlIG91dGVyIG5hbWVzcGFjZS5cbiAgICAgICAgICAgICAgbmFtZXNwYWNlID0gW107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBFLmcuIFwiZGVjbGFyZSBuYW1lc3BhY2UgZm9vIHtcIlxuICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZ2V0SWRlbnRpZmllclRleHQoZGVjbC5uYW1lIGFzIHRzLklkZW50aWZpZXIpO1xuICAgICAgICAgICAgICBpZiAoaXNGaXJzdFZhbHVlRGVjbGFyYXRpb24oZGVjbCkpIHtcbiAgICAgICAgICAgICAgICBlbWl0KCcvKiogQGNvbnN0ICovXFxuJyk7XG4gICAgICAgICAgICAgICAgd3JpdGVWYXJpYWJsZVN0YXRlbWVudChuYW1lLCBuYW1lc3BhY2UsICd7fScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5hbWVzcGFjZSA9IG5hbWVzcGFjZS5jb25jYXQobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVjbC5ib2R5KSB2aXNpdG9yKGRlY2wuYm9keSwgbmFtZXNwYWNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5TdHJpbmdMaXRlcmFsOlxuICAgICAgICAgICAgLy8gRS5nLiBcImRlY2xhcmUgbW9kdWxlICdmb28nIHtcIiAobm90ZSB0aGUgcXVvdGVzKS5cbiAgICAgICAgICAgIC8vIFdlIHN0aWxsIHdhbnQgdG8gZW1pdCBleHRlcm5zIGZvciB0aGlzIG1vZHVsZSwgYnV0IENsb3N1cmUgZG9lc24ndCBwcm92aWRlIGFcbiAgICAgICAgICAgIC8vIG1lY2hhbmlzbSBmb3IgbW9kdWxlLXNjb3BlZCBleHRlcm5zLiBJbnN0ZWFkLCB3ZSBlbWl0IGluIGEgbWFuZ2xlZCBuYW1lc3BhY2UuXG4gICAgICAgICAgICAvLyBUaGUgbWFuZ2xlZCBuYW1lc3BhY2UgKGFmdGVyIHJlc29sdmluZyBmaWxlcykgbWF0Y2hlcyB0aGUgZW1pdCBmb3IgYW4gb3JpZ2luYWwgbW9kdWxlXG4gICAgICAgICAgICAvLyBmaWxlLCBzbyBlZmZlY3RpdmVseSB0aGlzIGF1Z21lbnRzIGFueSBleGlzdGluZyBtb2R1bGUuXG5cbiAgICAgICAgICAgIGNvbnN0IGltcG9ydE5hbWUgPSAoZGVjbC5uYW1lIGFzIHRzLlN0cmluZ0xpdGVyYWwpLnRleHQ7XG4gICAgICAgICAgICBjb25zdCBpbXBvcnRlZE1vZHVsZU5hbWUgPVxuICAgICAgICAgICAgICAgIHJlc29sdmVNb2R1bGVOYW1lKHttb2R1bGVSZXNvbHV0aW9uSG9zdCwgb3B0aW9uc30sIHNvdXJjZUZpbGUuZmlsZU5hbWUsIGltcG9ydE5hbWUpO1xuICAgICAgICAgICAgY29uc3QgbWFuZ2xlZCA9IG1vZHVsZU5hbWVBc0lkZW50aWZpZXIoaG9zdCwgaW1wb3J0ZWRNb2R1bGVOYW1lKTtcbiAgICAgICAgICAgIGVtaXQoYC8vIERlcml2ZWQgZnJvbTogZGVjbGFyZSBtb2R1bGUgXCIke2ltcG9ydE5hbWV9XCJcXG5gKTtcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IFttYW5nbGVkXTtcblxuICAgICAgICAgICAgLy8gRGVjbGFyZSBcIm1hbmdsZWQkbmFtZVwiIGlmIGl0J3Mgbm90IGRlY2xhcmVkIGFscmVhZHkgZWxzZXdoZXJlLlxuICAgICAgICAgICAgaWYgKGlzRmlyc3RWYWx1ZURlY2xhcmF0aW9uKGRlY2wpKSB7XG4gICAgICAgICAgICAgIGVtaXQoJy8qKiBAY29uc3QgKi9cXG4nKTtcbiAgICAgICAgICAgICAgd3JpdGVWYXJpYWJsZVN0YXRlbWVudChtYW5nbGVkLCBbXSwgJ3t9Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZWNsYXJlIHRoZSBjb250ZW50cyBpbnNpZGUgdGhlIFwibWFuZ2xlZCRuYW1lXCIuXG4gICAgICAgICAgICBpZiAoZGVjbC5ib2R5KSB2aXNpdG9yKGRlY2wuYm9keSwgW21hbmdsZWRdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBlcnJvclVuaW1wbGVtZW50ZWRLaW5kKGRlY2wubmFtZSwgJ2V4dGVybnMgZ2VuZXJhdGlvbiBvZiBuYW1lc3BhY2UnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLk1vZHVsZUJsb2NrOlxuICAgICAgICBjb25zdCBibG9jayA9IG5vZGUgYXMgdHMuTW9kdWxlQmxvY2s7XG4gICAgICAgIGZvciAoY29uc3Qgc3RtdCBvZiBibG9jay5zdGF0ZW1lbnRzKSB7XG4gICAgICAgICAgdmlzaXRvcihzdG10LCBuYW1lc3BhY2UpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkltcG9ydEVxdWFsc0RlY2xhcmF0aW9uOlxuICAgICAgICBjb25zdCBpbXBvcnRFcXVhbHMgPSBub2RlIGFzIHRzLkltcG9ydEVxdWFsc0RlY2xhcmF0aW9uO1xuICAgICAgICBjb25zdCBsb2NhbE5hbWUgPSBnZXRJZGVudGlmaWVyVGV4dChpbXBvcnRFcXVhbHMubmFtZSk7XG4gICAgICAgIGlmIChpbXBvcnRFcXVhbHMubW9kdWxlUmVmZXJlbmNlLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2UpIHtcbiAgICAgICAgICBhZGRJbXBvcnRBbGlhc2VzKGltcG9ydEVxdWFscyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcW4gPSBxdWFsaWZpZWROYW1lVG9NYW5nbGVkSWRlbnRpZmllcihpbXBvcnRFcXVhbHMubW9kdWxlUmVmZXJlbmNlKTtcbiAgICAgICAgLy8gQGNvbnN0IHNvIHRoYXQgQ2xvc3VyZSBDb21waWxlciB1bmRlcnN0YW5kcyB0aGlzIGlzIGFuIGFsaWFzLlxuICAgICAgICBlbWl0KCcvKiogQGNvbnN0ICovXFxuJyk7XG4gICAgICAgIHdyaXRlVmFyaWFibGVTdGF0ZW1lbnQobG9jYWxOYW1lLCBuYW1lc3BhY2UsIHFuKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuQ2xhc3NEZWNsYXJhdGlvbjpcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5JbnRlcmZhY2VEZWNsYXJhdGlvbjpcbiAgICAgICAgd3JpdGVUeXBlKG5vZGUgYXMgdHMuSW50ZXJmYWNlRGVjbGFyYXRpb24gfCB0cy5DbGFzc0RlY2xhcmF0aW9uLCBuYW1lc3BhY2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5GdW5jdGlvbkRlY2xhcmF0aW9uOlxuICAgICAgICBjb25zdCBmbkRlY2wgPSBub2RlIGFzIHRzLkZ1bmN0aW9uRGVjbGFyYXRpb247XG4gICAgICAgIGNvbnN0IG5hbWUgPSBmbkRlY2wubmFtZTtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgcmVwb3J0RGlhZ25vc3RpYyhkaWFnbm9zdGljcywgZm5EZWNsLCAnYW5vbnltb3VzIGZ1bmN0aW9uIGluIGV4dGVybnMnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBHYXRoZXIgdXAgYWxsIG92ZXJsb2FkcyBvZiB0aGlzIGZ1bmN0aW9uLlxuICAgICAgICBjb25zdCBzeW0gPSB0eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKG5hbWUpITtcbiAgICAgICAgY29uc3QgZGVjbHMgPSBzeW0uZGVjbGFyYXRpb25zIS5maWx0ZXIodHMuaXNGdW5jdGlvbkRlY2xhcmF0aW9uKTtcbiAgICAgICAgLy8gT25seSBlbWl0IHRoZSBmaXJzdCBkZWNsYXJhdGlvbiBvZiBlYWNoIG92ZXJsb2FkZWQgZnVuY3Rpb24uXG4gICAgICAgIGlmIChmbkRlY2wgIT09IGRlY2xzWzBdKSBicmVhaztcbiAgICAgICAgY29uc3QgcGFyYW1zID0gZW1pdEZ1bmN0aW9uVHlwZShkZWNscyk7XG4gICAgICAgIHdyaXRlRnVuY3Rpb24obmFtZSwgcGFyYW1zLCBuYW1lc3BhY2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5WYXJpYWJsZVN0YXRlbWVudDpcbiAgICAgICAgZm9yIChjb25zdCBkZWNsIG9mIChub2RlIGFzIHRzLlZhcmlhYmxlU3RhdGVtZW50KS5kZWNsYXJhdGlvbkxpc3QuZGVjbGFyYXRpb25zKSB7XG4gICAgICAgICAgd3JpdGVWYXJpYWJsZURlY2xhcmF0aW9uKGRlY2wsIG5hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuRW51bURlY2xhcmF0aW9uOlxuICAgICAgICB3cml0ZUVudW0obm9kZSBhcyB0cy5FbnVtRGVjbGFyYXRpb24sIG5hbWVzcGFjZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlR5cGVBbGlhc0RlY2xhcmF0aW9uOlxuICAgICAgICB3cml0ZVR5cGVBbGlhcyhub2RlIGFzIHRzLlR5cGVBbGlhc0RlY2xhcmF0aW9uLCBuYW1lc3BhY2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5JbXBvcnREZWNsYXJhdGlvbjpcbiAgICAgICAgYWRkSW1wb3J0QWxpYXNlcyhub2RlIGFzIHRzLkltcG9ydERlY2xhcmF0aW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb246XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuRXhwb3J0QXNzaWdubWVudDpcbiAgICAgICAgLy8gSGFuZGxlZCBvbiB0aGUgZmlsZSBsZXZlbC5cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuRXhwb3J0RGVjbGFyYXRpb246XG4gICAgICAgIGNvbnN0IGV4cG9ydERlY2xhcmF0aW9uID0gbm9kZSBhcyB0cy5FeHBvcnREZWNsYXJhdGlvbjtcbiAgICAgICAgd3JpdGVFeHBvcnREZWNsYXJhdGlvbihleHBvcnREZWNsYXJhdGlvbiwgbmFtZXNwYWNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBlbWl0KGBcXG4vLyBUT0RPKHRzaWNrbGUpOiAke3RzLlN5bnRheEtpbmRbbm9kZS5raW5kXX0gaW4gJHtcbiAgICAgICAgICAgIGRlYnVnTG9jYXRpb25TdHIobm9kZSwgbmFtZXNwYWNlKX1cXG5gKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG4iXX0=