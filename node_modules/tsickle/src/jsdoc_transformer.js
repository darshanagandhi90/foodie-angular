/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/jsdoc_transformer", ["require", "exports", "typescript", "tsickle/src/annotator_host", "tsickle/src/decorators", "tsickle/src/googmodule", "tsickle/src/jsdoc", "tsickle/src/module_type_translator", "tsickle/src/transformer_util", "tsickle/src/transformer_util", "tsickle/src/type_translator"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @fileoverview jsdoc_transformer contains the logic to add JSDoc comments to TypeScript code.
     *
     * One of tsickle's features is to add Closure Compiler compatible JSDoc comments containing type
     * annotations, inheritance information, etc., onto TypeScript code. This allows Closure Compiler to
     * make better optimization decisions compared to an untyped code base.
     *
     * The entry point to the annotation operation is jsdocTransformer below. It adds synthetic comments
     * to existing TypeScript constructs, for example:
     *     const x: number = 1;
     * Might get transformed to:
     *     /.. \@type {number} ./
     *     const x: number = 1;
     * Later TypeScript phases then remove the type annotation, and the final emit is JavaScript that
     * only contains the JSDoc comment.
     *
     * To handle certain constructs, this transformer also performs AST transformations, e.g. by adding
     * CommonJS-style exports for type constructs, expanding `export *`, parenthesizing casts, etc.
     */
    const ts = require("typescript");
    const annotator_host_1 = require("tsickle/src/annotator_host");
    const decorators_1 = require("tsickle/src/decorators");
    const googmodule = require("tsickle/src/googmodule");
    const jsdoc = require("tsickle/src/jsdoc");
    const module_type_translator_1 = require("tsickle/src/module_type_translator");
    const transformerUtil = require("tsickle/src/transformer_util");
    const transformer_util_1 = require("tsickle/src/transformer_util");
    const type_translator_1 = require("tsickle/src/type_translator");
    function addCommentOn(node, tags, escapeExtraTags) {
        const comment = jsdoc.toSynthesizedComment(tags, escapeExtraTags);
        const comments = ts.getSyntheticLeadingComments(node) || [];
        comments.push(comment);
        ts.setSyntheticLeadingComments(node, comments);
        return comment;
    }
    /** Adds an \@template clause to docTags if decl has type parameters. */
    function maybeAddTemplateClause(docTags, decl) {
        if (!decl.typeParameters)
            return;
        // Closure does not support template constraints (T extends X), these are ignored below.
        docTags.push({
            tagName: 'template',
            text: decl.typeParameters.map(tp => transformerUtil.getIdentifierText(tp.name)).join(', ')
        });
    }
    exports.maybeAddTemplateClause = maybeAddTemplateClause;
    /**
     * Adds heritage clauses (\@extends, \@implements) to the given docTags for decl. Used by
     * jsdoc_transformer and externs generation.
     */
    function maybeAddHeritageClauses(docTags, mtt, decl) {
        if (!decl.heritageClauses)
            return;
        const isClass = decl.kind === ts.SyntaxKind.ClassDeclaration;
        const hasExtends = decl.heritageClauses.some(c => c.token === ts.SyntaxKind.ExtendsKeyword);
        for (const heritage of decl.heritageClauses) {
            const isExtends = heritage.token === ts.SyntaxKind.ExtendsKeyword;
            if (isClass && isExtends) {
                // If a class has an "extends", that is preserved in the ES6 output
                // and we don't need to emit any additional jsdoc.
                //
                // However for ambient declarations, we only emit externs, and in those we do need to
                // add "@extends {Foo}" as they use ES5 syntax.
                if (!transformerUtil.isAmbient(decl))
                    continue;
            }
            // Otherwise, if we get here, we need to emit some jsdoc.
            for (const expr of heritage.types) {
                addHeritage(isExtends ? 'extends' : 'implements', hasExtends, expr);
            }
        }
        /**
         * Adds the relevant Closure JSdoc tags for an expression occurring in a heritage clause,
         * e.g. "implements FooBar" => "@implements {FooBar}".
         *
         * Will return null if the expression is inexpressible in Closure semantics.
         *
         * Note that we don't need to consider all possible combinations of types/values and
         * extends/implements because our input is already verified to be valid TypeScript.  See
         * test_files/class/ for the full cartesian product of test cases.
         *
         * @param hasAnyExtends True if there are any 'extends' clauses present at all.
         */
        function addHeritage(relation, hasAnyExtends, expr) {
            let tagName = relation;
            let sym = mtt.typeChecker.getSymbolAtLocation(expr.expression);
            if (!sym) {
                // It's possible for a class declaration to extend an expression that
                // does not have have a symbol, for example when a mixin function is
                // used to build a base class, as in `declare MyClass extends
                // MyMixin(MyBaseClass)`.
                //
                // Handling this correctly is tricky. Closure throws on this
                // `extends <expression>` syntax (see
                // https://github.com/google/closure-compiler/issues/2182). We would
                // probably need to generate an intermediate class declaration and
                // extend that.
                warn(expr, `dropped ${relation} of non-symbol supertype: ${expr.getText()}`);
                return;
            }
            // Resolve any aliases to the underlying type.
            if (sym.flags & ts.SymbolFlags.TypeAlias) {
                // It's implementing a type alias.  Follow the type alias back
                // to the original symbol to check whether it's a type or a value.
                const type = mtt.typeChecker.getDeclaredTypeOfSymbol(sym);
                if (!type.symbol) {
                    // It's not clear when this can happen.
                    warn(decl, `could not get type of symbol: ${expr.getText()}`);
                    return;
                }
                sym = type.symbol;
            }
            if (sym.flags & ts.SymbolFlags.Alias) {
                sym = mtt.typeChecker.getAliasedSymbol(sym);
            }
            const typeTranslator = mtt.newTypeTranslator(expr.expression);
            if (typeTranslator.isBlackListed(sym)) {
                // Don't emit references to blacklisted types.
                warn(decl, `dropped ${relation} of blacklisted type: ${expr.getText()}`);
                return;
            }
            if (sym.flags & ts.SymbolFlags.Class) {
                if (!isClass) {
                    // Closure interfaces cannot extend or implements classes.
                    warn(decl, `dropped interface ${relation} class: ${expr.getText()}`);
                    return;
                }
                if (relation !== 'extends') {
                    if (!hasAnyExtends) {
                        // A special case: for a class that has no existing 'extends' clause but does
                        // have an 'implements' clause that refers to another class, we change it to
                        // instead be an 'extends'.  This was a poorly-thought-out hack that may
                        // actually cause compiler bugs:
                        //   https://github.com/google/closure-compiler/issues/3126
                        // but we have code that now relies on it, ugh.
                        tagName = 'extends';
                    }
                    else {
                        // Closure can only @implements an interface, not a class.
                        warn(decl, `dropped implements of class: ${expr.getText()}`);
                        return;
                    }
                }
            }
            else if (sym.flags & ts.SymbolFlags.Value) {
                // If the symbol came from tsickle emit and it's something other than a class in the value
                // namespace, then tsickle may not have emitted the type.
                // TODO(#1072): some other symbols we ought to be worrying about here:
                // - if the symbol is a TS builtin? we can emit it;
                // - if the symbol comes from a tsickle-transpiled file, either .ts or
                //   .d.ts with externs generation? then maybe we can emit it with
                //   name mangling.
                if (!type_translator_1.isClutzType(sym)) {
                    warn(decl, `dropped ${relation} of a type/value conflict: ${expr.getText()}`);
                    return;
                }
            }
            else if (sym.flags & ts.SymbolFlags.TypeLiteral) {
                // A type literal is a type like `{foo: string}`.
                // These can come up as the output of a mapped type.
                warn(decl, `dropped ${relation} of a type literal: ${expr.getText()}`);
                return;
            }
            // typeToClosure includes nullability modifiers, so call symbolToString directly here.
            const parentName = typeTranslator.symbolToString(sym);
            if (!parentName) {
                warn(decl, `dropped ${relation} of unnameable type: ${expr.getText()}`);
                return;
            }
            docTags.push({
                tagName,
                type: parentName,
            });
        }
        /** Records a warning, both in the source text and in the emit host. */
        function warn(context, message) {
            docTags.push({ tagName: '', text: `tsickle: ${message}` });
            mtt.debugWarn(context, message);
        }
    }
    exports.maybeAddHeritageClauses = maybeAddHeritageClauses;
    /**
     * createMemberTypeDeclaration emits the type annotations for members of a class. It's necessary in
     * the case where TypeScript syntax specifies there are additional properties on the class, because
     * to declare these in Closure you must declare these separately from the class.
     *
     * createMemberTypeDeclaration produces an if (false) statement containing property declarations, or
     * null if no declarations could or needed to be generated (e.g. no members, or an unnamed type).
     * The if statement is used to make sure the code is not executed, otherwise property accesses could
     * trigger getters on a superclass. See test_files/fields/fields.ts:BaseThatThrows.
     */
    function createMemberTypeDeclaration(mtt, typeDecl) {
        // Gather parameter properties from the constructor, if it exists.
        const ctors = [];
        let paramProps = [];
        const nonStaticProps = [];
        const staticProps = [];
        const unhandled = [];
        const abstractMethods = [];
        for (const member of typeDecl.members) {
            if (member.kind === ts.SyntaxKind.Constructor) {
                ctors.push(member);
            }
            else if (ts.isPropertyDeclaration(member) || ts.isPropertySignature(member)) {
                const isStatic = transformerUtil.hasModifierFlag(member, ts.ModifierFlags.Static);
                if (isStatic) {
                    staticProps.push(member);
                }
                else {
                    nonStaticProps.push(member);
                }
            }
            else if (member.kind === ts.SyntaxKind.MethodDeclaration ||
                member.kind === ts.SyntaxKind.MethodSignature ||
                member.kind === ts.SyntaxKind.GetAccessor || member.kind === ts.SyntaxKind.SetAccessor) {
                if (transformerUtil.hasModifierFlag(member, ts.ModifierFlags.Abstract) ||
                    ts.isInterfaceDeclaration(typeDecl)) {
                    abstractMethods.push(member);
                }
                // Non-abstract methods only exist on classes, and are handled in regular emit.
            }
            else {
                unhandled.push(member);
            }
        }
        if (ctors.length > 0) {
            // Only the actual constructor implementation, which must be last in a potential sequence of
            // overloaded constructors, may contain parameter properties.
            const ctor = ctors[ctors.length - 1];
            paramProps = ctor.parameters.filter(p => transformerUtil.hasModifierFlag(p, ts.ModifierFlags.ParameterPropertyModifier));
        }
        if (nonStaticProps.length === 0 && paramProps.length === 0 && staticProps.length === 0 &&
            abstractMethods.length === 0) {
            // There are no members so we don't need to emit any type
            // annotations helper.
            return null;
        }
        if (!typeDecl.name) {
            mtt.debugWarn(typeDecl, 'cannot add types on unnamed declarations');
            return null;
        }
        const className = transformerUtil.getIdentifierText(typeDecl.name);
        const staticPropAccess = ts.createIdentifier(className);
        const instancePropAccess = ts.createPropertyAccess(staticPropAccess, 'prototype');
        // Closure Compiler will report conformance errors about this being unknown type when emitting
        // class properties as {?|undefined}, instead of just {?}. So make sure to only emit {?|undefined}
        // on interfaces.
        const isInterface = ts.isInterfaceDeclaration(typeDecl);
        const propertyDecls = staticProps.map(p => createClosurePropertyDeclaration(mtt, staticPropAccess, p, isInterface && !!p.questionToken));
        propertyDecls.push(...[...nonStaticProps, ...paramProps].map(p => createClosurePropertyDeclaration(mtt, instancePropAccess, p, isInterface && !!p.questionToken)));
        propertyDecls.push(...unhandled.map(p => transformerUtil.createMultiLineComment(p, `Skipping unhandled member: ${escapeForComment(p.getText())}`)));
        for (const fnDecl of abstractMethods) {
            // If the function declaration is computed, its name is the computed expression; otherwise, its
            // name can be resolved to a string.
            const name = fnDecl.name && ts.isComputedPropertyName(fnDecl.name) ? fnDecl.name.expression :
                propertyName(fnDecl);
            if (!name) {
                mtt.error(fnDecl, 'anonymous abstract function');
                continue;
            }
            const { tags, parameterNames } = mtt.getFunctionTypeJSDoc([fnDecl], []);
            if (decorators_1.hasExportingDecorator(fnDecl, mtt.typeChecker))
                tags.push({ tagName: 'export' });
            // Use element access instead of property access for compued names.
            const lhs = typeof name === 'string' ? ts.createPropertyAccess(instancePropAccess, name) :
                ts.createElementAccess(instancePropAccess, name);
            // memberNamespace because abstract methods cannot be static in TypeScript.
            const abstractFnDecl = ts.createStatement(ts.createAssignment(lhs, ts.createFunctionExpression(
            /* modifiers */ undefined, 
            /* asterisk */ undefined, 
            /* name */ undefined, 
            /* typeParameters */ undefined, parameterNames.map(n => ts.createParameter(
            /* decorators */ undefined, /* modifiers */ undefined, 
            /* dotDotDot */ undefined, n)), undefined, ts.createBlock([]))));
            ts.setSyntheticLeadingComments(abstractFnDecl, [jsdoc.toSynthesizedComment(tags)]);
            propertyDecls.push(ts.setSourceMapRange(abstractFnDecl, fnDecl));
        }
        // See test_files/fields/fields.ts:BaseThatThrows for a note on this wrapper.
        return ts.createIf(ts.createLiteral(false), ts.createBlock(propertyDecls, true));
    }
    function propertyName(prop) {
        if (!prop.name)
            return null;
        switch (prop.name.kind) {
            case ts.SyntaxKind.Identifier:
                return transformerUtil.getIdentifierText(prop.name);
            case ts.SyntaxKind.StringLiteral:
                // E.g. interface Foo { 'bar': number; }
                // If 'bar' is a name that is not valid in Closure then there's nothing we can do.
                const text = prop.name.text;
                if (!type_translator_1.isValidClosurePropertyName(text))
                    return null;
                return text;
            default:
                return null;
        }
    }
    /** Removes comment metacharacters from a string, to make it safe to embed in a comment. */
    function escapeForComment(str) {
        return str.replace(/\/\*/g, '__').replace(/\*\//g, '__');
    }
    exports.escapeForComment = escapeForComment;
    function createClosurePropertyDeclaration(mtt, expr, prop, optional) {
        const name = propertyName(prop);
        if (!name) {
            mtt.debugWarn(prop, `handle unnamed member:\n${escapeForComment(prop.getText())}`);
            return transformerUtil.createMultiLineComment(prop, `Skipping unnamed member:\n${escapeForComment(prop.getText())}`);
        }
        if (name === 'prototype') {
            // Code that declares a property named 'prototype' typically is doing something
            // funny with the TS type system, and isn't actually interested in naming a
            // a field 'prototype', as prototype has special meaning in JS.
            return transformerUtil.createMultiLineComment(prop, `Skipping illegal member name:\n${escapeForComment(prop.getText())}`);
        }
        let type = mtt.typeToClosure(prop);
        // When a property is optional, e.g.
        //   foo?: string;
        // Then the TypeScript type of the property is string|undefined, the
        // typeToClosure translation handles it correctly, and string|undefined is
        // how you write an optional property in Closure.
        //
        // But in the special case of an optional property with type any:
        //   foo?: any;
        // The TypeScript type of the property is just "any" (because any includes
        // undefined as well) so our default translation of the type is just "?".
        // To mark the property as optional in Closure it must have "|undefined",
        // so the Closure type must be ?|undefined.
        if (optional && type === '?')
            type += '|undefined';
        const tags = mtt.getJSDoc(prop, /* reportWarnings */ true);
        tags.push({ tagName: 'type', type });
        const flags = ts.getCombinedModifierFlags(prop);
        if (flags & ts.ModifierFlags.Protected) {
            tags.push({ tagName: 'protected' });
        }
        else if (flags & ts.ModifierFlags.Private) {
            tags.push({ tagName: 'private' });
        }
        if (decorators_1.hasExportingDecorator(prop, mtt.typeChecker)) {
            tags.push({ tagName: 'export' });
        }
        const declStmt = ts.setSourceMapRange(ts.createStatement(ts.createPropertyAccess(expr, name)), prop);
        // Avoid printing annotations that can conflict with @type
        // This avoids Closure's error "type annotation incompatible with other annotations"
        addCommentOn(declStmt, tags, jsdoc.TAGS_CONFLICTING_WITH_TYPE);
        return declStmt;
    }
    /**
     * Removes any type assertions and non-null expressions from the AST before TypeScript processing.
     *
     * Ideally, the code in jsdoc_transformer below should just remove the cast expression and
     * replace it with the Closure equivalent. However Angular's compiler is fragile to AST
     * nodes being removed or changing type, so the code must retain the type assertion
     * expression, see: https://github.com/angular/angular/issues/24895.
     *
     * tsickle also cannot just generate and keep a `(/.. @type {SomeType} ./ (expr as SomeType))`
     * because TypeScript removes the parenthesized expressions in that syntax, (reasonably) believing
     * they were only added for the TS cast.
     *
     * The final workaround is then to keep the TypeScript type assertions, and have a post-Angular
     * processing step that removes the assertions before TypeScript sees them.
     *
     * TODO(martinprobst): remove once the Angular issue is fixed.
     */
    function removeTypeAssertions() {
        return (context) => {
            return (sourceFile) => {
                function visitor(node) {
                    switch (node.kind) {
                        case ts.SyntaxKind.TypeAssertionExpression:
                        case ts.SyntaxKind.AsExpression:
                            return ts.visitNode(node.expression, visitor);
                        case ts.SyntaxKind.NonNullExpression:
                            return ts.visitNode(node.expression, visitor);
                        default:
                            break;
                    }
                    return ts.visitEachChild(node, visitor, context);
                }
                return visitor(sourceFile);
            };
        };
    }
    exports.removeTypeAssertions = removeTypeAssertions;
    /**
     * Returns true if node lexically (recursively) contains an 'async' function.
     */
    function containsAsync(node) {
        if (ts.isFunctionLike(node) && transformerUtil.hasModifierFlag(node, ts.ModifierFlags.Async)) {
            return true;
        }
        return ts.forEachChild(node, containsAsync) || false;
    }
    /**
     * jsdocTransformer returns a transformer factory that converts TypeScript types into the equivalent
     * JSDoc annotations.
     */
    function jsdocTransformer(host, tsOptions, typeChecker, diagnostics) {
        return (context) => {
            return (sourceFile) => {
                const moduleTypeTranslator = new module_type_translator_1.ModuleTypeTranslator(sourceFile, typeChecker, host, diagnostics, /*isForExterns*/ false);
                /**
                 * The set of all names exported from an export * in the current module. Used to prevent
                 * emitting duplicated exports. The first export * takes precedence in ES6.
                 */
                const expandedStarImports = new Set();
                /**
                 * While Closure compiler supports parameterized types, including parameterized `this` on
                 * methods, it does not support constraints on them. That means that an `\@template`d type is
                 * always considered to be `unknown` within the method, including `THIS`.
                 *
                 * To help Closure Compiler, we keep track of any templated this return type, and substitute
                 * explicit casts to the templated type.
                 *
                 * This is an incomplete solution and works around a specific problem with warnings on unknown
                 * this accesses. More generally, Closure also cannot infer constraints for any other
                 * templated types, but that might require a more general solution in Closure Compiler.
                 */
                let contextThisType = null;
                function visitClassDeclaration(classDecl) {
                    const contextThisTypeBackup = contextThisType;
                    const mjsdoc = moduleTypeTranslator.getMutableJSDoc(classDecl);
                    if (transformerUtil.hasModifierFlag(classDecl, ts.ModifierFlags.Abstract)) {
                        mjsdoc.tags.push({ tagName: 'abstract' });
                    }
                    maybeAddTemplateClause(mjsdoc.tags, classDecl);
                    if (!host.untyped) {
                        maybeAddHeritageClauses(mjsdoc.tags, moduleTypeTranslator, classDecl);
                    }
                    mjsdoc.updateComment();
                    const decls = [];
                    const memberDecl = createMemberTypeDeclaration(moduleTypeTranslator, classDecl);
                    // WARNING: order is significant; we must create the member decl before transforming away
                    // parameter property comments when visiting the constructor.
                    decls.push(ts.visitEachChild(classDecl, visitor, context));
                    if (memberDecl)
                        decls.push(memberDecl);
                    contextThisType = contextThisTypeBackup;
                    return decls;
                }
                /**
                 * visitHeritageClause works around a Closure Compiler issue, where the expression in an
                 * "extends" clause must be a simple identifier, and in particular must not be a parenthesized
                 * expression.
                 *
                 * This is triggered when TS code writes "class X extends (Foo as Bar) { ... }", commonly done
                 * to support mixins. For extends clauses in classes, the code below drops the cast and any
                 * parentheticals, leaving just the original expression.
                 *
                 * This is an incomplete workaround, as Closure will still bail on other super expressions,
                 * but retains compatibility with the previous emit that (accidentally) dropped the cast
                 * expression.
                 *
                 * TODO(martinprobst): remove this once the Closure side issue has been resolved.
                 */
                function visitHeritageClause(heritageClause) {
                    if (heritageClause.token !== ts.SyntaxKind.ExtendsKeyword || !heritageClause.parent ||
                        heritageClause.parent.kind === ts.SyntaxKind.InterfaceDeclaration) {
                        return ts.visitEachChild(heritageClause, visitor, context);
                    }
                    if (heritageClause.types.length !== 1) {
                        moduleTypeTranslator.error(heritageClause, `expected exactly one type in class extension clause`);
                    }
                    const type = heritageClause.types[0];
                    let expr = type.expression;
                    while (ts.isParenthesizedExpression(expr) || ts.isNonNullExpression(expr) ||
                        ts.isAssertionExpression(expr)) {
                        expr = expr.expression;
                    }
                    return ts.updateHeritageClause(heritageClause, [ts.updateExpressionWithTypeArguments(type, type.typeArguments || [], expr)]);
                }
                function visitInterfaceDeclaration(iface) {
                    const sym = typeChecker.getSymbolAtLocation(iface.name);
                    if (!sym) {
                        moduleTypeTranslator.error(iface, 'interface with no symbol');
                        return [];
                    }
                    // If this symbol is both a type and a value, we cannot emit both into Closure's
                    // single namespace.
                    if (transformer_util_1.symbolIsValue(typeChecker, sym)) {
                        moduleTypeTranslator.debugWarn(iface, `type/symbol conflict for ${sym.name}, using {?} for now`);
                        return [transformerUtil.createSingleLineComment(iface, 'WARNING: interface has both a type and a value, skipping emit')];
                    }
                    const tags = moduleTypeTranslator.getJSDoc(iface, /* reportWarnings */ true) || [];
                    tags.push({ tagName: 'record' });
                    maybeAddTemplateClause(tags, iface);
                    if (!host.untyped) {
                        maybeAddHeritageClauses(tags, moduleTypeTranslator, iface);
                    }
                    const name = transformerUtil.getIdentifierText(iface.name);
                    const modifiers = transformerUtil.hasModifierFlag(iface, ts.ModifierFlags.Export) ?
                        [ts.createToken(ts.SyntaxKind.ExportKeyword)] :
                        undefined;
                    const decl = ts.setSourceMapRange(ts.createFunctionDeclaration(
                    /* decorators */ undefined, modifiers, 
                    /* asterisk */ undefined, name, 
                    /* typeParameters */ undefined, 
                    /* parameters */ [], 
                    /* type */ undefined, 
                    /* body */ ts.createBlock([])), iface);
                    addCommentOn(decl, tags);
                    const memberDecl = createMemberTypeDeclaration(moduleTypeTranslator, iface);
                    return memberDecl ? [decl, memberDecl] : [decl];
                }
                /** Returns the `this` type in this context, or undefined if none. */
                function getContextThisType(node) {
                    while (node) {
                        if (ts.isClassDeclaration(node) && node.name) {
                            return typeChecker.getTypeAtLocation(node.name);
                        }
                        if (ts.isFunctionDeclaration(node) && node.parameters.length > 0) {
                            const firstParam = node.parameters[0];
                            // ts.Signature does not expose a `this` type, so comparing identifier names to 'this'
                            // is the only way to find a this type declaration.
                            if (ts.isIdentifier(firstParam.name) &&
                                transformerUtil.getIdentifierText(firstParam.name) === 'this' && firstParam.type) {
                                return typeChecker.getTypeAtLocation(firstParam.type);
                            }
                        }
                        node = node.parent;
                    }
                    return undefined;
                }
                /** Function declarations are emitted as they are, with only JSDoc added. */
                function visitFunctionLikeDeclaration(fnDecl) {
                    if (!fnDecl.body) {
                        // Two cases: abstract methods and overloaded methods/functions.
                        // Abstract methods are handled in emitTypeAnnotationsHandler.
                        // Overloads are union-ized into the shared type in FunctionType.
                        return ts.visitEachChild(fnDecl, visitor, context);
                    }
                    const extraTags = [];
                    if (decorators_1.hasExportingDecorator(fnDecl, typeChecker))
                        extraTags.push({ tagName: 'export' });
                    const { tags, thisReturnType } = moduleTypeTranslator.getFunctionTypeJSDoc([fnDecl], extraTags);
                    // async functions when down-leveled access `this` to pass it to
                    // tslib.__awaiter.  Closure wants to know the type of 'this' for that.
                    // The type is known in many contexts (e.g. methods, arrow functions)
                    // per the normal rules (e.g. looking at parent nodes and @this tags)
                    // but if the search bottoms out at a function scope, then Closure
                    // warns that 'this' is unknown.
                    // Because we have already checked the type of 'this', we are ok to just
                    // suppress in that case.  We do so by stuffing a @this on any function
                    // where it might be needed; it's harmless to overapproximate.
                    const isDownlevellingAsync = tsOptions.target !== undefined && tsOptions.target <= ts.ScriptTarget.ES2015;
                    const isFunction = fnDecl.kind === ts.SyntaxKind.FunctionDeclaration;
                    const hasExistingThisTag = tags.some(t => t.tagName === 'this');
                    if (isDownlevellingAsync && isFunction && !hasExistingThisTag && containsAsync(fnDecl)) {
                        tags.push({ tagName: 'this', type: '*' });
                    }
                    const mjsdoc = moduleTypeTranslator.getMutableJSDoc(fnDecl);
                    mjsdoc.tags = tags;
                    mjsdoc.updateComment();
                    const contextThisTypeBackup = contextThisType;
                    // Arrow functions retain their context `this` type. All others reset the this type to
                    // either none (if not specified) or the type given in a fn(this: T, ...) declaration.
                    if (!ts.isArrowFunction(fnDecl))
                        contextThisType = thisReturnType;
                    const result = ts.visitEachChild(fnDecl, visitor, context);
                    contextThisType = contextThisTypeBackup;
                    return result;
                }
                /**
                 * In methods with a templated this type, adds explicit casts to accesses on this.
                 *
                 * @see contextThisType
                 */
                function visitThisExpression(node) {
                    if (!contextThisType)
                        return ts.visitEachChild(node, visitor, context);
                    return createClosureCast(node, node, contextThisType);
                }
                /**
                 * visitVariableStatement flattens variable declaration lists (`var a, b;` to `var a; var
                 * b;`), and attaches JSDoc comments to each variable. JSDoc comments preceding the
                 * original variable are attached to the first newly created one.
                 */
                function visitVariableStatement(varStmt) {
                    const stmts = [];
                    // "const", "let", etc are stored in node flags on the declarationList.
                    const flags = ts.getCombinedNodeFlags(varStmt.declarationList);
                    let tags = moduleTypeTranslator.getJSDoc(varStmt, /* reportWarnings */ true);
                    const leading = ts.getSyntheticLeadingComments(varStmt);
                    if (leading) {
                        // Attach non-JSDoc comments to a not emitted statement.
                        const commentHolder = ts.createNotEmittedStatement(varStmt);
                        ts.setSyntheticLeadingComments(commentHolder, leading.filter(c => c.text[0] !== '*'));
                        stmts.push(commentHolder);
                    }
                    for (const decl of varStmt.declarationList.declarations) {
                        const localTags = [];
                        if (tags) {
                            // Add any tags and docs preceding the entire statement to the first variable.
                            localTags.push(...tags);
                            tags = null;
                        }
                        // Add an @type for plain identifiers, but not for bindings patterns (i.e. object or array
                        // destructuring - those do not have a syntax in Closure) or @defines, which already
                        // declare their type.
                        if (ts.isIdentifier(decl.name)) {
                            // For variables that are initialized and use a blacklisted type, do not emit a type at
                            // all. Closure Compiler might be able to infer a better type from the initializer than
                            // the `?` the code below would emit.
                            // TODO(martinprobst): consider doing this for all types that get emitted as ?, not just
                            // for blacklisted ones.
                            const blackListedInitialized = !!decl.initializer && moduleTypeTranslator.isBlackListed(decl);
                            if (!blackListedInitialized) {
                                // getOriginalNode(decl) is required because the type checker cannot type check
                                // synthesized nodes.
                                const typeStr = moduleTypeTranslator.typeToClosure(ts.getOriginalNode(decl));
                                // If @define is present then add the type to it, rather than adding a normal @type.
                                const defineTag = localTags.find(({ tagName }) => tagName === 'define');
                                if (defineTag) {
                                    defineTag.type = typeStr;
                                }
                                else {
                                    localTags.push({ tagName: 'type', type: typeStr });
                                }
                            }
                        }
                        const newDecl = ts.visitNode(decl, visitor);
                        const newStmt = ts.createVariableStatement(varStmt.modifiers, ts.createVariableDeclarationList([newDecl], flags));
                        if (localTags.length)
                            addCommentOn(newStmt, localTags, jsdoc.TAGS_CONFLICTING_WITH_TYPE);
                        stmts.push(newStmt);
                    }
                    return stmts;
                }
                /**
                 * shouldEmitExportsAssignments returns true if tsickle should emit `exports.Foo = ...` style
                 * export statements.
                 *
                 * TypeScript modules can export types. Because types are pure design-time constructs in
                 * TypeScript, it does not emit any actual exported symbols for these. But tsickle has to emit
                 * an export, so that downstream Closure code (including tsickle-converted Closure code) can
                 * import upstream types. tsickle has to pick a module format for that, because the pure ES6
                 * export would get stripped by TypeScript.
                 *
                 * tsickle uses CommonJS to emit googmodule, and code not using googmodule doesn't care about
                 * the Closure annotations anyway, so tsickle skips emitting exports if the module target
                 * isn't commonjs.
                 */
                function shouldEmitExportsAssignments() {
                    return tsOptions.module === ts.ModuleKind.CommonJS;
                }
                function visitTypeAliasDeclaration(typeAlias) {
                    const sym = moduleTypeTranslator.mustGetSymbolAtLocation(typeAlias.name);
                    // If the type is also defined as a value, skip emitting it. Closure collapses type & value
                    // namespaces, the two emits would conflict if tsickle emitted both.
                    if (transformer_util_1.symbolIsValue(typeChecker, sym))
                        return [];
                    if (!shouldEmitExportsAssignments())
                        return [];
                    const typeName = typeAlias.name.getText();
                    // Blacklist any type parameters, Closure does not support type aliases with type
                    // parameters.
                    moduleTypeTranslator.newTypeTranslator(typeAlias).blacklistTypeParameters(moduleTypeTranslator.symbolsToAliasedNames, typeAlias.typeParameters);
                    const typeStr = host.untyped ? '?' : moduleTypeTranslator.typeToClosure(typeAlias, undefined);
                    // We want to emit a @typedef.  They are a bit weird because they are 'var' statements
                    // that have no value.
                    const tags = moduleTypeTranslator.getJSDoc(typeAlias, /* reportWarnings */ true);
                    tags.push({ tagName: 'typedef', type: typeStr });
                    const isExported = transformerUtil.hasModifierFlag(typeAlias, ts.ModifierFlags.Export);
                    let decl;
                    if (isExported) {
                        // Given: export type T = ...;
                        // We cannot emit `export var foo;` and let TS generate from there because TypeScript
                        // drops exports that are never assigned values, and Closure requires us to not assign
                        // values to typedef exports. Introducing a new local variable and exporting it can cause
                        // bugs due to name shadowing and confusing TypeScript's logic on what symbols and types
                        // vs values are exported. Mangling the name to avoid the conflicts would be reasonably
                        // clean, but would require a two pass emit to first find all type alias names, mangle
                        // them, and emit the use sites only later.
                        // So we produce: exports.T;
                        decl = ts.createStatement(ts.createPropertyAccess(ts.createIdentifier('exports'), ts.createIdentifier(typeName)));
                    }
                    else {
                        // Given: type T = ...;
                        // We produce: var T;
                        // Note: not const, because 'const Foo;' is illegal;
                        // not let, because we want hoisting behavior for types.
                        decl = ts.createVariableStatement(
                        /* modifiers */ undefined, ts.createVariableDeclarationList([ts.createVariableDeclaration(ts.createIdentifier(typeName))]));
                    }
                    decl = ts.setSourceMapRange(decl, typeAlias);
                    addCommentOn(decl, tags, jsdoc.TAGS_CONFLICTING_WITH_TYPE);
                    return [decl];
                }
                /** Emits a parenthesized Closure cast: `(/** \@type ... * / (expr))`. */
                function createClosureCast(context, expression, type) {
                    const inner = ts.createParen(expression);
                    const comment = addCommentOn(inner, [{ tagName: 'type', type: moduleTypeTranslator.typeToClosure(context, type) }]);
                    comment.hasTrailingNewLine = false;
                    return ts.setSourceMapRange(ts.createParen(inner), context);
                }
                /** Converts a TypeScript type assertion into a Closure Cast. */
                function visitAssertionExpression(assertion) {
                    const type = typeChecker.getTypeAtLocation(assertion.type);
                    return createClosureCast(assertion, ts.visitEachChild(assertion, visitor, context), type);
                }
                /**
                 * Converts a TypeScript non-null assertion into a Closure Cast, by stripping |null and
                 * |undefined from a union type.
                 */
                function visitNonNullExpression(nonNull) {
                    const type = typeChecker.getTypeAtLocation(nonNull.expression);
                    const nonNullType = typeChecker.getNonNullableType(type);
                    return createClosureCast(nonNull, ts.visitEachChild(nonNull, visitor, context), nonNullType);
                }
                function visitImportDeclaration(importDecl) {
                    // For each import, insert a goog.requireType for the module, so that if TypeScript does not
                    // emit the module because it's only used in type positions, the JSDoc comments still
                    // reference a valid Closure level symbol.
                    // No need to requireType side effect imports.
                    if (!importDecl.importClause)
                        return importDecl;
                    const sym = typeChecker.getSymbolAtLocation(importDecl.moduleSpecifier);
                    // Scripts do not have a symbol, and neither do unused modules. Scripts can still be
                    // imported, either as side effect imports or with an empty import set ("{}"). TypeScript
                    // does not emit a runtime load for an import with an empty list of symbols, but the import
                    // forces any global declarations from the library to be visible, which is what users use
                    // this for. No symbols from the script need requireType, so just return.
                    // TODO(evmar): revisit this.  If TS needs to see the module import, it's likely Closure
                    // does too.
                    if (!sym)
                        return importDecl;
                    const importPath = googmodule.resolveModuleName({ options: tsOptions, moduleResolutionHost: host.moduleResolutionHost }, sourceFile.fileName, importDecl.moduleSpecifier.text);
                    moduleTypeTranslator.requireType(importPath, sym, 
                    /* default import? */ !!importDecl.importClause.name);
                    return importDecl;
                }
                /**
                 * Closure Compiler will fail when it finds incorrect JSDoc tags on nodes. This function
                 * parses and then re-serializes JSDoc comments, escaping or removing illegal tags.
                 */
                function escapeIllegalJSDoc(node) {
                    const mjsdoc = moduleTypeTranslator.getMutableJSDoc(node);
                    mjsdoc.updateComment();
                }
                /** Returns true if a value export should be emitted for the given symbol in export *. */
                function shouldEmitValueExportForSymbol(sym) {
                    if (sym.flags & ts.SymbolFlags.Alias) {
                        sym = typeChecker.getAliasedSymbol(sym);
                    }
                    if ((sym.flags & ts.SymbolFlags.Value) === 0) {
                        // Note: We create explicit exports of type symbols for closure in visitExportDeclaration.
                        return false;
                    }
                    if (!tsOptions.preserveConstEnums && sym.flags & ts.SymbolFlags.ConstEnum) {
                        return false;
                    }
                    return true;
                }
                /**
                 * visitExportDeclaration requireTypes exported modules and emits explicit exports for
                 * types (which normally do not get emitted by TypeScript).
                 */
                function visitExportDeclaration(exportDecl) {
                    const importedModuleSymbol = exportDecl.moduleSpecifier &&
                        typeChecker.getSymbolAtLocation(exportDecl.moduleSpecifier);
                    if (importedModuleSymbol) {
                        // requireType all explicitly imported modules, so that symbols can be referenced and
                        // type only modules are usable from type declarations.
                        moduleTypeTranslator.requireType(exportDecl.moduleSpecifier.text, importedModuleSymbol, 
                        /* default import? */ false);
                    }
                    const typesToExport = [];
                    if (!exportDecl.exportClause) {
                        // export * from '...'
                        // Resolve the * into all value symbols exported, and update the export declaration.
                        // Explicitly spelled out exports (i.e. the exports of the current module) take precedence
                        // over implicit ones from export *. Use the current module's exports to filter.
                        const currentModuleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
                        const currentModuleExports = currentModuleSymbol && currentModuleSymbol.exports;
                        if (!importedModuleSymbol) {
                            moduleTypeTranslator.error(exportDecl, `export * without module symbol`);
                            return exportDecl;
                        }
                        const exportedSymbols = typeChecker.getExportsOfModule(importedModuleSymbol);
                        const exportSpecifiers = [];
                        for (const sym of exportedSymbols) {
                            if (currentModuleExports && currentModuleExports.has(sym.escapedName))
                                continue;
                            // We might have already generated an export for the given symbol.
                            if (expandedStarImports.has(sym.name))
                                continue;
                            expandedStarImports.add(sym.name);
                            // Only create an export specifier for values that are exported. For types, the code
                            // below creates specific export statements that match Closure's expectations.
                            if (shouldEmitValueExportForSymbol(sym)) {
                                exportSpecifiers.push(ts.createExportSpecifier(undefined, sym.name));
                            }
                            else {
                                typesToExport.push([sym.name, sym]);
                            }
                        }
                        exportDecl = ts.updateExportDeclaration(exportDecl, exportDecl.decorators, exportDecl.modifiers, ts.createNamedExports(exportSpecifiers), exportDecl.moduleSpecifier);
                    }
                    else {
                        for (const exp of exportDecl.exportClause.elements) {
                            const exportedName = transformerUtil.getIdentifierText(exp.name);
                            typesToExport.push([exportedName, moduleTypeTranslator.mustGetSymbolAtLocation(exp.name)]);
                        }
                    }
                    // Do not emit typedef re-exports in untyped mode.
                    if (host.untyped)
                        return exportDecl;
                    const result = [exportDecl];
                    for (const [exportedName, sym] of typesToExport) {
                        let aliasedSymbol = sym;
                        if (sym.flags & ts.SymbolFlags.Alias) {
                            aliasedSymbol = typeChecker.getAliasedSymbol(sym);
                        }
                        const isTypeAlias = (aliasedSymbol.flags & ts.SymbolFlags.Value) === 0 &&
                            (aliasedSymbol.flags & (ts.SymbolFlags.TypeAlias | ts.SymbolFlags.Interface)) !== 0;
                        if (!isTypeAlias)
                            continue;
                        const typeName = moduleTypeTranslator.symbolsToAliasedNames.get(aliasedSymbol) || aliasedSymbol.name;
                        const stmt = ts.createStatement(ts.createPropertyAccess(ts.createIdentifier('exports'), exportedName));
                        addCommentOn(stmt, [{ tagName: 'typedef', type: '!' + typeName }]);
                        ts.addSyntheticTrailingComment(stmt, ts.SyntaxKind.SingleLineCommentTrivia, ' re-export typedef', true);
                        result.push(stmt);
                    }
                    return result;
                }
                /**
                 * Returns the identifiers exported in a single exported statement - typically just one
                 * identifier (e.g. for `export function foo()`), but multiple for `export declare var a, b`.
                 */
                function getExportDeclarationNames(node) {
                    switch (node.kind) {
                        case ts.SyntaxKind.VariableStatement:
                            const varDecl = node;
                            return varDecl.declarationList.declarations.map((d) => getExportDeclarationNames(d)[0]);
                        case ts.SyntaxKind.VariableDeclaration:
                        case ts.SyntaxKind.FunctionDeclaration:
                        case ts.SyntaxKind.InterfaceDeclaration:
                        case ts.SyntaxKind.ClassDeclaration:
                        case ts.SyntaxKind.ModuleDeclaration:
                        case ts.SyntaxKind.EnumDeclaration:
                            const decl = node;
                            if (!decl.name || decl.name.kind !== ts.SyntaxKind.Identifier) {
                                break;
                            }
                            return [decl.name];
                        case ts.SyntaxKind.TypeAliasDeclaration:
                            const typeAlias = node;
                            return [typeAlias.name];
                        default:
                            break;
                    }
                    moduleTypeTranslator.error(node, `unsupported export declaration ${ts.SyntaxKind[node.kind]}: ${node.getText()}`);
                    return [];
                }
                /**
                 * Ambient declarations declare types for TypeScript's benefit, and will be removed by
                 * TypeScript during its emit phase. Downstream Closure code however might be importing
                 * symbols from this module, so tsickle must emit a Closure-compatible exports declaration.
                 */
                function visitExportedAmbient(node) {
                    if (host.untyped || !shouldEmitExportsAssignments())
                        return [node];
                    const declNames = getExportDeclarationNames(node);
                    const result = [node];
                    for (const decl of declNames) {
                        const sym = typeChecker.getSymbolAtLocation(decl);
                        // Non-value objects do not exist at runtime, so we cannot access the symbol (it only
                        // exists in externs). Export them as a typedef, which forwards to the type in externs.
                        // Note: TypeScript emits odd code for exported ambients (exports.x for variables, just x
                        // for everything else). That seems buggy, and in either case this code should not attempt
                        // to fix it.
                        // See also https://github.com/Microsoft/TypeScript/issues/8015.
                        if (!transformer_util_1.symbolIsValue(typeChecker, sym)) {
                            // Do not emit re-exports for ModuleDeclarations.
                            // Ambient ModuleDeclarations are always referenced as global symbols, so they don't
                            // need to be exported.
                            if (node.kind === ts.SyntaxKind.ModuleDeclaration)
                                continue;
                            const mangledName = annotator_host_1.moduleNameAsIdentifier(host, sourceFile.fileName);
                            const declName = transformerUtil.getIdentifierText(decl);
                            const stmt = ts.createStatement(ts.createPropertyAccess(ts.createIdentifier('exports'), declName));
                            addCommentOn(stmt, [{ tagName: 'typedef', type: `!${mangledName}.${declName}` }]);
                            result.push(stmt);
                        }
                    }
                    return result;
                }
                function visitor(node) {
                    if (transformerUtil.isAmbient(node)) {
                        if (!transformerUtil.hasModifierFlag(node, ts.ModifierFlags.Export)) {
                            return node;
                        }
                        return visitExportedAmbient(node);
                    }
                    switch (node.kind) {
                        case ts.SyntaxKind.ImportDeclaration:
                            return visitImportDeclaration(node);
                        case ts.SyntaxKind.ExportDeclaration:
                            return visitExportDeclaration(node);
                        case ts.SyntaxKind.ClassDeclaration:
                            return visitClassDeclaration(node);
                        case ts.SyntaxKind.InterfaceDeclaration:
                            return visitInterfaceDeclaration(node);
                        case ts.SyntaxKind.HeritageClause:
                            return visitHeritageClause(node);
                        case ts.SyntaxKind.ArrowFunction:
                        case ts.SyntaxKind.FunctionExpression:
                            // Inserting a comment before an expression can trigger automatic semicolon insertion,
                            // e.g. if the function below is the expression in a `return` statement. Parenthesizing
                            // prevents ASI, as long as the opening paren remains on the same line (which it does).
                            return ts.createParen(visitFunctionLikeDeclaration(node));
                        case ts.SyntaxKind.Constructor:
                        case ts.SyntaxKind.FunctionDeclaration:
                        case ts.SyntaxKind.MethodDeclaration:
                        case ts.SyntaxKind.GetAccessor:
                        case ts.SyntaxKind.SetAccessor:
                            return visitFunctionLikeDeclaration(node);
                        case ts.SyntaxKind.ThisKeyword:
                            return visitThisExpression(node);
                        case ts.SyntaxKind.VariableStatement:
                            return visitVariableStatement(node);
                        case ts.SyntaxKind.PropertyDeclaration:
                        case ts.SyntaxKind.PropertyAssignment:
                            escapeIllegalJSDoc(node);
                            break;
                        case ts.SyntaxKind.Parameter:
                            // Parameter properties (e.g. `constructor(/** docs */ private foo: string)`) might have
                            // JSDoc comments, including JSDoc tags recognized by Closure Compiler. Prevent emitting
                            // any comments on them, so that Closure doesn't error on them.
                            // See test_files/parameter_properties.ts.
                            const paramDecl = node;
                            if (transformerUtil.hasModifierFlag(paramDecl, ts.ModifierFlags.ParameterPropertyModifier)) {
                                ts.setSyntheticLeadingComments(paramDecl, []);
                                jsdoc.suppressLeadingCommentsRecursively(paramDecl);
                            }
                            break;
                        case ts.SyntaxKind.TypeAliasDeclaration:
                            return visitTypeAliasDeclaration(node);
                        case ts.SyntaxKind.AsExpression:
                        case ts.SyntaxKind.TypeAssertionExpression:
                            return visitAssertionExpression(node);
                        case ts.SyntaxKind.NonNullExpression:
                            return visitNonNullExpression(node);
                        default:
                            break;
                    }
                    return ts.visitEachChild(node, visitor, context);
                }
                sourceFile = ts.visitEachChild(sourceFile, visitor, context);
                return moduleTypeTranslator.insertAdditionalImports(sourceFile);
            };
        };
    }
    exports.jsdocTransformer = jsdocTransformer;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianNkb2NfdHJhbnNmb3JtZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvanNkb2NfdHJhbnNmb3JtZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HOzs7Ozs7Ozs7Ozs7SUFFSDs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Ba0JHO0lBRUgsaUNBQWlDO0lBRWpDLCtEQUF1RTtJQUN2RSx1REFBbUQ7SUFDbkQscURBQTJDO0lBQzNDLDJDQUFpQztJQUNqQywrRUFBOEQ7SUFDOUQsZ0VBQXNEO0lBQ3RELG1FQUFpRDtJQUNqRCxpRUFBMEU7SUFFMUUsU0FBUyxZQUFZLENBQUMsSUFBYSxFQUFFLElBQWlCLEVBQUUsZUFBNkI7UUFDbkYsTUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLG9CQUFvQixDQUFDLElBQUksRUFBRSxlQUFlLENBQUMsQ0FBQztRQUNsRSxNQUFNLFFBQVEsR0FBRyxFQUFFLENBQUMsMkJBQTJCLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQzVELFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDdkIsRUFBRSxDQUFDLDJCQUEyQixDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztRQUMvQyxPQUFPLE9BQU8sQ0FBQztJQUNqQixDQUFDO0lBS0Qsd0VBQXdFO0lBQ3hFLFNBQWdCLHNCQUFzQixDQUFDLE9BQW9CLEVBQUUsSUFBdUI7UUFDbEYsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjO1lBQUUsT0FBTztRQUNqQyx3RkFBd0Y7UUFDeEYsT0FBTyxDQUFDLElBQUksQ0FBQztZQUNYLE9BQU8sRUFBRSxVQUFVO1lBQ25CLElBQUksRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLGVBQWUsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxD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O0lBQ0osQ0FBQztJQTNtQkQsNENBMm1CQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGpzZG9jX3RyYW5zZm9ybWVyIGNvbnRhaW5zIHRoZSBsb2dpYyB0byBhZGQgSlNEb2MgY29tbWVudHMgdG8gVHlwZVNjcmlwdCBjb2RlLlxuICpcbiAqIE9uZSBvZiB0c2lja2xlJ3MgZmVhdHVyZXMgaXMgdG8gYWRkIENsb3N1cmUgQ29tcGlsZXIgY29tcGF0aWJsZSBKU0RvYyBjb21tZW50cyBjb250YWluaW5nIHR5cGVcbiAqIGFubm90YXRpb25zLCBpbmhlcml0YW5jZSBpbmZvcm1hdGlvbiwgZXRjLiwgb250byBUeXBlU2NyaXB0IGNvZGUuIFRoaXMgYWxsb3dzIENsb3N1cmUgQ29tcGlsZXIgdG9cbiAqIG1ha2UgYmV0dGVyIG9wdGltaXphdGlvbiBkZWNpc2lvbnMgY29tcGFyZWQgdG8gYW4gdW50eXBlZCBjb2RlIGJhc2UuXG4gKlxuICogVGhlIGVudHJ5IHBvaW50IHRvIHRoZSBhbm5vdGF0aW9uIG9wZXJhdGlvbiBpcyBqc2RvY1RyYW5zZm9ybWVyIGJlbG93LiBJdCBhZGRzIHN5bnRoZXRpYyBjb21tZW50c1xuICogdG8gZXhpc3RpbmcgVHlwZVNjcmlwdCBjb25zdHJ1Y3RzLCBmb3IgZXhhbXBsZTpcbiAqICAgICBjb25zdCB4OiBudW1iZXIgPSAxO1xuICogTWlnaHQgZ2V0IHRyYW5zZm9ybWVkIHRvOlxuICogICAgIC8uLiBcXEB0eXBlIHtudW1iZXJ9IC4vXG4gKiAgICAgY29uc3QgeDogbnVtYmVyID0gMTtcbiAqIExhdGVyIFR5cGVTY3JpcHQgcGhhc2VzIHRoZW4gcmVtb3ZlIHRoZSB0eXBlIGFubm90YXRpb24sIGFuZCB0aGUgZmluYWwgZW1pdCBpcyBKYXZhU2NyaXB0IHRoYXRcbiAqIG9ubHkgY29udGFpbnMgdGhlIEpTRG9jIGNvbW1lbnQuXG4gKlxuICogVG8gaGFuZGxlIGNlcnRhaW4gY29uc3RydWN0cywgdGhpcyB0cmFuc2Zvcm1lciBhbHNvIHBlcmZvcm1zIEFTVCB0cmFuc2Zvcm1hdGlvbnMsIGUuZy4gYnkgYWRkaW5nXG4gKiBDb21tb25KUy1zdHlsZSBleHBvcnRzIGZvciB0eXBlIGNvbnN0cnVjdHMsIGV4cGFuZGluZyBgZXhwb3J0ICpgLCBwYXJlbnRoZXNpemluZyBjYXN0cywgZXRjLlxuICovXG5cbmltcG9ydCAqIGFzIHRzIGZyb20gJ3R5cGVzY3JpcHQnO1xuXG5pbXBvcnQge0Fubm90YXRvckhvc3QsIG1vZHVsZU5hbWVBc0lkZW50aWZpZXJ9IGZyb20gJy4vYW5ub3RhdG9yX2hvc3QnO1xuaW1wb3J0IHtoYXNFeHBvcnRpbmdEZWNvcmF0b3J9IGZyb20gJy4vZGVjb3JhdG9ycyc7XG5pbXBvcnQgKiBhcyBnb29nbW9kdWxlIGZyb20gJy4vZ29vZ21vZHVsZSc7XG5pbXBvcnQgKiBhcyBqc2RvYyBmcm9tICcuL2pzZG9jJztcbmltcG9ydCB7TW9kdWxlVHlwZVRyYW5zbGF0b3J9IGZyb20gJy4vbW9kdWxlX3R5cGVfdHJhbnNsYXRvcic7XG5pbXBvcnQgKiBhcyB0cmFuc2Zvcm1lclV0aWwgZnJvbSAnLi90cmFuc2Zvcm1lcl91dGlsJztcbmltcG9ydCB7c3ltYm9sSXNWYWx1ZX0gZnJvbSAnLi90cmFuc2Zvcm1lcl91dGlsJztcbmltcG9ydCB7aXNDbHV0elR5cGUsIGlzVmFsaWRDbG9zdXJlUHJvcGVydHlOYW1lfSBmcm9tICcuL3R5cGVfdHJhbnNsYXRvcic7XG5cbmZ1bmN0aW9uIGFkZENvbW1lbnRPbihub2RlOiB0cy5Ob2RlLCB0YWdzOiBqc2RvYy5UYWdbXSwgZXNjYXBlRXh0cmFUYWdzPzogU2V0PHN0cmluZz4pIHtcbiAgY29uc3QgY29tbWVudCA9IGpzZG9jLnRvU3ludGhlc2l6ZWRDb21tZW50KHRhZ3MsIGVzY2FwZUV4dHJhVGFncyk7XG4gIGNvbnN0IGNvbW1lbnRzID0gdHMuZ2V0U3ludGhldGljTGVhZGluZ0NvbW1lbnRzKG5vZGUpIHx8IFtdO1xuICBjb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICB0cy5zZXRTeW50aGV0aWNMZWFkaW5nQ29tbWVudHMobm9kZSwgY29tbWVudHMpO1xuICByZXR1cm4gY29tbWVudDtcbn1cblxudHlwZSBIYXNUeXBlUGFyYW1ldGVycyA9XG4gICAgdHMuSW50ZXJmYWNlRGVjbGFyYXRpb258dHMuQ2xhc3NMaWtlRGVjbGFyYXRpb258dHMuVHlwZUFsaWFzRGVjbGFyYXRpb258dHMuU2lnbmF0dXJlRGVjbGFyYXRpb247XG5cbi8qKiBBZGRzIGFuIFxcQHRlbXBsYXRlIGNsYXVzZSB0byBkb2NUYWdzIGlmIGRlY2wgaGFzIHR5cGUgcGFyYW1ldGVycy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXliZUFkZFRlbXBsYXRlQ2xhdXNlKGRvY1RhZ3M6IGpzZG9jLlRhZ1tdLCBkZWNsOiBIYXNUeXBlUGFyYW1ldGVycykge1xuICBpZiAoIWRlY2wudHlwZVBhcmFtZXRlcnMpIHJldHVybjtcbiAgLy8gQ2xvc3VyZSBkb2VzIG5vdCBzdXBwb3J0IHRlbXBsYXRlIGNvbnN0cmFpbnRzIChUIGV4dGVuZHMgWCksIHRoZXNlIGFyZSBpZ25vcmVkIGJlbG93LlxuICBkb2NUYWdzLnB1c2goe1xuICAgIHRhZ05hbWU6ICd0ZW1wbGF0ZScsXG4gICAgdGV4dDogZGVjbC50eXBlUGFyYW1ldGVycy5tYXAodHAgPT4gdHJhbnNmb3JtZXJVdGlsLmdldElkZW50aWZpZXJUZXh0KHRwLm5hbWUpKS5qb2luKCcsICcpXG4gIH0pO1xufVxuXG4vKipcbiAqIEFkZHMgaGVyaXRhZ2UgY2xhdXNlcyAoXFxAZXh0ZW5kcywgXFxAaW1wbGVtZW50cykgdG8gdGhlIGdpdmVuIGRvY1RhZ3MgZm9yIGRlY2wuIFVzZWQgYnlcbiAqIGpzZG9jX3RyYW5zZm9ybWVyIGFuZCBleHRlcm5zIGdlbmVyYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXliZUFkZEhlcml0YWdlQ2xhdXNlcyhcbiAgICBkb2NUYWdzOiBqc2RvYy5UYWdbXSwgbXR0OiBNb2R1bGVUeXBlVHJhbnNsYXRvcixcbiAgICBkZWNsOiB0cy5DbGFzc0xpa2VEZWNsYXJhdGlvbnx0cy5JbnRlcmZhY2VEZWNsYXJhdGlvbikge1xuICBpZiAoIWRlY2wuaGVyaXRhZ2VDbGF1c2VzKSByZXR1cm47XG4gIGNvbnN0IGlzQ2xhc3MgPSBkZWNsLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuQ2xhc3NEZWNsYXJhdGlvbjtcbiAgY29uc3QgaGFzRXh0ZW5kcyA9IGRlY2wuaGVyaXRhZ2VDbGF1c2VzLnNvbWUoYyA9PiBjLnRva2VuID09PSB0cy5TeW50YXhLaW5kLkV4dGVuZHNLZXl3b3JkKTtcbiAgZm9yIChjb25zdCBoZXJpdGFnZSBvZiBkZWNsLmhlcml0YWdlQ2xhdXNlcykge1xuICAgIGNvbnN0IGlzRXh0ZW5kcyA9IGhlcml0YWdlLnRva2VuID09PSB0cy5TeW50YXhLaW5kLkV4dGVuZHNLZXl3b3JkO1xuICAgIGlmIChpc0NsYXNzICYmIGlzRXh0ZW5kcykge1xuICAgICAgLy8gSWYgYSBjbGFzcyBoYXMgYW4gXCJleHRlbmRzXCIsIHRoYXQgaXMgcHJlc2VydmVkIGluIHRoZSBFUzYgb3V0cHV0XG4gICAgICAvLyBhbmQgd2UgZG9uJ3QgbmVlZCB0byBlbWl0IGFueSBhZGRpdGlvbmFsIGpzZG9jLlxuICAgICAgLy9cbiAgICAgIC8vIEhvd2V2ZXIgZm9yIGFtYmllbnQgZGVjbGFyYXRpb25zLCB3ZSBvbmx5IGVtaXQgZXh0ZXJucywgYW5kIGluIHRob3NlIHdlIGRvIG5lZWQgdG9cbiAgICAgIC8vIGFkZCBcIkBleHRlbmRzIHtGb299XCIgYXMgdGhleSB1c2UgRVM1IHN5bnRheC5cbiAgICAgIGlmICghdHJhbnNmb3JtZXJVdGlsLmlzQW1iaWVudChkZWNsKSkgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlLCBpZiB3ZSBnZXQgaGVyZSwgd2UgbmVlZCB0byBlbWl0IHNvbWUganNkb2MuXG4gICAgZm9yIChjb25zdCBleHByIG9mIGhlcml0YWdlLnR5cGVzKSB7XG4gICAgICBhZGRIZXJpdGFnZShpc0V4dGVuZHMgPyAnZXh0ZW5kcycgOiAnaW1wbGVtZW50cycsIGhhc0V4dGVuZHMsIGV4cHIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSByZWxldmFudCBDbG9zdXJlIEpTZG9jIHRhZ3MgZm9yIGFuIGV4cHJlc3Npb24gb2NjdXJyaW5nIGluIGEgaGVyaXRhZ2UgY2xhdXNlLFxuICAgKiBlLmcuIFwiaW1wbGVtZW50cyBGb29CYXJcIiA9PiBcIkBpbXBsZW1lbnRzIHtGb29CYXJ9XCIuXG4gICAqXG4gICAqIFdpbGwgcmV0dXJuIG51bGwgaWYgdGhlIGV4cHJlc3Npb24gaXMgaW5leHByZXNzaWJsZSBpbiBDbG9zdXJlIHNlbWFudGljcy5cbiAgICpcbiAgICogTm90ZSB0aGF0IHdlIGRvbid0IG5lZWQgdG8gY29uc2lkZXIgYWxsIHBvc3NpYmxlIGNvbWJpbmF0aW9ucyBvZiB0eXBlcy92YWx1ZXMgYW5kXG4gICAqIGV4dGVuZHMvaW1wbGVtZW50cyBiZWNhdXNlIG91ciBpbnB1dCBpcyBhbHJlYWR5IHZlcmlmaWVkIHRvIGJlIHZhbGlkIFR5cGVTY3JpcHQuICBTZWVcbiAgICogdGVzdF9maWxlcy9jbGFzcy8gZm9yIHRoZSBmdWxsIGNhcnRlc2lhbiBwcm9kdWN0IG9mIHRlc3QgY2FzZXMuXG4gICAqXG4gICAqIEBwYXJhbSBoYXNBbnlFeHRlbmRzIFRydWUgaWYgdGhlcmUgYXJlIGFueSAnZXh0ZW5kcycgY2xhdXNlcyBwcmVzZW50IGF0IGFsbC5cbiAgICovXG4gIGZ1bmN0aW9uIGFkZEhlcml0YWdlKFxuICAgICAgcmVsYXRpb246ICdleHRlbmRzJ3wnaW1wbGVtZW50cycsIGhhc0FueUV4dGVuZHM6IGJvb2xlYW4sXG4gICAgICBleHByOiB0cy5FeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHMpOiB2b2lkIHtcbiAgICBsZXQgdGFnTmFtZSA9IHJlbGF0aW9uO1xuICAgIGxldCBzeW0gPSBtdHQudHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbihleHByLmV4cHJlc3Npb24pO1xuICAgIGlmICghc3ltKSB7XG4gICAgICAvLyBJdCdzIHBvc3NpYmxlIGZvciBhIGNsYXNzIGRlY2xhcmF0aW9uIHRvIGV4dGVuZCBhbiBleHByZXNzaW9uIHRoYXRcbiAgICAgIC8vIGRvZXMgbm90IGhhdmUgaGF2ZSBhIHN5bWJvbCwgZm9yIGV4YW1wbGUgd2hlbiBhIG1peGluIGZ1bmN0aW9uIGlzXG4gICAgICAvLyB1c2VkIHRvIGJ1aWxkIGEgYmFzZSBjbGFzcywgYXMgaW4gYGRlY2xhcmUgTXlDbGFzcyBleHRlbmRzXG4gICAgICAvLyBNeU1peGluKE15QmFzZUNsYXNzKWAuXG4gICAgICAvL1xuICAgICAgLy8gSGFuZGxpbmcgdGhpcyBjb3JyZWN0bHkgaXMgdHJpY2t5LiBDbG9zdXJlIHRocm93cyBvbiB0aGlzXG4gICAgICAvLyBgZXh0ZW5kcyA8ZXhwcmVzc2lvbj5gIHN5bnRheCAoc2VlXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtY29tcGlsZXIvaXNzdWVzLzIxODIpLiBXZSB3b3VsZFxuICAgICAgLy8gcHJvYmFibHkgbmVlZCB0byBnZW5lcmF0ZSBhbiBpbnRlcm1lZGlhdGUgY2xhc3MgZGVjbGFyYXRpb24gYW5kXG4gICAgICAvLyBleHRlbmQgdGhhdC5cbiAgICAgIHdhcm4oZXhwciwgYGRyb3BwZWQgJHtyZWxhdGlvbn0gb2Ygbm9uLXN5bWJvbCBzdXBlcnR5cGU6ICR7ZXhwci5nZXRUZXh0KCl9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUmVzb2x2ZSBhbnkgYWxpYXNlcyB0byB0aGUgdW5kZXJseWluZyB0eXBlLlxuICAgIGlmIChzeW0uZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5UeXBlQWxpYXMpIHtcbiAgICAgIC8vIEl0J3MgaW1wbGVtZW50aW5nIGEgdHlwZSBhbGlhcy4gIEZvbGxvdyB0aGUgdHlwZSBhbGlhcyBiYWNrXG4gICAgICAvLyB0byB0aGUgb3JpZ2luYWwgc3ltYm9sIHRvIGNoZWNrIHdoZXRoZXIgaXQncyBhIHR5cGUgb3IgYSB2YWx1ZS5cbiAgICAgIGNvbnN0IHR5cGUgPSBtdHQudHlwZUNoZWNrZXIuZ2V0RGVjbGFyZWRUeXBlT2ZTeW1ib2woc3ltKTtcbiAgICAgIGlmICghdHlwZS5zeW1ib2wpIHtcbiAgICAgICAgLy8gSXQncyBub3QgY2xlYXIgd2hlbiB0aGlzIGNhbiBoYXBwZW4uXG4gICAgICAgIHdhcm4oZGVjbCwgYGNvdWxkIG5vdCBnZXQgdHlwZSBvZiBzeW1ib2w6ICR7ZXhwci5nZXRUZXh0KCl9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN5bSA9IHR5cGUuc3ltYm9sO1xuICAgIH1cbiAgICBpZiAoc3ltLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuQWxpYXMpIHtcbiAgICAgIHN5bSA9IG10dC50eXBlQ2hlY2tlci5nZXRBbGlhc2VkU3ltYm9sKHN5bSk7XG4gICAgfVxuXG4gICAgY29uc3QgdHlwZVRyYW5zbGF0b3IgPSBtdHQubmV3VHlwZVRyYW5zbGF0b3IoZXhwci5leHByZXNzaW9uKTtcbiAgICBpZiAodHlwZVRyYW5zbGF0b3IuaXNCbGFja0xpc3RlZChzeW0pKSB7XG4gICAgICAvLyBEb24ndCBlbWl0IHJlZmVyZW5jZXMgdG8gYmxhY2tsaXN0ZWQgdHlwZXMuXG4gICAgICB3YXJuKGRlY2wsIGBkcm9wcGVkICR7cmVsYXRpb259IG9mIGJsYWNrbGlzdGVkIHR5cGU6ICR7ZXhwci5nZXRUZXh0KCl9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHN5bS5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLkNsYXNzKSB7XG4gICAgICBpZiAoIWlzQ2xhc3MpIHtcbiAgICAgICAgLy8gQ2xvc3VyZSBpbnRlcmZhY2VzIGNhbm5vdCBleHRlbmQgb3IgaW1wbGVtZW50cyBjbGFzc2VzLlxuICAgICAgICB3YXJuKGRlY2wsIGBkcm9wcGVkIGludGVyZmFjZSAke3JlbGF0aW9ufSBjbGFzczogJHtleHByLmdldFRleHQoKX1gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHJlbGF0aW9uICE9PSAnZXh0ZW5kcycpIHtcbiAgICAgICAgaWYgKCFoYXNBbnlFeHRlbmRzKSB7XG4gICAgICAgICAgLy8gQSBzcGVjaWFsIGNhc2U6IGZvciBhIGNsYXNzIHRoYXQgaGFzIG5vIGV4aXN0aW5nICdleHRlbmRzJyBjbGF1c2UgYnV0IGRvZXNcbiAgICAgICAgICAvLyBoYXZlIGFuICdpbXBsZW1lbnRzJyBjbGF1c2UgdGhhdCByZWZlcnMgdG8gYW5vdGhlciBjbGFzcywgd2UgY2hhbmdlIGl0IHRvXG4gICAgICAgICAgLy8gaW5zdGVhZCBiZSBhbiAnZXh0ZW5kcycuICBUaGlzIHdhcyBhIHBvb3JseS10aG91Z2h0LW91dCBoYWNrIHRoYXQgbWF5XG4gICAgICAgICAgLy8gYWN0dWFsbHkgY2F1c2UgY29tcGlsZXIgYnVnczpcbiAgICAgICAgICAvLyAgIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1jb21waWxlci9pc3N1ZXMvMzEyNlxuICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGNvZGUgdGhhdCBub3cgcmVsaWVzIG9uIGl0LCB1Z2guXG4gICAgICAgICAgdGFnTmFtZSA9ICdleHRlbmRzJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDbG9zdXJlIGNhbiBvbmx5IEBpbXBsZW1lbnRzIGFuIGludGVyZmFjZSwgbm90IGEgY2xhc3MuXG4gICAgICAgICAgd2FybihkZWNsLCBgZHJvcHBlZCBpbXBsZW1lbnRzIG9mIGNsYXNzOiAke2V4cHIuZ2V0VGV4dCgpfWApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3ltLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuVmFsdWUpIHtcbiAgICAgIC8vIElmIHRoZSBzeW1ib2wgY2FtZSBmcm9tIHRzaWNrbGUgZW1pdCBhbmQgaXQncyBzb21ldGhpbmcgb3RoZXIgdGhhbiBhIGNsYXNzIGluIHRoZSB2YWx1ZVxuICAgICAgLy8gbmFtZXNwYWNlLCB0aGVuIHRzaWNrbGUgbWF5IG5vdCBoYXZlIGVtaXR0ZWQgdGhlIHR5cGUuXG4gICAgICAvLyBUT0RPKCMxMDcyKTogc29tZSBvdGhlciBzeW1ib2xzIHdlIG91Z2h0IHRvIGJlIHdvcnJ5aW5nIGFib3V0IGhlcmU6XG4gICAgICAvLyAtIGlmIHRoZSBzeW1ib2wgaXMgYSBUUyBidWlsdGluPyB3ZSBjYW4gZW1pdCBpdDtcbiAgICAgIC8vIC0gaWYgdGhlIHN5bWJvbCBjb21lcyBmcm9tIGEgdHNpY2tsZS10cmFuc3BpbGVkIGZpbGUsIGVpdGhlciAudHMgb3JcbiAgICAgIC8vICAgLmQudHMgd2l0aCBleHRlcm5zIGdlbmVyYXRpb24/IHRoZW4gbWF5YmUgd2UgY2FuIGVtaXQgaXQgd2l0aFxuICAgICAgLy8gICBuYW1lIG1hbmdsaW5nLlxuICAgICAgaWYgKCFpc0NsdXR6VHlwZShzeW0pKSB7XG4gICAgICAgIHdhcm4oZGVjbCwgYGRyb3BwZWQgJHtyZWxhdGlvbn0gb2YgYSB0eXBlL3ZhbHVlIGNvbmZsaWN0OiAke2V4cHIuZ2V0VGV4dCgpfWApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzeW0uZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5UeXBlTGl0ZXJhbCkge1xuICAgICAgLy8gQSB0eXBlIGxpdGVyYWwgaXMgYSB0eXBlIGxpa2UgYHtmb286IHN0cmluZ31gLlxuICAgICAgLy8gVGhlc2UgY2FuIGNvbWUgdXAgYXMgdGhlIG91dHB1dCBvZiBhIG1hcHBlZCB0eXBlLlxuICAgICAgd2FybihkZWNsLCBgZHJvcHBlZCAke3JlbGF0aW9ufSBvZiBhIHR5cGUgbGl0ZXJhbDogJHtleHByLmdldFRleHQoKX1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB0eXBlVG9DbG9zdXJlIGluY2x1ZGVzIG51bGxhYmlsaXR5IG1vZGlmaWVycywgc28gY2FsbCBzeW1ib2xUb1N0cmluZyBkaXJlY3RseSBoZXJlLlxuICAgIGNvbnN0IHBhcmVudE5hbWUgPSB0eXBlVHJhbnNsYXRvci5zeW1ib2xUb1N0cmluZyhzeW0pO1xuICAgIGlmICghcGFyZW50TmFtZSkge1xuICAgICAgd2FybihkZWNsLCBgZHJvcHBlZCAke3JlbGF0aW9ufSBvZiB1bm5hbWVhYmxlIHR5cGU6ICR7ZXhwci5nZXRUZXh0KCl9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRvY1RhZ3MucHVzaCh7XG4gICAgICB0YWdOYW1lLFxuICAgICAgdHlwZTogcGFyZW50TmFtZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBSZWNvcmRzIGEgd2FybmluZywgYm90aCBpbiB0aGUgc291cmNlIHRleHQgYW5kIGluIHRoZSBlbWl0IGhvc3QuICovXG4gIGZ1bmN0aW9uIHdhcm4oY29udGV4dDogdHMuTm9kZSwgbWVzc2FnZTogc3RyaW5nKSB7XG4gICAgZG9jVGFncy5wdXNoKHt0YWdOYW1lOiAnJywgdGV4dDogYHRzaWNrbGU6ICR7bWVzc2FnZX1gfSk7XG4gICAgbXR0LmRlYnVnV2Fybihjb250ZXh0LCBtZXNzYWdlKTtcbiAgfVxufVxuXG4vKipcbiAqIGNyZWF0ZU1lbWJlclR5cGVEZWNsYXJhdGlvbiBlbWl0cyB0aGUgdHlwZSBhbm5vdGF0aW9ucyBmb3IgbWVtYmVycyBvZiBhIGNsYXNzLiBJdCdzIG5lY2Vzc2FyeSBpblxuICogdGhlIGNhc2Ugd2hlcmUgVHlwZVNjcmlwdCBzeW50YXggc3BlY2lmaWVzIHRoZXJlIGFyZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgb24gdGhlIGNsYXNzLCBiZWNhdXNlXG4gKiB0byBkZWNsYXJlIHRoZXNlIGluIENsb3N1cmUgeW91IG11c3QgZGVjbGFyZSB0aGVzZSBzZXBhcmF0ZWx5IGZyb20gdGhlIGNsYXNzLlxuICpcbiAqIGNyZWF0ZU1lbWJlclR5cGVEZWNsYXJhdGlvbiBwcm9kdWNlcyBhbiBpZiAoZmFsc2UpIHN0YXRlbWVudCBjb250YWluaW5nIHByb3BlcnR5IGRlY2xhcmF0aW9ucywgb3JcbiAqIG51bGwgaWYgbm8gZGVjbGFyYXRpb25zIGNvdWxkIG9yIG5lZWRlZCB0byBiZSBnZW5lcmF0ZWQgKGUuZy4gbm8gbWVtYmVycywgb3IgYW4gdW5uYW1lZCB0eXBlKS5cbiAqIFRoZSBpZiBzdGF0ZW1lbnQgaXMgdXNlZCB0byBtYWtlIHN1cmUgdGhlIGNvZGUgaXMgbm90IGV4ZWN1dGVkLCBvdGhlcndpc2UgcHJvcGVydHkgYWNjZXNzZXMgY291bGRcbiAqIHRyaWdnZXIgZ2V0dGVycyBvbiBhIHN1cGVyY2xhc3MuIFNlZSB0ZXN0X2ZpbGVzL2ZpZWxkcy9maWVsZHMudHM6QmFzZVRoYXRUaHJvd3MuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1lbWJlclR5cGVEZWNsYXJhdGlvbihcbiAgICBtdHQ6IE1vZHVsZVR5cGVUcmFuc2xhdG9yLFxuICAgIHR5cGVEZWNsOiB0cy5DbGFzc0RlY2xhcmF0aW9ufHRzLkludGVyZmFjZURlY2xhcmF0aW9uKTogdHMuSWZTdGF0ZW1lbnR8bnVsbCB7XG4gIC8vIEdhdGhlciBwYXJhbWV0ZXIgcHJvcGVydGllcyBmcm9tIHRoZSBjb25zdHJ1Y3RvciwgaWYgaXQgZXhpc3RzLlxuICBjb25zdCBjdG9yczogdHMuQ29uc3RydWN0b3JEZWNsYXJhdGlvbltdID0gW107XG4gIGxldCBwYXJhbVByb3BzOiB0cy5QYXJhbWV0ZXJEZWNsYXJhdGlvbltdID0gW107XG4gIGNvbnN0IG5vblN0YXRpY1Byb3BzOiBBcnJheTx0cy5Qcm9wZXJ0eURlY2xhcmF0aW9ufHRzLlByb3BlcnR5U2lnbmF0dXJlPiA9IFtdO1xuICBjb25zdCBzdGF0aWNQcm9wczogQXJyYXk8dHMuUHJvcGVydHlEZWNsYXJhdGlvbnx0cy5Qcm9wZXJ0eVNpZ25hdHVyZT4gPSBbXTtcbiAgY29uc3QgdW5oYW5kbGVkOiB0cy5OYW1lZERlY2xhcmF0aW9uW10gPSBbXTtcbiAgY29uc3QgYWJzdHJhY3RNZXRob2RzOiB0cy5GdW5jdGlvbkxpa2VEZWNsYXJhdGlvbltdID0gW107XG4gIGZvciAoY29uc3QgbWVtYmVyIG9mIHR5cGVEZWNsLm1lbWJlcnMpIHtcbiAgICBpZiAobWVtYmVyLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuQ29uc3RydWN0b3IpIHtcbiAgICAgIGN0b3JzLnB1c2gobWVtYmVyIGFzIHRzLkNvbnN0cnVjdG9yRGVjbGFyYXRpb24pO1xuICAgIH0gZWxzZSBpZiAodHMuaXNQcm9wZXJ0eURlY2xhcmF0aW9uKG1lbWJlcikgfHwgdHMuaXNQcm9wZXJ0eVNpZ25hdHVyZShtZW1iZXIpKSB7XG4gICAgICBjb25zdCBpc1N0YXRpYyA9IHRyYW5zZm9ybWVyVXRpbC5oYXNNb2RpZmllckZsYWcobWVtYmVyLCB0cy5Nb2RpZmllckZsYWdzLlN0YXRpYyk7XG4gICAgICBpZiAoaXNTdGF0aWMpIHtcbiAgICAgICAgc3RhdGljUHJvcHMucHVzaChtZW1iZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9uU3RhdGljUHJvcHMucHVzaChtZW1iZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIG1lbWJlci5raW5kID09PSB0cy5TeW50YXhLaW5kLk1ldGhvZERlY2xhcmF0aW9uIHx8XG4gICAgICAgIG1lbWJlci5raW5kID09PSB0cy5TeW50YXhLaW5kLk1ldGhvZFNpZ25hdHVyZSB8fFxuICAgICAgICBtZW1iZXIua2luZCA9PT0gdHMuU3ludGF4S2luZC5HZXRBY2Nlc3NvciB8fCBtZW1iZXIua2luZCA9PT0gdHMuU3ludGF4S2luZC5TZXRBY2Nlc3Nvcikge1xuICAgICAgaWYgKHRyYW5zZm9ybWVyVXRpbC5oYXNNb2RpZmllckZsYWcobWVtYmVyLCB0cy5Nb2RpZmllckZsYWdzLkFic3RyYWN0KSB8fFxuICAgICAgICAgIHRzLmlzSW50ZXJmYWNlRGVjbGFyYXRpb24odHlwZURlY2wpKSB7XG4gICAgICAgIGFic3RyYWN0TWV0aG9kcy5wdXNoKFxuICAgICAgICAgICAgbWVtYmVyIGFzIHRzLk1ldGhvZERlY2xhcmF0aW9uIHwgdHMuR2V0QWNjZXNzb3JEZWNsYXJhdGlvbiB8IHRzLlNldEFjY2Vzc29yRGVjbGFyYXRpb24pO1xuICAgICAgfVxuICAgICAgLy8gTm9uLWFic3RyYWN0IG1ldGhvZHMgb25seSBleGlzdCBvbiBjbGFzc2VzLCBhbmQgYXJlIGhhbmRsZWQgaW4gcmVndWxhciBlbWl0LlxuICAgIH0gZWxzZSB7XG4gICAgICB1bmhhbmRsZWQucHVzaChtZW1iZXIpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjdG9ycy5sZW5ndGggPiAwKSB7XG4gICAgLy8gT25seSB0aGUgYWN0dWFsIGNvbnN0cnVjdG9yIGltcGxlbWVudGF0aW9uLCB3aGljaCBtdXN0IGJlIGxhc3QgaW4gYSBwb3RlbnRpYWwgc2VxdWVuY2Ugb2ZcbiAgICAvLyBvdmVybG9hZGVkIGNvbnN0cnVjdG9ycywgbWF5IGNvbnRhaW4gcGFyYW1ldGVyIHByb3BlcnRpZXMuXG4gICAgY29uc3QgY3RvciA9IGN0b3JzW2N0b3JzLmxlbmd0aCAtIDFdO1xuICAgIHBhcmFtUHJvcHMgPSBjdG9yLnBhcmFtZXRlcnMuZmlsdGVyKFxuICAgICAgICBwID0+IHRyYW5zZm9ybWVyVXRpbC5oYXNNb2RpZmllckZsYWcocCwgdHMuTW9kaWZpZXJGbGFncy5QYXJhbWV0ZXJQcm9wZXJ0eU1vZGlmaWVyKSk7XG4gIH1cblxuICBpZiAobm9uU3RhdGljUHJvcHMubGVuZ3RoID09PSAwICYmIHBhcmFtUHJvcHMubGVuZ3RoID09PSAwICYmIHN0YXRpY1Byb3BzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgYWJzdHJhY3RNZXRob2RzLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIFRoZXJlIGFyZSBubyBtZW1iZXJzIHNvIHdlIGRvbid0IG5lZWQgdG8gZW1pdCBhbnkgdHlwZVxuICAgIC8vIGFubm90YXRpb25zIGhlbHBlci5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICghdHlwZURlY2wubmFtZSkge1xuICAgIG10dC5kZWJ1Z1dhcm4odHlwZURlY2wsICdjYW5ub3QgYWRkIHR5cGVzIG9uIHVubmFtZWQgZGVjbGFyYXRpb25zJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBjbGFzc05hbWUgPSB0cmFuc2Zvcm1lclV0aWwuZ2V0SWRlbnRpZmllclRleHQodHlwZURlY2wubmFtZSk7XG4gIGNvbnN0IHN0YXRpY1Byb3BBY2Nlc3MgPSB0cy5jcmVhdGVJZGVudGlmaWVyKGNsYXNzTmFtZSk7XG4gIGNvbnN0IGluc3RhbmNlUHJvcEFjY2VzcyA9IHRzLmNyZWF0ZVByb3BlcnR5QWNjZXNzKHN0YXRpY1Byb3BBY2Nlc3MsICdwcm90b3R5cGUnKTtcbiAgLy8gQ2xvc3VyZSBDb21waWxlciB3aWxsIHJlcG9ydCBjb25mb3JtYW5jZSBlcnJvcnMgYWJvdXQgdGhpcyBiZWluZyB1bmtub3duIHR5cGUgd2hlbiBlbWl0dGluZ1xuICAvLyBjbGFzcyBwcm9wZXJ0aWVzIGFzIHs/fHVuZGVmaW5lZH0sIGluc3RlYWQgb2YganVzdCB7P30uIFNvIG1ha2Ugc3VyZSB0byBvbmx5IGVtaXQgez98dW5kZWZpbmVkfVxuICAvLyBvbiBpbnRlcmZhY2VzLlxuICBjb25zdCBpc0ludGVyZmFjZSA9IHRzLmlzSW50ZXJmYWNlRGVjbGFyYXRpb24odHlwZURlY2wpO1xuICBjb25zdCBwcm9wZXJ0eURlY2xzID0gc3RhdGljUHJvcHMubWFwKFxuICAgICAgcCA9PiBjcmVhdGVDbG9zdXJlUHJvcGVydHlEZWNsYXJhdGlvbihcbiAgICAgICAgICBtdHQsIHN0YXRpY1Byb3BBY2Nlc3MsIHAsIGlzSW50ZXJmYWNlICYmICEhcC5xdWVzdGlvblRva2VuKSk7XG4gIHByb3BlcnR5RGVjbHMucHVzaCguLi5bLi4ubm9uU3RhdGljUHJvcHMsIC4uLnBhcmFtUHJvcHNdLm1hcChcbiAgICAgIHAgPT4gY3JlYXRlQ2xvc3VyZVByb3BlcnR5RGVjbGFyYXRpb24oXG4gICAgICAgICAgbXR0LCBpbnN0YW5jZVByb3BBY2Nlc3MsIHAsIGlzSW50ZXJmYWNlICYmICEhcC5xdWVzdGlvblRva2VuKSkpO1xuICBwcm9wZXJ0eURlY2xzLnB1c2goLi4udW5oYW5kbGVkLm1hcChcbiAgICAgIHAgPT4gdHJhbnNmb3JtZXJVdGlsLmNyZWF0ZU11bHRpTGluZUNvbW1lbnQoXG4gICAgICAgICAgcCwgYFNraXBwaW5nIHVuaGFuZGxlZCBtZW1iZXI6ICR7ZXNjYXBlRm9yQ29tbWVudChwLmdldFRleHQoKSl9YCkpKTtcblxuICBmb3IgKGNvbnN0IGZuRGVjbCBvZiBhYnN0cmFjdE1ldGhvZHMpIHtcbiAgICAvLyBJZiB0aGUgZnVuY3Rpb24gZGVjbGFyYXRpb24gaXMgY29tcHV0ZWQsIGl0cyBuYW1lIGlzIHRoZSBjb21wdXRlZCBleHByZXNzaW9uOyBvdGhlcndpc2UsIGl0c1xuICAgIC8vIG5hbWUgY2FuIGJlIHJlc29sdmVkIHRvIGEgc3RyaW5nLlxuICAgIGNvbnN0IG5hbWUgPSBmbkRlY2wubmFtZSAmJiB0cy5pc0NvbXB1dGVkUHJvcGVydHlOYW1lKGZuRGVjbC5uYW1lKSA/IGZuRGVjbC5uYW1lLmV4cHJlc3Npb24gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZShmbkRlY2wpO1xuICAgIGlmICghbmFtZSkge1xuICAgICAgbXR0LmVycm9yKGZuRGVjbCwgJ2Fub255bW91cyBhYnN0cmFjdCBmdW5jdGlvbicpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHt0YWdzLCBwYXJhbWV0ZXJOYW1lc30gPSBtdHQuZ2V0RnVuY3Rpb25UeXBlSlNEb2MoW2ZuRGVjbF0sIFtdKTtcbiAgICBpZiAoaGFzRXhwb3J0aW5nRGVjb3JhdG9yKGZuRGVjbCwgbXR0LnR5cGVDaGVja2VyKSkgdGFncy5wdXNoKHt0YWdOYW1lOiAnZXhwb3J0J30pO1xuICAgIC8vIFVzZSBlbGVtZW50IGFjY2VzcyBpbnN0ZWFkIG9mIHByb3BlcnR5IGFjY2VzcyBmb3IgY29tcHVlZCBuYW1lcy5cbiAgICBjb25zdCBsaHMgPSB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgPyB0cy5jcmVhdGVQcm9wZXJ0eUFjY2VzcyhpbnN0YW5jZVByb3BBY2Nlc3MsIG5hbWUpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cy5jcmVhdGVFbGVtZW50QWNjZXNzKGluc3RhbmNlUHJvcEFjY2VzcywgbmFtZSk7XG4gICAgLy8gbWVtYmVyTmFtZXNwYWNlIGJlY2F1c2UgYWJzdHJhY3QgbWV0aG9kcyBjYW5ub3QgYmUgc3RhdGljIGluIFR5cGVTY3JpcHQuXG4gICAgY29uc3QgYWJzdHJhY3RGbkRlY2wgPSB0cy5jcmVhdGVTdGF0ZW1lbnQodHMuY3JlYXRlQXNzaWdubWVudChcbiAgICAgICAgbGhzLFxuICAgICAgICB0cy5jcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24oXG4gICAgICAgICAgICAvKiBtb2RpZmllcnMgKi8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgLyogYXN0ZXJpc2sgKi8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgLyogbmFtZSAqLyB1bmRlZmluZWQsXG4gICAgICAgICAgICAvKiB0eXBlUGFyYW1ldGVycyAqLyB1bmRlZmluZWQsXG4gICAgICAgICAgICBwYXJhbWV0ZXJOYW1lcy5tYXAoXG4gICAgICAgICAgICAgICAgbiA9PiB0cy5jcmVhdGVQYXJhbWV0ZXIoXG4gICAgICAgICAgICAgICAgICAgIC8qIGRlY29yYXRvcnMgKi8gdW5kZWZpbmVkLCAvKiBtb2RpZmllcnMgKi8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAvKiBkb3REb3REb3QgKi8gdW5kZWZpbmVkLCBuKSksXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB0cy5jcmVhdGVCbG9jayhbXSksXG4gICAgICAgICAgICApKSk7XG4gICAgdHMuc2V0U3ludGhldGljTGVhZGluZ0NvbW1lbnRzKGFic3RyYWN0Rm5EZWNsLCBbanNkb2MudG9TeW50aGVzaXplZENvbW1lbnQodGFncyldKTtcbiAgICBwcm9wZXJ0eURlY2xzLnB1c2godHMuc2V0U291cmNlTWFwUmFuZ2UoYWJzdHJhY3RGbkRlY2wsIGZuRGVjbCkpO1xuICB9XG5cbiAgLy8gU2VlIHRlc3RfZmlsZXMvZmllbGRzL2ZpZWxkcy50czpCYXNlVGhhdFRocm93cyBmb3IgYSBub3RlIG9uIHRoaXMgd3JhcHBlci5cbiAgcmV0dXJuIHRzLmNyZWF0ZUlmKHRzLmNyZWF0ZUxpdGVyYWwoZmFsc2UpLCB0cy5jcmVhdGVCbG9jayhwcm9wZXJ0eURlY2xzLCB0cnVlKSk7XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5TmFtZShwcm9wOiB0cy5OYW1lZERlY2xhcmF0aW9uKTogc3RyaW5nfG51bGwge1xuICBpZiAoIXByb3AubmFtZSkgcmV0dXJuIG51bGw7XG5cbiAgc3dpdGNoIChwcm9wLm5hbWUua2luZCkge1xuICAgIGNhc2UgdHMuU3ludGF4S2luZC5JZGVudGlmaWVyOlxuICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyVXRpbC5nZXRJZGVudGlmaWVyVGV4dChwcm9wLm5hbWUgYXMgdHMuSWRlbnRpZmllcik7XG4gICAgY2FzZSB0cy5TeW50YXhLaW5kLlN0cmluZ0xpdGVyYWw6XG4gICAgICAvLyBFLmcuIGludGVyZmFjZSBGb28geyAnYmFyJzogbnVtYmVyOyB9XG4gICAgICAvLyBJZiAnYmFyJyBpcyBhIG5hbWUgdGhhdCBpcyBub3QgdmFsaWQgaW4gQ2xvc3VyZSB0aGVuIHRoZXJlJ3Mgbm90aGluZyB3ZSBjYW4gZG8uXG4gICAgICBjb25zdCB0ZXh0ID0gKHByb3AubmFtZSBhcyB0cy5TdHJpbmdMaXRlcmFsKS50ZXh0O1xuICAgICAgaWYgKCFpc1ZhbGlkQ2xvc3VyZVByb3BlcnR5TmFtZSh0ZXh0KSkgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqIFJlbW92ZXMgY29tbWVudCBtZXRhY2hhcmFjdGVycyBmcm9tIGEgc3RyaW5nLCB0byBtYWtlIGl0IHNhZmUgdG8gZW1iZWQgaW4gYSBjb21tZW50LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZUZvckNvbW1lbnQoc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcL1xcKi9nLCAnX18nKS5yZXBsYWNlKC9cXCpcXC8vZywgJ19fJyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNsb3N1cmVQcm9wZXJ0eURlY2xhcmF0aW9uKFxuICAgIG10dDogTW9kdWxlVHlwZVRyYW5zbGF0b3IsIGV4cHI6IHRzLkV4cHJlc3Npb24sXG4gICAgcHJvcDogdHMuUHJvcGVydHlEZWNsYXJhdGlvbnx0cy5Qcm9wZXJ0eVNpZ25hdHVyZXx0cy5QYXJhbWV0ZXJEZWNsYXJhdGlvbixcbiAgICBvcHRpb25hbDogYm9vbGVhbik6IHRzLlN0YXRlbWVudCB7XG4gIGNvbnN0IG5hbWUgPSBwcm9wZXJ0eU5hbWUocHJvcCk7XG4gIGlmICghbmFtZSkge1xuICAgIG10dC5kZWJ1Z1dhcm4ocHJvcCwgYGhhbmRsZSB1bm5hbWVkIG1lbWJlcjpcXG4ke2VzY2FwZUZvckNvbW1lbnQocHJvcC5nZXRUZXh0KCkpfWApO1xuICAgIHJldHVybiB0cmFuc2Zvcm1lclV0aWwuY3JlYXRlTXVsdGlMaW5lQ29tbWVudChcbiAgICAgICAgcHJvcCwgYFNraXBwaW5nIHVubmFtZWQgbWVtYmVyOlxcbiR7ZXNjYXBlRm9yQ29tbWVudChwcm9wLmdldFRleHQoKSl9YCk7XG4gIH1cblxuICBpZiAobmFtZSA9PT0gJ3Byb3RvdHlwZScpIHtcbiAgICAvLyBDb2RlIHRoYXQgZGVjbGFyZXMgYSBwcm9wZXJ0eSBuYW1lZCAncHJvdG90eXBlJyB0eXBpY2FsbHkgaXMgZG9pbmcgc29tZXRoaW5nXG4gICAgLy8gZnVubnkgd2l0aCB0aGUgVFMgdHlwZSBzeXN0ZW0sIGFuZCBpc24ndCBhY3R1YWxseSBpbnRlcmVzdGVkIGluIG5hbWluZyBhXG4gICAgLy8gYSBmaWVsZCAncHJvdG90eXBlJywgYXMgcHJvdG90eXBlIGhhcyBzcGVjaWFsIG1lYW5pbmcgaW4gSlMuXG4gICAgcmV0dXJuIHRyYW5zZm9ybWVyVXRpbC5jcmVhdGVNdWx0aUxpbmVDb21tZW50KFxuICAgICAgICBwcm9wLCBgU2tpcHBpbmcgaWxsZWdhbCBtZW1iZXIgbmFtZTpcXG4ke2VzY2FwZUZvckNvbW1lbnQocHJvcC5nZXRUZXh0KCkpfWApO1xuICB9XG5cbiAgbGV0IHR5cGUgPSBtdHQudHlwZVRvQ2xvc3VyZShwcm9wKTtcbiAgLy8gV2hlbiBhIHByb3BlcnR5IGlzIG9wdGlvbmFsLCBlLmcuXG4gIC8vICAgZm9vPzogc3RyaW5nO1xuICAvLyBUaGVuIHRoZSBUeXBlU2NyaXB0IHR5cGUgb2YgdGhlIHByb3BlcnR5IGlzIHN0cmluZ3x1bmRlZmluZWQsIHRoZVxuICAvLyB0eXBlVG9DbG9zdXJlIHRyYW5zbGF0aW9uIGhhbmRsZXMgaXQgY29ycmVjdGx5LCBhbmQgc3RyaW5nfHVuZGVmaW5lZCBpc1xuICAvLyBob3cgeW91IHdyaXRlIGFuIG9wdGlvbmFsIHByb3BlcnR5IGluIENsb3N1cmUuXG4gIC8vXG4gIC8vIEJ1dCBpbiB0aGUgc3BlY2lhbCBjYXNlIG9mIGFuIG9wdGlvbmFsIHByb3BlcnR5IHdpdGggdHlwZSBhbnk6XG4gIC8vICAgZm9vPzogYW55O1xuICAvLyBUaGUgVHlwZVNjcmlwdCB0eXBlIG9mIHRoZSBwcm9wZXJ0eSBpcyBqdXN0IFwiYW55XCIgKGJlY2F1c2UgYW55IGluY2x1ZGVzXG4gIC8vIHVuZGVmaW5lZCBhcyB3ZWxsKSBzbyBvdXIgZGVmYXVsdCB0cmFuc2xhdGlvbiBvZiB0aGUgdHlwZSBpcyBqdXN0IFwiP1wiLlxuICAvLyBUbyBtYXJrIHRoZSBwcm9wZXJ0eSBhcyBvcHRpb25hbCBpbiBDbG9zdXJlIGl0IG11c3QgaGF2ZSBcInx1bmRlZmluZWRcIixcbiAgLy8gc28gdGhlIENsb3N1cmUgdHlwZSBtdXN0IGJlID98dW5kZWZpbmVkLlxuICBpZiAob3B0aW9uYWwgJiYgdHlwZSA9PT0gJz8nKSB0eXBlICs9ICd8dW5kZWZpbmVkJztcblxuICBjb25zdCB0YWdzID0gbXR0LmdldEpTRG9jKHByb3AsIC8qIHJlcG9ydFdhcm5pbmdzICovIHRydWUpO1xuICB0YWdzLnB1c2goe3RhZ05hbWU6ICd0eXBlJywgdHlwZX0pO1xuICBjb25zdCBmbGFncyA9IHRzLmdldENvbWJpbmVkTW9kaWZpZXJGbGFncyhwcm9wKTtcbiAgaWYgKGZsYWdzICYgdHMuTW9kaWZpZXJGbGFncy5Qcm90ZWN0ZWQpIHtcbiAgICB0YWdzLnB1c2goe3RhZ05hbWU6ICdwcm90ZWN0ZWQnfSk7XG4gIH0gZWxzZSBpZiAoZmxhZ3MgJiB0cy5Nb2RpZmllckZsYWdzLlByaXZhdGUpIHtcbiAgICB0YWdzLnB1c2goe3RhZ05hbWU6ICdwcml2YXRlJ30pO1xuICB9XG4gIGlmIChoYXNFeHBvcnRpbmdEZWNvcmF0b3IocHJvcCwgbXR0LnR5cGVDaGVja2VyKSkge1xuICAgIHRhZ3MucHVzaCh7dGFnTmFtZTogJ2V4cG9ydCd9KTtcbiAgfVxuICBjb25zdCBkZWNsU3RtdCA9XG4gICAgICB0cy5zZXRTb3VyY2VNYXBSYW5nZSh0cy5jcmVhdGVTdGF0ZW1lbnQodHMuY3JlYXRlUHJvcGVydHlBY2Nlc3MoZXhwciwgbmFtZSkpLCBwcm9wKTtcbiAgLy8gQXZvaWQgcHJpbnRpbmcgYW5ub3RhdGlvbnMgdGhhdCBjYW4gY29uZmxpY3Qgd2l0aCBAdHlwZVxuICAvLyBUaGlzIGF2b2lkcyBDbG9zdXJlJ3MgZXJyb3IgXCJ0eXBlIGFubm90YXRpb24gaW5jb21wYXRpYmxlIHdpdGggb3RoZXIgYW5ub3RhdGlvbnNcIlxuICBhZGRDb21tZW50T24oZGVjbFN0bXQsIHRhZ3MsIGpzZG9jLlRBR1NfQ09ORkxJQ1RJTkdfV0lUSF9UWVBFKTtcbiAgcmV0dXJuIGRlY2xTdG10O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYW55IHR5cGUgYXNzZXJ0aW9ucyBhbmQgbm9uLW51bGwgZXhwcmVzc2lvbnMgZnJvbSB0aGUgQVNUIGJlZm9yZSBUeXBlU2NyaXB0IHByb2Nlc3NpbmcuXG4gKlxuICogSWRlYWxseSwgdGhlIGNvZGUgaW4ganNkb2NfdHJhbnNmb3JtZXIgYmVsb3cgc2hvdWxkIGp1c3QgcmVtb3ZlIHRoZSBjYXN0IGV4cHJlc3Npb24gYW5kXG4gKiByZXBsYWNlIGl0IHdpdGggdGhlIENsb3N1cmUgZXF1aXZhbGVudC4gSG93ZXZlciBBbmd1bGFyJ3MgY29tcGlsZXIgaXMgZnJhZ2lsZSB0byBBU1RcbiAqIG5vZGVzIGJlaW5nIHJlbW92ZWQgb3IgY2hhbmdpbmcgdHlwZSwgc28gdGhlIGNvZGUgbXVzdCByZXRhaW4gdGhlIHR5cGUgYXNzZXJ0aW9uXG4gKiBleHByZXNzaW9uLCBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzI0ODk1LlxuICpcbiAqIHRzaWNrbGUgYWxzbyBjYW5ub3QganVzdCBnZW5lcmF0ZSBhbmQga2VlcCBhIGAoLy4uIEB0eXBlIHtTb21lVHlwZX0gLi8gKGV4cHIgYXMgU29tZVR5cGUpKWBcbiAqIGJlY2F1c2UgVHlwZVNjcmlwdCByZW1vdmVzIHRoZSBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb25zIGluIHRoYXQgc3ludGF4LCAocmVhc29uYWJseSkgYmVsaWV2aW5nXG4gKiB0aGV5IHdlcmUgb25seSBhZGRlZCBmb3IgdGhlIFRTIGNhc3QuXG4gKlxuICogVGhlIGZpbmFsIHdvcmthcm91bmQgaXMgdGhlbiB0byBrZWVwIHRoZSBUeXBlU2NyaXB0IHR5cGUgYXNzZXJ0aW9ucywgYW5kIGhhdmUgYSBwb3N0LUFuZ3VsYXJcbiAqIHByb2Nlc3Npbmcgc3RlcCB0aGF0IHJlbW92ZXMgdGhlIGFzc2VydGlvbnMgYmVmb3JlIFR5cGVTY3JpcHQgc2VlcyB0aGVtLlxuICpcbiAqIFRPRE8obWFydGlucHJvYnN0KTogcmVtb3ZlIG9uY2UgdGhlIEFuZ3VsYXIgaXNzdWUgaXMgZml4ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVUeXBlQXNzZXJ0aW9ucygpOiB0cy5UcmFuc2Zvcm1lckZhY3Rvcnk8dHMuU291cmNlRmlsZT4ge1xuICByZXR1cm4gKGNvbnRleHQ6IHRzLlRyYW5zZm9ybWF0aW9uQ29udGV4dCkgPT4ge1xuICAgIHJldHVybiAoc291cmNlRmlsZTogdHMuU291cmNlRmlsZSkgPT4ge1xuICAgICAgZnVuY3Rpb24gdmlzaXRvcihub2RlOiB0cy5Ob2RlKTogdHMuTm9kZSB7XG4gICAgICAgIHN3aXRjaCAobm9kZS5raW5kKSB7XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlR5cGVBc3NlcnRpb25FeHByZXNzaW9uOlxuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5Bc0V4cHJlc3Npb246XG4gICAgICAgICAgICByZXR1cm4gdHMudmlzaXROb2RlKChub2RlIGFzIHRzLkFzc2VydGlvbkV4cHJlc3Npb24pLmV4cHJlc3Npb24sIHZpc2l0b3IpO1xuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5Ob25OdWxsRXhwcmVzc2lvbjpcbiAgICAgICAgICAgIHJldHVybiB0cy52aXNpdE5vZGUoKG5vZGUgYXMgdHMuTm9uTnVsbEV4cHJlc3Npb24pLmV4cHJlc3Npb24sIHZpc2l0b3IpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHMudmlzaXRFYWNoQ2hpbGQobm9kZSwgdmlzaXRvciwgY29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2aXNpdG9yKHNvdXJjZUZpbGUpIGFzIHRzLlNvdXJjZUZpbGU7XG4gICAgfTtcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgbm9kZSBsZXhpY2FsbHkgKHJlY3Vyc2l2ZWx5KSBjb250YWlucyBhbiAnYXN5bmMnIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjb250YWluc0FzeW5jKG5vZGU6IHRzLk5vZGUpOiBib29sZWFuIHtcbiAgaWYgKHRzLmlzRnVuY3Rpb25MaWtlKG5vZGUpICYmIHRyYW5zZm9ybWVyVXRpbC5oYXNNb2RpZmllckZsYWcobm9kZSwgdHMuTW9kaWZpZXJGbGFncy5Bc3luYykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gdHMuZm9yRWFjaENoaWxkKG5vZGUsIGNvbnRhaW5zQXN5bmMpIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIGpzZG9jVHJhbnNmb3JtZXIgcmV0dXJucyBhIHRyYW5zZm9ybWVyIGZhY3RvcnkgdGhhdCBjb252ZXJ0cyBUeXBlU2NyaXB0IHR5cGVzIGludG8gdGhlIGVxdWl2YWxlbnRcbiAqIEpTRG9jIGFubm90YXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24ganNkb2NUcmFuc2Zvcm1lcihcbiAgICBob3N0OiBBbm5vdGF0b3JIb3N0LCB0c09wdGlvbnM6IHRzLkNvbXBpbGVyT3B0aW9ucywgdHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyLFxuICAgIGRpYWdub3N0aWNzOiB0cy5EaWFnbm9zdGljW10pOiAoY29udGV4dDogdHMuVHJhbnNmb3JtYXRpb25Db250ZXh0KSA9PlxuICAgIHRzLlRyYW5zZm9ybWVyPHRzLlNvdXJjZUZpbGU+IHtcbiAgcmV0dXJuIChjb250ZXh0OiB0cy5UcmFuc2Zvcm1hdGlvbkNvbnRleHQpOiB0cy5UcmFuc2Zvcm1lcjx0cy5Tb3VyY2VGaWxlPiA9PiB7XG4gICAgcmV0dXJuIChzb3VyY2VGaWxlOiB0cy5Tb3VyY2VGaWxlKSA9PiB7XG4gICAgICBjb25zdCBtb2R1bGVUeXBlVHJhbnNsYXRvciA9IG5ldyBNb2R1bGVUeXBlVHJhbnNsYXRvcihcbiAgICAgICAgICBzb3VyY2VGaWxlLCB0eXBlQ2hlY2tlciwgaG9zdCwgZGlhZ25vc3RpY3MsIC8qaXNGb3JFeHRlcm5zKi8gZmFsc2UpO1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgc2V0IG9mIGFsbCBuYW1lcyBleHBvcnRlZCBmcm9tIGFuIGV4cG9ydCAqIGluIHRoZSBjdXJyZW50IG1vZHVsZS4gVXNlZCB0byBwcmV2ZW50XG4gICAgICAgKiBlbWl0dGluZyBkdXBsaWNhdGVkIGV4cG9ydHMuIFRoZSBmaXJzdCBleHBvcnQgKiB0YWtlcyBwcmVjZWRlbmNlIGluIEVTNi5cbiAgICAgICAqL1xuICAgICAgY29uc3QgZXhwYW5kZWRTdGFySW1wb3J0cyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gICAgICAvKipcbiAgICAgICAqIFdoaWxlIENsb3N1cmUgY29tcGlsZXIgc3VwcG9ydHMgcGFyYW1ldGVyaXplZCB0eXBlcywgaW5jbHVkaW5nIHBhcmFtZXRlcml6ZWQgYHRoaXNgIG9uXG4gICAgICAgKiBtZXRob2RzLCBpdCBkb2VzIG5vdCBzdXBwb3J0IGNvbnN0cmFpbnRzIG9uIHRoZW0uIFRoYXQgbWVhbnMgdGhhdCBhbiBgXFxAdGVtcGxhdGVgZCB0eXBlIGlzXG4gICAgICAgKiBhbHdheXMgY29uc2lkZXJlZCB0byBiZSBgdW5rbm93bmAgd2l0aGluIHRoZSBtZXRob2QsIGluY2x1ZGluZyBgVEhJU2AuXG4gICAgICAgKlxuICAgICAgICogVG8gaGVscCBDbG9zdXJlIENvbXBpbGVyLCB3ZSBrZWVwIHRyYWNrIG9mIGFueSB0ZW1wbGF0ZWQgdGhpcyByZXR1cm4gdHlwZSwgYW5kIHN1YnN0aXR1dGVcbiAgICAgICAqIGV4cGxpY2l0IGNhc3RzIHRvIHRoZSB0ZW1wbGF0ZWQgdHlwZS5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIGlzIGFuIGluY29tcGxldGUgc29sdXRpb24gYW5kIHdvcmtzIGFyb3VuZCBhIHNwZWNpZmljIHByb2JsZW0gd2l0aCB3YXJuaW5ncyBvbiB1bmtub3duXG4gICAgICAgKiB0aGlzIGFjY2Vzc2VzLiBNb3JlIGdlbmVyYWxseSwgQ2xvc3VyZSBhbHNvIGNhbm5vdCBpbmZlciBjb25zdHJhaW50cyBmb3IgYW55IG90aGVyXG4gICAgICAgKiB0ZW1wbGF0ZWQgdHlwZXMsIGJ1dCB0aGF0IG1pZ2h0IHJlcXVpcmUgYSBtb3JlIGdlbmVyYWwgc29sdXRpb24gaW4gQ2xvc3VyZSBDb21waWxlci5cbiAgICAgICAqL1xuICAgICAgbGV0IGNvbnRleHRUaGlzVHlwZTogdHMuVHlwZXxudWxsID0gbnVsbDtcblxuICAgICAgZnVuY3Rpb24gdmlzaXRDbGFzc0RlY2xhcmF0aW9uKGNsYXNzRGVjbDogdHMuQ2xhc3NEZWNsYXJhdGlvbik6IHRzLlN0YXRlbWVudFtdIHtcbiAgICAgICAgY29uc3QgY29udGV4dFRoaXNUeXBlQmFja3VwID0gY29udGV4dFRoaXNUeXBlO1xuXG4gICAgICAgIGNvbnN0IG1qc2RvYyA9IG1vZHVsZVR5cGVUcmFuc2xhdG9yLmdldE11dGFibGVKU0RvYyhjbGFzc0RlY2wpO1xuICAgICAgICBpZiAodHJhbnNmb3JtZXJVdGlsLmhhc01vZGlmaWVyRmxhZyhjbGFzc0RlY2wsIHRzLk1vZGlmaWVyRmxhZ3MuQWJzdHJhY3QpKSB7XG4gICAgICAgICAgbWpzZG9jLnRhZ3MucHVzaCh7dGFnTmFtZTogJ2Fic3RyYWN0J30pO1xuICAgICAgICB9XG5cbiAgICAgICAgbWF5YmVBZGRUZW1wbGF0ZUNsYXVzZShtanNkb2MudGFncywgY2xhc3NEZWNsKTtcbiAgICAgICAgaWYgKCFob3N0LnVudHlwZWQpIHtcbiAgICAgICAgICBtYXliZUFkZEhlcml0YWdlQ2xhdXNlcyhtanNkb2MudGFncywgbW9kdWxlVHlwZVRyYW5zbGF0b3IsIGNsYXNzRGVjbCk7XG4gICAgICAgIH1cbiAgICAgICAgbWpzZG9jLnVwZGF0ZUNvbW1lbnQoKTtcbiAgICAgICAgY29uc3QgZGVjbHM6IHRzLlN0YXRlbWVudFtdID0gW107XG4gICAgICAgIGNvbnN0IG1lbWJlckRlY2wgPSBjcmVhdGVNZW1iZXJUeXBlRGVjbGFyYXRpb24obW9kdWxlVHlwZVRyYW5zbGF0b3IsIGNsYXNzRGVjbCk7XG4gICAgICAgIC8vIFdBUk5JTkc6IG9yZGVyIGlzIHNpZ25pZmljYW50OyB3ZSBtdXN0IGNyZWF0ZSB0aGUgbWVtYmVyIGRlY2wgYmVmb3JlIHRyYW5zZm9ybWluZyBhd2F5XG4gICAgICAgIC8vIHBhcmFtZXRlciBwcm9wZXJ0eSBjb21tZW50cyB3aGVuIHZpc2l0aW5nIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgZGVjbHMucHVzaCh0cy52aXNpdEVhY2hDaGlsZChjbGFzc0RlY2wsIHZpc2l0b3IsIGNvbnRleHQpKTtcbiAgICAgICAgaWYgKG1lbWJlckRlY2wpIGRlY2xzLnB1c2gobWVtYmVyRGVjbCk7XG4gICAgICAgIGNvbnRleHRUaGlzVHlwZSA9IGNvbnRleHRUaGlzVHlwZUJhY2t1cDtcbiAgICAgICAgcmV0dXJuIGRlY2xzO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHZpc2l0SGVyaXRhZ2VDbGF1c2Ugd29ya3MgYXJvdW5kIGEgQ2xvc3VyZSBDb21waWxlciBpc3N1ZSwgd2hlcmUgdGhlIGV4cHJlc3Npb24gaW4gYW5cbiAgICAgICAqIFwiZXh0ZW5kc1wiIGNsYXVzZSBtdXN0IGJlIGEgc2ltcGxlIGlkZW50aWZpZXIsIGFuZCBpbiBwYXJ0aWN1bGFyIG11c3Qgbm90IGJlIGEgcGFyZW50aGVzaXplZFxuICAgICAgICogZXhwcmVzc2lvbi5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIGlzIHRyaWdnZXJlZCB3aGVuIFRTIGNvZGUgd3JpdGVzIFwiY2xhc3MgWCBleHRlbmRzIChGb28gYXMgQmFyKSB7IC4uLiB9XCIsIGNvbW1vbmx5IGRvbmVcbiAgICAgICAqIHRvIHN1cHBvcnQgbWl4aW5zLiBGb3IgZXh0ZW5kcyBjbGF1c2VzIGluIGNsYXNzZXMsIHRoZSBjb2RlIGJlbG93IGRyb3BzIHRoZSBjYXN0IGFuZCBhbnlcbiAgICAgICAqIHBhcmVudGhldGljYWxzLCBsZWF2aW5nIGp1c3QgdGhlIG9yaWdpbmFsIGV4cHJlc3Npb24uXG4gICAgICAgKlxuICAgICAgICogVGhpcyBpcyBhbiBpbmNvbXBsZXRlIHdvcmthcm91bmQsIGFzIENsb3N1cmUgd2lsbCBzdGlsbCBiYWlsIG9uIG90aGVyIHN1cGVyIGV4cHJlc3Npb25zLFxuICAgICAgICogYnV0IHJldGFpbnMgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBwcmV2aW91cyBlbWl0IHRoYXQgKGFjY2lkZW50YWxseSkgZHJvcHBlZCB0aGUgY2FzdFxuICAgICAgICogZXhwcmVzc2lvbi5cbiAgICAgICAqXG4gICAgICAgKiBUT0RPKG1hcnRpbnByb2JzdCk6IHJlbW92ZSB0aGlzIG9uY2UgdGhlIENsb3N1cmUgc2lkZSBpc3N1ZSBoYXMgYmVlbiByZXNvbHZlZC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gdmlzaXRIZXJpdGFnZUNsYXVzZShoZXJpdGFnZUNsYXVzZTogdHMuSGVyaXRhZ2VDbGF1c2UpIHtcbiAgICAgICAgaWYgKGhlcml0YWdlQ2xhdXNlLnRva2VuICE9PSB0cy5TeW50YXhLaW5kLkV4dGVuZHNLZXl3b3JkIHx8ICFoZXJpdGFnZUNsYXVzZS5wYXJlbnQgfHxcbiAgICAgICAgICAgIGhlcml0YWdlQ2xhdXNlLnBhcmVudC5raW5kID09PSB0cy5TeW50YXhLaW5kLkludGVyZmFjZURlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHRzLnZpc2l0RWFjaENoaWxkKGhlcml0YWdlQ2xhdXNlLCB2aXNpdG9yLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyaXRhZ2VDbGF1c2UudHlwZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgbW9kdWxlVHlwZVRyYW5zbGF0b3IuZXJyb3IoXG4gICAgICAgICAgICAgIGhlcml0YWdlQ2xhdXNlLCBgZXhwZWN0ZWQgZXhhY3RseSBvbmUgdHlwZSBpbiBjbGFzcyBleHRlbnNpb24gY2xhdXNlYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZSA9IGhlcml0YWdlQ2xhdXNlLnR5cGVzWzBdO1xuICAgICAgICBsZXQgZXhwcjogdHMuRXhwcmVzc2lvbiA9IHR5cGUuZXhwcmVzc2lvbjtcbiAgICAgICAgd2hpbGUgKHRzLmlzUGFyZW50aGVzaXplZEV4cHJlc3Npb24oZXhwcikgfHwgdHMuaXNOb25OdWxsRXhwcmVzc2lvbihleHByKSB8fFxuICAgICAgICAgICAgICAgdHMuaXNBc3NlcnRpb25FeHByZXNzaW9uKGV4cHIpKSB7XG4gICAgICAgICAgZXhwciA9IGV4cHIuZXhwcmVzc2lvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHMudXBkYXRlSGVyaXRhZ2VDbGF1c2UoaGVyaXRhZ2VDbGF1c2UsIFt0cy51cGRhdGVFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsIHR5cGUudHlwZUFyZ3VtZW50cyB8fCBbXSwgZXhwcildKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdmlzaXRJbnRlcmZhY2VEZWNsYXJhdGlvbihpZmFjZTogdHMuSW50ZXJmYWNlRGVjbGFyYXRpb24pOiB0cy5TdGF0ZW1lbnRbXSB7XG4gICAgICAgIGNvbnN0IHN5bSA9IHR5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24oaWZhY2UubmFtZSk7XG4gICAgICAgIGlmICghc3ltKSB7XG4gICAgICAgICAgbW9kdWxlVHlwZVRyYW5zbGF0b3IuZXJyb3IoaWZhY2UsICdpbnRlcmZhY2Ugd2l0aCBubyBzeW1ib2wnKTtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhpcyBzeW1ib2wgaXMgYm90aCBhIHR5cGUgYW5kIGEgdmFsdWUsIHdlIGNhbm5vdCBlbWl0IGJvdGggaW50byBDbG9zdXJlJ3NcbiAgICAgICAgLy8gc2luZ2xlIG5hbWVzcGFjZS5cbiAgICAgICAgaWYgKHN5bWJvbElzVmFsdWUodHlwZUNoZWNrZXIsIHN5bSkpIHtcbiAgICAgICAgICBtb2R1bGVUeXBlVHJhbnNsYXRvci5kZWJ1Z1dhcm4oXG4gICAgICAgICAgICAgIGlmYWNlLCBgdHlwZS9zeW1ib2wgY29uZmxpY3QgZm9yICR7c3ltLm5hbWV9LCB1c2luZyB7P30gZm9yIG5vd2ApO1xuICAgICAgICAgIHJldHVybiBbdHJhbnNmb3JtZXJVdGlsLmNyZWF0ZVNpbmdsZUxpbmVDb21tZW50KFxuICAgICAgICAgICAgICBpZmFjZSwgJ1dBUk5JTkc6IGludGVyZmFjZSBoYXMgYm90aCBhIHR5cGUgYW5kIGEgdmFsdWUsIHNraXBwaW5nIGVtaXQnKV07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0YWdzID0gbW9kdWxlVHlwZVRyYW5zbGF0b3IuZ2V0SlNEb2MoaWZhY2UsIC8qIHJlcG9ydFdhcm5pbmdzICovIHRydWUpIHx8IFtdO1xuICAgICAgICB0YWdzLnB1c2goe3RhZ05hbWU6ICdyZWNvcmQnfSk7XG4gICAgICAgIG1heWJlQWRkVGVtcGxhdGVDbGF1c2UodGFncywgaWZhY2UpO1xuICAgICAgICBpZiAoIWhvc3QudW50eXBlZCkge1xuICAgICAgICAgIG1heWJlQWRkSGVyaXRhZ2VDbGF1c2VzKHRhZ3MsIG1vZHVsZVR5cGVUcmFuc2xhdG9yLCBpZmFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IHRyYW5zZm9ybWVyVXRpbC5nZXRJZGVudGlmaWVyVGV4dChpZmFjZS5uYW1lKTtcbiAgICAgICAgY29uc3QgbW9kaWZpZXJzID0gdHJhbnNmb3JtZXJVdGlsLmhhc01vZGlmaWVyRmxhZyhpZmFjZSwgdHMuTW9kaWZpZXJGbGFncy5FeHBvcnQpID9cbiAgICAgICAgICAgIFt0cy5jcmVhdGVUb2tlbih0cy5TeW50YXhLaW5kLkV4cG9ydEtleXdvcmQpXSA6XG4gICAgICAgICAgICB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGRlY2wgPSB0cy5zZXRTb3VyY2VNYXBSYW5nZShcbiAgICAgICAgICAgIHRzLmNyZWF0ZUZ1bmN0aW9uRGVjbGFyYXRpb24oXG4gICAgICAgICAgICAgICAgLyogZGVjb3JhdG9ycyAqLyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbW9kaWZpZXJzLFxuICAgICAgICAgICAgICAgIC8qIGFzdGVyaXNrICovIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIC8qIHR5cGVQYXJhbWV0ZXJzICovIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAvKiBwYXJhbWV0ZXJzICovW10sXG4gICAgICAgICAgICAgICAgLyogdHlwZSAqLyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgLyogYm9keSAqLyB0cy5jcmVhdGVCbG9jayhbXSksXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGlmYWNlKTtcbiAgICAgICAgYWRkQ29tbWVudE9uKGRlY2wsIHRhZ3MpO1xuICAgICAgICBjb25zdCBtZW1iZXJEZWNsID0gY3JlYXRlTWVtYmVyVHlwZURlY2xhcmF0aW9uKG1vZHVsZVR5cGVUcmFuc2xhdG9yLCBpZmFjZSk7XG4gICAgICAgIHJldHVybiBtZW1iZXJEZWNsID8gW2RlY2wsIG1lbWJlckRlY2xdIDogW2RlY2xdO1xuICAgICAgfVxuXG4gICAgICAvKiogUmV0dXJucyB0aGUgYHRoaXNgIHR5cGUgaW4gdGhpcyBjb250ZXh0LCBvciB1bmRlZmluZWQgaWYgbm9uZS4gKi9cbiAgICAgIGZ1bmN0aW9uIGdldENvbnRleHRUaGlzVHlwZShub2RlOiB0cy5Ob2RlfHVuZGVmaW5lZCk6IHRzLlR5cGV8dW5kZWZpbmVkIHtcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICBpZiAodHMuaXNDbGFzc0RlY2xhcmF0aW9uKG5vZGUpICYmIG5vZGUubmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVDaGVja2VyLmdldFR5cGVBdExvY2F0aW9uKG5vZGUubmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0cy5pc0Z1bmN0aW9uRGVjbGFyYXRpb24obm9kZSkgJiYgbm9kZS5wYXJhbWV0ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0UGFyYW0gPSBub2RlLnBhcmFtZXRlcnNbMF07XG4gICAgICAgICAgICAvLyB0cy5TaWduYXR1cmUgZG9lcyBub3QgZXhwb3NlIGEgYHRoaXNgIHR5cGUsIHNvIGNvbXBhcmluZyBpZGVudGlmaWVyIG5hbWVzIHRvICd0aGlzJ1xuICAgICAgICAgICAgLy8gaXMgdGhlIG9ubHkgd2F5IHRvIGZpbmQgYSB0aGlzIHR5cGUgZGVjbGFyYXRpb24uXG4gICAgICAgICAgICBpZiAodHMuaXNJZGVudGlmaWVyKGZpcnN0UGFyYW0ubmFtZSkgJiZcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lclV0aWwuZ2V0SWRlbnRpZmllclRleHQoZmlyc3RQYXJhbS5uYW1lKSA9PT0gJ3RoaXMnICYmIGZpcnN0UGFyYW0udHlwZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHlwZUNoZWNrZXIuZ2V0VHlwZUF0TG9jYXRpb24oZmlyc3RQYXJhbS50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8qKiBGdW5jdGlvbiBkZWNsYXJhdGlvbnMgYXJlIGVtaXR0ZWQgYXMgdGhleSBhcmUsIHdpdGggb25seSBKU0RvYyBhZGRlZC4gKi9cbiAgICAgIGZ1bmN0aW9uIHZpc2l0RnVuY3Rpb25MaWtlRGVjbGFyYXRpb248VCBleHRlbmRzIHRzLkZ1bmN0aW9uTGlrZURlY2xhcmF0aW9uPihmbkRlY2w6IFQpOiBUIHtcbiAgICAgICAgaWYgKCFmbkRlY2wuYm9keSkge1xuICAgICAgICAgIC8vIFR3byBjYXNlczogYWJzdHJhY3QgbWV0aG9kcyBhbmQgb3ZlcmxvYWRlZCBtZXRob2RzL2Z1bmN0aW9ucy5cbiAgICAgICAgICAvLyBBYnN0cmFjdCBtZXRob2RzIGFyZSBoYW5kbGVkIGluIGVtaXRUeXBlQW5ub3RhdGlvbnNIYW5kbGVyLlxuICAgICAgICAgIC8vIE92ZXJsb2FkcyBhcmUgdW5pb24taXplZCBpbnRvIHRoZSBzaGFyZWQgdHlwZSBpbiBGdW5jdGlvblR5cGUuXG4gICAgICAgICAgcmV0dXJuIHRzLnZpc2l0RWFjaENoaWxkKGZuRGVjbCwgdmlzaXRvciwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXh0cmFUYWdzID0gW107XG4gICAgICAgIGlmIChoYXNFeHBvcnRpbmdEZWNvcmF0b3IoZm5EZWNsLCB0eXBlQ2hlY2tlcikpIGV4dHJhVGFncy5wdXNoKHt0YWdOYW1lOiAnZXhwb3J0J30pO1xuXG4gICAgICAgIGNvbnN0IHt0YWdzLCB0aGlzUmV0dXJuVHlwZX0gPVxuICAgICAgICAgICAgbW9kdWxlVHlwZVRyYW5zbGF0b3IuZ2V0RnVuY3Rpb25UeXBlSlNEb2MoW2ZuRGVjbF0sIGV4dHJhVGFncyk7XG5cbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIHdoZW4gZG93bi1sZXZlbGVkIGFjY2VzcyBgdGhpc2AgdG8gcGFzcyBpdCB0b1xuICAgICAgICAvLyB0c2xpYi5fX2F3YWl0ZXIuICBDbG9zdXJlIHdhbnRzIHRvIGtub3cgdGhlIHR5cGUgb2YgJ3RoaXMnIGZvciB0aGF0LlxuICAgICAgICAvLyBUaGUgdHlwZSBpcyBrbm93biBpbiBtYW55IGNvbnRleHRzIChlLmcuIG1ldGhvZHMsIGFycm93IGZ1bmN0aW9ucylcbiAgICAgICAgLy8gcGVyIHRoZSBub3JtYWwgcnVsZXMgKGUuZy4gbG9va2luZyBhdCBwYXJlbnQgbm9kZXMgYW5kIEB0aGlzIHRhZ3MpXG4gICAgICAgIC8vIGJ1dCBpZiB0aGUgc2VhcmNoIGJvdHRvbXMgb3V0IGF0IGEgZnVuY3Rpb24gc2NvcGUsIHRoZW4gQ2xvc3VyZVxuICAgICAgICAvLyB3YXJucyB0aGF0ICd0aGlzJyBpcyB1bmtub3duLlxuICAgICAgICAvLyBCZWNhdXNlIHdlIGhhdmUgYWxyZWFkeSBjaGVja2VkIHRoZSB0eXBlIG9mICd0aGlzJywgd2UgYXJlIG9rIHRvIGp1c3RcbiAgICAgICAgLy8gc3VwcHJlc3MgaW4gdGhhdCBjYXNlLiAgV2UgZG8gc28gYnkgc3R1ZmZpbmcgYSBAdGhpcyBvbiBhbnkgZnVuY3Rpb25cbiAgICAgICAgLy8gd2hlcmUgaXQgbWlnaHQgYmUgbmVlZGVkOyBpdCdzIGhhcm1sZXNzIHRvIG92ZXJhcHByb3hpbWF0ZS5cbiAgICAgICAgY29uc3QgaXNEb3dubGV2ZWxsaW5nQXN5bmMgPVxuICAgICAgICAgICAgdHNPcHRpb25zLnRhcmdldCAhPT0gdW5kZWZpbmVkICYmIHRzT3B0aW9ucy50YXJnZXQgPD0gdHMuU2NyaXB0VGFyZ2V0LkVTMjAxNTtcbiAgICAgICAgY29uc3QgaXNGdW5jdGlvbiA9IGZuRGVjbC5raW5kID09PSB0cy5TeW50YXhLaW5kLkZ1bmN0aW9uRGVjbGFyYXRpb247XG4gICAgICAgIGNvbnN0IGhhc0V4aXN0aW5nVGhpc1RhZyA9IHRhZ3Muc29tZSh0ID0+IHQudGFnTmFtZSA9PT0gJ3RoaXMnKTtcbiAgICAgICAgaWYgKGlzRG93bmxldmVsbGluZ0FzeW5jICYmIGlzRnVuY3Rpb24gJiYgIWhhc0V4aXN0aW5nVGhpc1RhZyAmJiBjb250YWluc0FzeW5jKGZuRGVjbCkpIHtcbiAgICAgICAgICB0YWdzLnB1c2goe3RhZ05hbWU6ICd0aGlzJywgdHlwZTogJyonfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWpzZG9jID0gbW9kdWxlVHlwZVRyYW5zbGF0b3IuZ2V0TXV0YWJsZUpTRG9jKGZuRGVjbCk7XG4gICAgICAgIG1qc2RvYy50YWdzID0gdGFncztcbiAgICAgICAgbWpzZG9jLnVwZGF0ZUNvbW1lbnQoKTtcblxuICAgICAgICBjb25zdCBjb250ZXh0VGhpc1R5cGVCYWNrdXAgPSBjb250ZXh0VGhpc1R5cGU7XG4gICAgICAgIC8vIEFycm93IGZ1bmN0aW9ucyByZXRhaW4gdGhlaXIgY29udGV4dCBgdGhpc2AgdHlwZS4gQWxsIG90aGVycyByZXNldCB0aGUgdGhpcyB0eXBlIHRvXG4gICAgICAgIC8vIGVpdGhlciBub25lIChpZiBub3Qgc3BlY2lmaWVkKSBvciB0aGUgdHlwZSBnaXZlbiBpbiBhIGZuKHRoaXM6IFQsIC4uLikgZGVjbGFyYXRpb24uXG4gICAgICAgIGlmICghdHMuaXNBcnJvd0Z1bmN0aW9uKGZuRGVjbCkpIGNvbnRleHRUaGlzVHlwZSA9IHRoaXNSZXR1cm5UeXBlO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0cy52aXNpdEVhY2hDaGlsZChmbkRlY2wsIHZpc2l0b3IsIGNvbnRleHQpO1xuICAgICAgICBjb250ZXh0VGhpc1R5cGUgPSBjb250ZXh0VGhpc1R5cGVCYWNrdXA7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSW4gbWV0aG9kcyB3aXRoIGEgdGVtcGxhdGVkIHRoaXMgdHlwZSwgYWRkcyBleHBsaWNpdCBjYXN0cyB0byBhY2Nlc3NlcyBvbiB0aGlzLlxuICAgICAgICpcbiAgICAgICAqIEBzZWUgY29udGV4dFRoaXNUeXBlXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIHZpc2l0VGhpc0V4cHJlc3Npb24obm9kZTogdHMuVGhpc0V4cHJlc3Npb24pIHtcbiAgICAgICAgaWYgKCFjb250ZXh0VGhpc1R5cGUpIHJldHVybiB0cy52aXNpdEVhY2hDaGlsZChub2RlLCB2aXNpdG9yLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNsb3N1cmVDYXN0KG5vZGUsIG5vZGUsIGNvbnRleHRUaGlzVHlwZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogdmlzaXRWYXJpYWJsZVN0YXRlbWVudCBmbGF0dGVucyB2YXJpYWJsZSBkZWNsYXJhdGlvbiBsaXN0cyAoYHZhciBhLCBiO2AgdG8gYHZhciBhOyB2YXJcbiAgICAgICAqIGI7YCksIGFuZCBhdHRhY2hlcyBKU0RvYyBjb21tZW50cyB0byBlYWNoIHZhcmlhYmxlLiBKU0RvYyBjb21tZW50cyBwcmVjZWRpbmcgdGhlXG4gICAgICAgKiBvcmlnaW5hbCB2YXJpYWJsZSBhcmUgYXR0YWNoZWQgdG8gdGhlIGZpcnN0IG5ld2x5IGNyZWF0ZWQgb25lLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiB2aXNpdFZhcmlhYmxlU3RhdGVtZW50KHZhclN0bXQ6IHRzLlZhcmlhYmxlU3RhdGVtZW50KTogdHMuU3RhdGVtZW50W10ge1xuICAgICAgICBjb25zdCBzdG10czogdHMuU3RhdGVtZW50W10gPSBbXTtcblxuICAgICAgICAvLyBcImNvbnN0XCIsIFwibGV0XCIsIGV0YyBhcmUgc3RvcmVkIGluIG5vZGUgZmxhZ3Mgb24gdGhlIGRlY2xhcmF0aW9uTGlzdC5cbiAgICAgICAgY29uc3QgZmxhZ3MgPSB0cy5nZXRDb21iaW5lZE5vZGVGbGFncyh2YXJTdG10LmRlY2xhcmF0aW9uTGlzdCk7XG5cbiAgICAgICAgbGV0IHRhZ3M6IGpzZG9jLlRhZ1tdfG51bGwgPVxuICAgICAgICAgICAgbW9kdWxlVHlwZVRyYW5zbGF0b3IuZ2V0SlNEb2ModmFyU3RtdCwgLyogcmVwb3J0V2FybmluZ3MgKi8gdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGxlYWRpbmcgPSB0cy5nZXRTeW50aGV0aWNMZWFkaW5nQ29tbWVudHModmFyU3RtdCk7XG4gICAgICAgIGlmIChsZWFkaW5nKSB7XG4gICAgICAgICAgLy8gQXR0YWNoIG5vbi1KU0RvYyBjb21tZW50cyB0byBhIG5vdCBlbWl0dGVkIHN0YXRlbWVudC5cbiAgICAgICAgICBjb25zdCBjb21tZW50SG9sZGVyID0gdHMuY3JlYXRlTm90RW1pdHRlZFN0YXRlbWVudCh2YXJTdG10KTtcbiAgICAgICAgICB0cy5zZXRTeW50aGV0aWNMZWFkaW5nQ29tbWVudHMoY29tbWVudEhvbGRlciwgbGVhZGluZy5maWx0ZXIoYyA9PiBjLnRleHRbMF0gIT09ICcqJykpO1xuICAgICAgICAgIHN0bXRzLnB1c2goY29tbWVudEhvbGRlcik7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGRlY2wgb2YgdmFyU3RtdC5kZWNsYXJhdGlvbkxpc3QuZGVjbGFyYXRpb25zKSB7XG4gICAgICAgICAgY29uc3QgbG9jYWxUYWdzOiBqc2RvYy5UYWdbXSA9IFtdO1xuICAgICAgICAgIGlmICh0YWdzKSB7XG4gICAgICAgICAgICAvLyBBZGQgYW55IHRhZ3MgYW5kIGRvY3MgcHJlY2VkaW5nIHRoZSBlbnRpcmUgc3RhdGVtZW50IHRvIHRoZSBmaXJzdCB2YXJpYWJsZS5cbiAgICAgICAgICAgIGxvY2FsVGFncy5wdXNoKC4uLnRhZ3MpO1xuICAgICAgICAgICAgdGFncyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEFkZCBhbiBAdHlwZSBmb3IgcGxhaW4gaWRlbnRpZmllcnMsIGJ1dCBub3QgZm9yIGJpbmRpbmdzIHBhdHRlcm5zIChpLmUuIG9iamVjdCBvciBhcnJheVxuICAgICAgICAgIC8vIGRlc3RydWN0dXJpbmcgLSB0aG9zZSBkbyBub3QgaGF2ZSBhIHN5bnRheCBpbiBDbG9zdXJlKSBvciBAZGVmaW5lcywgd2hpY2ggYWxyZWFkeVxuICAgICAgICAgIC8vIGRlY2xhcmUgdGhlaXIgdHlwZS5cbiAgICAgICAgICBpZiAodHMuaXNJZGVudGlmaWVyKGRlY2wubmFtZSkpIHtcbiAgICAgICAgICAgIC8vIEZvciB2YXJpYWJsZXMgdGhhdCBhcmUgaW5pdGlhbGl6ZWQgYW5kIHVzZSBhIGJsYWNrbGlzdGVkIHR5cGUsIGRvIG5vdCBlbWl0IGEgdHlwZSBhdFxuICAgICAgICAgICAgLy8gYWxsLiBDbG9zdXJlIENvbXBpbGVyIG1pZ2h0IGJlIGFibGUgdG8gaW5mZXIgYSBiZXR0ZXIgdHlwZSBmcm9tIHRoZSBpbml0aWFsaXplciB0aGFuXG4gICAgICAgICAgICAvLyB0aGUgYD9gIHRoZSBjb2RlIGJlbG93IHdvdWxkIGVtaXQuXG4gICAgICAgICAgICAvLyBUT0RPKG1hcnRpbnByb2JzdCk6IGNvbnNpZGVyIGRvaW5nIHRoaXMgZm9yIGFsbCB0eXBlcyB0aGF0IGdldCBlbWl0dGVkIGFzID8sIG5vdCBqdXN0XG4gICAgICAgICAgICAvLyBmb3IgYmxhY2tsaXN0ZWQgb25lcy5cbiAgICAgICAgICAgIGNvbnN0IGJsYWNrTGlzdGVkSW5pdGlhbGl6ZWQgPVxuICAgICAgICAgICAgICAgICEhZGVjbC5pbml0aWFsaXplciAmJiBtb2R1bGVUeXBlVHJhbnNsYXRvci5pc0JsYWNrTGlzdGVkKGRlY2wpO1xuICAgICAgICAgICAgaWYgKCFibGFja0xpc3RlZEluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgIC8vIGdldE9yaWdpbmFsTm9kZShkZWNsKSBpcyByZXF1aXJlZCBiZWNhdXNlIHRoZSB0eXBlIGNoZWNrZXIgY2Fubm90IHR5cGUgY2hlY2tcbiAgICAgICAgICAgICAgLy8gc3ludGhlc2l6ZWQgbm9kZXMuXG4gICAgICAgICAgICAgIGNvbnN0IHR5cGVTdHIgPSBtb2R1bGVUeXBlVHJhbnNsYXRvci50eXBlVG9DbG9zdXJlKHRzLmdldE9yaWdpbmFsTm9kZShkZWNsKSk7XG4gICAgICAgICAgICAgIC8vIElmIEBkZWZpbmUgaXMgcHJlc2VudCB0aGVuIGFkZCB0aGUgdHlwZSB0byBpdCwgcmF0aGVyIHRoYW4gYWRkaW5nIGEgbm9ybWFsIEB0eXBlLlxuICAgICAgICAgICAgICBjb25zdCBkZWZpbmVUYWcgPSBsb2NhbFRhZ3MuZmluZCgoe3RhZ05hbWV9KSA9PiB0YWdOYW1lID09PSAnZGVmaW5lJyk7XG4gICAgICAgICAgICAgIGlmIChkZWZpbmVUYWcpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVUYWcudHlwZSA9IHR5cGVTdHI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9jYWxUYWdzLnB1c2goe3RhZ05hbWU6ICd0eXBlJywgdHlwZTogdHlwZVN0cn0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG5ld0RlY2wgPSB0cy52aXNpdE5vZGUoZGVjbCwgdmlzaXRvcik7XG4gICAgICAgICAgY29uc3QgbmV3U3RtdCA9IHRzLmNyZWF0ZVZhcmlhYmxlU3RhdGVtZW50KFxuICAgICAgICAgICAgICB2YXJTdG10Lm1vZGlmaWVycywgdHMuY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoW25ld0RlY2xdLCBmbGFncykpO1xuICAgICAgICAgIGlmIChsb2NhbFRhZ3MubGVuZ3RoKSBhZGRDb21tZW50T24obmV3U3RtdCwgbG9jYWxUYWdzLCBqc2RvYy5UQUdTX0NPTkZMSUNUSU5HX1dJVEhfVFlQRSk7XG4gICAgICAgICAgc3RtdHMucHVzaChuZXdTdG10KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdG10cztcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBzaG91bGRFbWl0RXhwb3J0c0Fzc2lnbm1lbnRzIHJldHVybnMgdHJ1ZSBpZiB0c2lja2xlIHNob3VsZCBlbWl0IGBleHBvcnRzLkZvbyA9IC4uLmAgc3R5bGVcbiAgICAgICAqIGV4cG9ydCBzdGF0ZW1lbnRzLlxuICAgICAgICpcbiAgICAgICAqIFR5cGVTY3JpcHQgbW9kdWxlcyBjYW4gZXhwb3J0IHR5cGVzLiBCZWNhdXNlIHR5cGVzIGFyZSBwdXJlIGRlc2lnbi10aW1lIGNvbnN0cnVjdHMgaW5cbiAgICAgICAqIFR5cGVTY3JpcHQsIGl0IGRvZXMgbm90IGVtaXQgYW55IGFjdHVhbCBleHBvcnRlZCBzeW1ib2xzIGZvciB0aGVzZS4gQnV0IHRzaWNrbGUgaGFzIHRvIGVtaXRcbiAgICAgICAqIGFuIGV4cG9ydCwgc28gdGhhdCBkb3duc3RyZWFtIENsb3N1cmUgY29kZSAoaW5jbHVkaW5nIHRzaWNrbGUtY29udmVydGVkIENsb3N1cmUgY29kZSkgY2FuXG4gICAgICAgKiBpbXBvcnQgdXBzdHJlYW0gdHlwZXMuIHRzaWNrbGUgaGFzIHRvIHBpY2sgYSBtb2R1bGUgZm9ybWF0IGZvciB0aGF0LCBiZWNhdXNlIHRoZSBwdXJlIEVTNlxuICAgICAgICogZXhwb3J0IHdvdWxkIGdldCBzdHJpcHBlZCBieSBUeXBlU2NyaXB0LlxuICAgICAgICpcbiAgICAgICAqIHRzaWNrbGUgdXNlcyBDb21tb25KUyB0byBlbWl0IGdvb2dtb2R1bGUsIGFuZCBjb2RlIG5vdCB1c2luZyBnb29nbW9kdWxlIGRvZXNuJ3QgY2FyZSBhYm91dFxuICAgICAgICogdGhlIENsb3N1cmUgYW5ub3RhdGlvbnMgYW55d2F5LCBzbyB0c2lja2xlIHNraXBzIGVtaXR0aW5nIGV4cG9ydHMgaWYgdGhlIG1vZHVsZSB0YXJnZXRcbiAgICAgICAqIGlzbid0IGNvbW1vbmpzLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBzaG91bGRFbWl0RXhwb3J0c0Fzc2lnbm1lbnRzKCkge1xuICAgICAgICByZXR1cm4gdHNPcHRpb25zLm1vZHVsZSA9PT0gdHMuTW9kdWxlS2luZC5Db21tb25KUztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdmlzaXRUeXBlQWxpYXNEZWNsYXJhdGlvbih0eXBlQWxpYXM6IHRzLlR5cGVBbGlhc0RlY2xhcmF0aW9uKTogdHMuU3RhdGVtZW50W10ge1xuICAgICAgICBjb25zdCBzeW0gPSBtb2R1bGVUeXBlVHJhbnNsYXRvci5tdXN0R2V0U3ltYm9sQXRMb2NhdGlvbih0eXBlQWxpYXMubmFtZSk7XG4gICAgICAgIC8vIElmIHRoZSB0eXBlIGlzIGFsc28gZGVmaW5lZCBhcyBhIHZhbHVlLCBza2lwIGVtaXR0aW5nIGl0LiBDbG9zdXJlIGNvbGxhcHNlcyB0eXBlICYgdmFsdWVcbiAgICAgICAgLy8gbmFtZXNwYWNlcywgdGhlIHR3byBlbWl0cyB3b3VsZCBjb25mbGljdCBpZiB0c2lja2xlIGVtaXR0ZWQgYm90aC5cbiAgICAgICAgaWYgKHN5bWJvbElzVmFsdWUodHlwZUNoZWNrZXIsIHN5bSkpIHJldHVybiBbXTtcbiAgICAgICAgaWYgKCFzaG91bGRFbWl0RXhwb3J0c0Fzc2lnbm1lbnRzKCkpIHJldHVybiBbXTtcblxuICAgICAgICBjb25zdCB0eXBlTmFtZSA9IHR5cGVBbGlhcy5uYW1lLmdldFRleHQoKTtcblxuICAgICAgICAvLyBCbGFja2xpc3QgYW55IHR5cGUgcGFyYW1ldGVycywgQ2xvc3VyZSBkb2VzIG5vdCBzdXBwb3J0IHR5cGUgYWxpYXNlcyB3aXRoIHR5cGVcbiAgICAgICAgLy8gcGFyYW1ldGVycy5cbiAgICAgICAgbW9kdWxlVHlwZVRyYW5zbGF0b3IubmV3VHlwZVRyYW5zbGF0b3IodHlwZUFsaWFzKS5ibGFja2xpc3RUeXBlUGFyYW1ldGVycyhcbiAgICAgICAgICAgIG1vZHVsZVR5cGVUcmFuc2xhdG9yLnN5bWJvbHNUb0FsaWFzZWROYW1lcywgdHlwZUFsaWFzLnR5cGVQYXJhbWV0ZXJzKTtcbiAgICAgICAgY29uc3QgdHlwZVN0ciA9XG4gICAgICAgICAgICBob3N0LnVudHlwZWQgPyAnPycgOiBtb2R1bGVUeXBlVHJhbnNsYXRvci50eXBlVG9DbG9zdXJlKHR5cGVBbGlhcywgdW5kZWZpbmVkKTtcblxuICAgICAgICAvLyBXZSB3YW50IHRvIGVtaXQgYSBAdHlwZWRlZi4gIFRoZXkgYXJlIGEgYml0IHdlaXJkIGJlY2F1c2UgdGhleSBhcmUgJ3Zhcicgc3RhdGVtZW50c1xuICAgICAgICAvLyB0aGF0IGhhdmUgbm8gdmFsdWUuXG4gICAgICAgIGNvbnN0IHRhZ3MgPSBtb2R1bGVUeXBlVHJhbnNsYXRvci5nZXRKU0RvYyh0eXBlQWxpYXMsIC8qIHJlcG9ydFdhcm5pbmdzICovIHRydWUpO1xuICAgICAgICB0YWdzLnB1c2goe3RhZ05hbWU6ICd0eXBlZGVmJywgdHlwZTogdHlwZVN0cn0pO1xuICAgICAgICBjb25zdCBpc0V4cG9ydGVkID0gdHJhbnNmb3JtZXJVdGlsLmhhc01vZGlmaWVyRmxhZyh0eXBlQWxpYXMsIHRzLk1vZGlmaWVyRmxhZ3MuRXhwb3J0KTtcbiAgICAgICAgbGV0IGRlY2w6IHRzLlN0YXRlbWVudDtcbiAgICAgICAgaWYgKGlzRXhwb3J0ZWQpIHtcbiAgICAgICAgICAvLyBHaXZlbjogZXhwb3J0IHR5cGUgVCA9IC4uLjtcbiAgICAgICAgICAvLyBXZSBjYW5ub3QgZW1pdCBgZXhwb3J0IHZhciBmb287YCBhbmQgbGV0IFRTIGdlbmVyYXRlIGZyb20gdGhlcmUgYmVjYXVzZSBUeXBlU2NyaXB0XG4gICAgICAgICAgLy8gZHJvcHMgZXhwb3J0cyB0aGF0IGFyZSBuZXZlciBhc3NpZ25lZCB2YWx1ZXMsIGFuZCBDbG9zdXJlIHJlcXVpcmVzIHVzIHRvIG5vdCBhc3NpZ25cbiAgICAgICAgICAvLyB2YWx1ZXMgdG8gdHlwZWRlZiBleHBvcnRzLiBJbnRyb2R1Y2luZyBhIG5ldyBsb2NhbCB2YXJpYWJsZSBhbmQgZXhwb3J0aW5nIGl0IGNhbiBjYXVzZVxuICAgICAgICAgIC8vIGJ1Z3MgZHVlIHRvIG5hbWUgc2hhZG93aW5nIGFuZCBjb25mdXNpbmcgVHlwZVNjcmlwdCdzIGxvZ2ljIG9uIHdoYXQgc3ltYm9scyBhbmQgdHlwZXNcbiAgICAgICAgICAvLyB2cyB2YWx1ZXMgYXJlIGV4cG9ydGVkLiBNYW5nbGluZyB0aGUgbmFtZSB0byBhdm9pZCB0aGUgY29uZmxpY3RzIHdvdWxkIGJlIHJlYXNvbmFibHlcbiAgICAgICAgICAvLyBjbGVhbiwgYnV0IHdvdWxkIHJlcXVpcmUgYSB0d28gcGFzcyBlbWl0IHRvIGZpcnN0IGZpbmQgYWxsIHR5cGUgYWxpYXMgbmFtZXMsIG1hbmdsZVxuICAgICAgICAgIC8vIHRoZW0sIGFuZCBlbWl0IHRoZSB1c2Ugc2l0ZXMgb25seSBsYXRlci5cbiAgICAgICAgICAvLyBTbyB3ZSBwcm9kdWNlOiBleHBvcnRzLlQ7XG4gICAgICAgICAgZGVjbCA9IHRzLmNyZWF0ZVN0YXRlbWVudCh0cy5jcmVhdGVQcm9wZXJ0eUFjY2VzcyhcbiAgICAgICAgICAgICAgdHMuY3JlYXRlSWRlbnRpZmllcignZXhwb3J0cycpLCB0cy5jcmVhdGVJZGVudGlmaWVyKHR5cGVOYW1lKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEdpdmVuOiB0eXBlIFQgPSAuLi47XG4gICAgICAgICAgLy8gV2UgcHJvZHVjZTogdmFyIFQ7XG4gICAgICAgICAgLy8gTm90ZTogbm90IGNvbnN0LCBiZWNhdXNlICdjb25zdCBGb287JyBpcyBpbGxlZ2FsO1xuICAgICAgICAgIC8vIG5vdCBsZXQsIGJlY2F1c2Ugd2Ugd2FudCBob2lzdGluZyBiZWhhdmlvciBmb3IgdHlwZXMuXG4gICAgICAgICAgZGVjbCA9IHRzLmNyZWF0ZVZhcmlhYmxlU3RhdGVtZW50KFxuICAgICAgICAgICAgICAvKiBtb2RpZmllcnMgKi8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICB0cy5jcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uTGlzdChcbiAgICAgICAgICAgICAgICAgIFt0cy5jcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uKHRzLmNyZWF0ZUlkZW50aWZpZXIodHlwZU5hbWUpKV0pKTtcbiAgICAgICAgfVxuICAgICAgICBkZWNsID0gdHMuc2V0U291cmNlTWFwUmFuZ2UoZGVjbCwgdHlwZUFsaWFzKTtcbiAgICAgICAgYWRkQ29tbWVudE9uKGRlY2wsIHRhZ3MsIGpzZG9jLlRBR1NfQ09ORkxJQ1RJTkdfV0lUSF9UWVBFKTtcbiAgICAgICAgcmV0dXJuIFtkZWNsXTtcbiAgICAgIH1cblxuICAgICAgLyoqIEVtaXRzIGEgcGFyZW50aGVzaXplZCBDbG9zdXJlIGNhc3Q6IGAoLyoqIFxcQHR5cGUgLi4uICogLyAoZXhwcikpYC4gKi9cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZUNsb3N1cmVDYXN0KGNvbnRleHQ6IHRzLk5vZGUsIGV4cHJlc3Npb246IHRzLkV4cHJlc3Npb24sIHR5cGU6IHRzLlR5cGUpIHtcbiAgICAgICAgY29uc3QgaW5uZXIgPSB0cy5jcmVhdGVQYXJlbihleHByZXNzaW9uKTtcbiAgICAgICAgY29uc3QgY29tbWVudCA9IGFkZENvbW1lbnRPbihcbiAgICAgICAgICAgIGlubmVyLCBbe3RhZ05hbWU6ICd0eXBlJywgdHlwZTogbW9kdWxlVHlwZVRyYW5zbGF0b3IudHlwZVRvQ2xvc3VyZShjb250ZXh0LCB0eXBlKX1dKTtcbiAgICAgICAgY29tbWVudC5oYXNUcmFpbGluZ05ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRzLnNldFNvdXJjZU1hcFJhbmdlKHRzLmNyZWF0ZVBhcmVuKGlubmVyKSwgY29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIC8qKiBDb252ZXJ0cyBhIFR5cGVTY3JpcHQgdHlwZSBhc3NlcnRpb24gaW50byBhIENsb3N1cmUgQ2FzdC4gKi9cbiAgICAgIGZ1bmN0aW9uIHZpc2l0QXNzZXJ0aW9uRXhwcmVzc2lvbihhc3NlcnRpb246IHRzLkFzc2VydGlvbkV4cHJlc3Npb24pIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVDaGVja2VyLmdldFR5cGVBdExvY2F0aW9uKGFzc2VydGlvbi50eXBlKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNsb3N1cmVDYXN0KGFzc2VydGlvbiwgdHMudmlzaXRFYWNoQ2hpbGQoYXNzZXJ0aW9uLCB2aXNpdG9yLCBjb250ZXh0KSwgdHlwZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVydHMgYSBUeXBlU2NyaXB0IG5vbi1udWxsIGFzc2VydGlvbiBpbnRvIGEgQ2xvc3VyZSBDYXN0LCBieSBzdHJpcHBpbmcgfG51bGwgYW5kXG4gICAgICAgKiB8dW5kZWZpbmVkIGZyb20gYSB1bmlvbiB0eXBlLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiB2aXNpdE5vbk51bGxFeHByZXNzaW9uKG5vbk51bGw6IHRzLk5vbk51bGxFeHByZXNzaW9uKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlQ2hlY2tlci5nZXRUeXBlQXRMb2NhdGlvbihub25OdWxsLmV4cHJlc3Npb24pO1xuICAgICAgICBjb25zdCBub25OdWxsVHlwZSA9IHR5cGVDaGVja2VyLmdldE5vbk51bGxhYmxlVHlwZSh0eXBlKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNsb3N1cmVDYXN0KFxuICAgICAgICAgICAgbm9uTnVsbCwgdHMudmlzaXRFYWNoQ2hpbGQobm9uTnVsbCwgdmlzaXRvciwgY29udGV4dCksIG5vbk51bGxUeXBlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdmlzaXRJbXBvcnREZWNsYXJhdGlvbihpbXBvcnREZWNsOiB0cy5JbXBvcnREZWNsYXJhdGlvbikge1xuICAgICAgICAvLyBGb3IgZWFjaCBpbXBvcnQsIGluc2VydCBhIGdvb2cucmVxdWlyZVR5cGUgZm9yIHRoZSBtb2R1bGUsIHNvIHRoYXQgaWYgVHlwZVNjcmlwdCBkb2VzIG5vdFxuICAgICAgICAvLyBlbWl0IHRoZSBtb2R1bGUgYmVjYXVzZSBpdCdzIG9ubHkgdXNlZCBpbiB0eXBlIHBvc2l0aW9ucywgdGhlIEpTRG9jIGNvbW1lbnRzIHN0aWxsXG4gICAgICAgIC8vIHJlZmVyZW5jZSBhIHZhbGlkIENsb3N1cmUgbGV2ZWwgc3ltYm9sLlxuXG4gICAgICAgIC8vIE5vIG5lZWQgdG8gcmVxdWlyZVR5cGUgc2lkZSBlZmZlY3QgaW1wb3J0cy5cbiAgICAgICAgaWYgKCFpbXBvcnREZWNsLmltcG9ydENsYXVzZSkgcmV0dXJuIGltcG9ydERlY2w7XG5cbiAgICAgICAgY29uc3Qgc3ltID0gdHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbihpbXBvcnREZWNsLm1vZHVsZVNwZWNpZmllcik7XG4gICAgICAgIC8vIFNjcmlwdHMgZG8gbm90IGhhdmUgYSBzeW1ib2wsIGFuZCBuZWl0aGVyIGRvIHVudXNlZCBtb2R1bGVzLiBTY3JpcHRzIGNhbiBzdGlsbCBiZVxuICAgICAgICAvLyBpbXBvcnRlZCwgZWl0aGVyIGFzIHNpZGUgZWZmZWN0IGltcG9ydHMgb3Igd2l0aCBhbiBlbXB0eSBpbXBvcnQgc2V0IChcInt9XCIpLiBUeXBlU2NyaXB0XG4gICAgICAgIC8vIGRvZXMgbm90IGVtaXQgYSBydW50aW1lIGxvYWQgZm9yIGFuIGltcG9ydCB3aXRoIGFuIGVtcHR5IGxpc3Qgb2Ygc3ltYm9scywgYnV0IHRoZSBpbXBvcnRcbiAgICAgICAgLy8gZm9yY2VzIGFueSBnbG9iYWwgZGVjbGFyYXRpb25zIGZyb20gdGhlIGxpYnJhcnkgdG8gYmUgdmlzaWJsZSwgd2hpY2ggaXMgd2hhdCB1c2VycyB1c2VcbiAgICAgICAgLy8gdGhpcyBmb3IuIE5vIHN5bWJvbHMgZnJvbSB0aGUgc2NyaXB0IG5lZWQgcmVxdWlyZVR5cGUsIHNvIGp1c3QgcmV0dXJuLlxuICAgICAgICAvLyBUT0RPKGV2bWFyKTogcmV2aXNpdCB0aGlzLiAgSWYgVFMgbmVlZHMgdG8gc2VlIHRoZSBtb2R1bGUgaW1wb3J0LCBpdCdzIGxpa2VseSBDbG9zdXJlXG4gICAgICAgIC8vIGRvZXMgdG9vLlxuICAgICAgICBpZiAoIXN5bSkgcmV0dXJuIGltcG9ydERlY2w7XG5cbiAgICAgICAgY29uc3QgaW1wb3J0UGF0aCA9IGdvb2dtb2R1bGUucmVzb2x2ZU1vZHVsZU5hbWUoXG4gICAgICAgICAgICB7b3B0aW9uczogdHNPcHRpb25zLCBtb2R1bGVSZXNvbHV0aW9uSG9zdDogaG9zdC5tb2R1bGVSZXNvbHV0aW9uSG9zdH0sXG4gICAgICAgICAgICBzb3VyY2VGaWxlLmZpbGVOYW1lLCAoaW1wb3J0RGVjbC5tb2R1bGVTcGVjaWZpZXIgYXMgdHMuU3RyaW5nTGl0ZXJhbCkudGV4dCk7XG5cbiAgICAgICAgbW9kdWxlVHlwZVRyYW5zbGF0b3IucmVxdWlyZVR5cGUoXG4gICAgICAgICAgICBpbXBvcnRQYXRoLCBzeW0sXG4gICAgICAgICAgICAvKiBkZWZhdWx0IGltcG9ydD8gKi8gISFpbXBvcnREZWNsLmltcG9ydENsYXVzZS5uYW1lKTtcbiAgICAgICAgcmV0dXJuIGltcG9ydERlY2w7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2xvc3VyZSBDb21waWxlciB3aWxsIGZhaWwgd2hlbiBpdCBmaW5kcyBpbmNvcnJlY3QgSlNEb2MgdGFncyBvbiBub2Rlcy4gVGhpcyBmdW5jdGlvblxuICAgICAgICogcGFyc2VzIGFuZCB0aGVuIHJlLXNlcmlhbGl6ZXMgSlNEb2MgY29tbWVudHMsIGVzY2FwaW5nIG9yIHJlbW92aW5nIGlsbGVnYWwgdGFncy5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gZXNjYXBlSWxsZWdhbEpTRG9jKG5vZGU6IHRzLk5vZGUpIHtcbiAgICAgICAgY29uc3QgbWpzZG9jID0gbW9kdWxlVHlwZVRyYW5zbGF0b3IuZ2V0TXV0YWJsZUpTRG9jKG5vZGUpO1xuICAgICAgICBtanNkb2MudXBkYXRlQ29tbWVudCgpO1xuICAgICAgfVxuXG4gICAgICAvKiogUmV0dXJucyB0cnVlIGlmIGEgdmFsdWUgZXhwb3J0IHNob3VsZCBiZSBlbWl0dGVkIGZvciB0aGUgZ2l2ZW4gc3ltYm9sIGluIGV4cG9ydCAqLiAqL1xuICAgICAgZnVuY3Rpb24gc2hvdWxkRW1pdFZhbHVlRXhwb3J0Rm9yU3ltYm9sKHN5bTogdHMuU3ltYm9sKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChzeW0uZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5BbGlhcykge1xuICAgICAgICAgIHN5bSA9IHR5cGVDaGVja2VyLmdldEFsaWFzZWRTeW1ib2woc3ltKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN5bS5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLlZhbHVlKSA9PT0gMCkge1xuICAgICAgICAgIC8vIE5vdGU6IFdlIGNyZWF0ZSBleHBsaWNpdCBleHBvcnRzIG9mIHR5cGUgc3ltYm9scyBmb3IgY2xvc3VyZSBpbiB2aXNpdEV4cG9ydERlY2xhcmF0aW9uLlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRzT3B0aW9ucy5wcmVzZXJ2ZUNvbnN0RW51bXMgJiYgc3ltLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuQ29uc3RFbnVtKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHZpc2l0RXhwb3J0RGVjbGFyYXRpb24gcmVxdWlyZVR5cGVzIGV4cG9ydGVkIG1vZHVsZXMgYW5kIGVtaXRzIGV4cGxpY2l0IGV4cG9ydHMgZm9yXG4gICAgICAgKiB0eXBlcyAod2hpY2ggbm9ybWFsbHkgZG8gbm90IGdldCBlbWl0dGVkIGJ5IFR5cGVTY3JpcHQpLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiB2aXNpdEV4cG9ydERlY2xhcmF0aW9uKGV4cG9ydERlY2w6IHRzLkV4cG9ydERlY2xhcmF0aW9uKTogdHMuTm9kZXx0cy5Ob2RlW10ge1xuICAgICAgICBjb25zdCBpbXBvcnRlZE1vZHVsZVN5bWJvbCA9IGV4cG9ydERlY2wubW9kdWxlU3BlY2lmaWVyICYmXG4gICAgICAgICAgICB0eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKGV4cG9ydERlY2wubW9kdWxlU3BlY2lmaWVyKSE7XG4gICAgICAgIGlmIChpbXBvcnRlZE1vZHVsZVN5bWJvbCkge1xuICAgICAgICAgIC8vIHJlcXVpcmVUeXBlIGFsbCBleHBsaWNpdGx5IGltcG9ydGVkIG1vZHVsZXMsIHNvIHRoYXQgc3ltYm9scyBjYW4gYmUgcmVmZXJlbmNlZCBhbmRcbiAgICAgICAgICAvLyB0eXBlIG9ubHkgbW9kdWxlcyBhcmUgdXNhYmxlIGZyb20gdHlwZSBkZWNsYXJhdGlvbnMuXG4gICAgICAgICAgbW9kdWxlVHlwZVRyYW5zbGF0b3IucmVxdWlyZVR5cGUoXG4gICAgICAgICAgICAgIChleHBvcnREZWNsLm1vZHVsZVNwZWNpZmllciBhcyB0cy5TdHJpbmdMaXRlcmFsKS50ZXh0LCBpbXBvcnRlZE1vZHVsZVN5bWJvbCxcbiAgICAgICAgICAgICAgLyogZGVmYXVsdCBpbXBvcnQ/ICovIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHR5cGVzVG9FeHBvcnQ6IEFycmF5PFtzdHJpbmcsIHRzLlN5bWJvbF0+ID0gW107XG4gICAgICAgIGlmICghZXhwb3J0RGVjbC5leHBvcnRDbGF1c2UpIHtcbiAgICAgICAgICAvLyBleHBvcnQgKiBmcm9tICcuLi4nXG4gICAgICAgICAgLy8gUmVzb2x2ZSB0aGUgKiBpbnRvIGFsbCB2YWx1ZSBzeW1ib2xzIGV4cG9ydGVkLCBhbmQgdXBkYXRlIHRoZSBleHBvcnQgZGVjbGFyYXRpb24uXG5cbiAgICAgICAgICAvLyBFeHBsaWNpdGx5IHNwZWxsZWQgb3V0IGV4cG9ydHMgKGkuZS4gdGhlIGV4cG9ydHMgb2YgdGhlIGN1cnJlbnQgbW9kdWxlKSB0YWtlIHByZWNlZGVuY2VcbiAgICAgICAgICAvLyBvdmVyIGltcGxpY2l0IG9uZXMgZnJvbSBleHBvcnQgKi4gVXNlIHRoZSBjdXJyZW50IG1vZHVsZSdzIGV4cG9ydHMgdG8gZmlsdGVyLlxuICAgICAgICAgIGNvbnN0IGN1cnJlbnRNb2R1bGVTeW1ib2wgPSB0eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKHNvdXJjZUZpbGUpO1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRNb2R1bGVFeHBvcnRzID0gY3VycmVudE1vZHVsZVN5bWJvbCAmJiBjdXJyZW50TW9kdWxlU3ltYm9sLmV4cG9ydHM7XG5cbiAgICAgICAgICBpZiAoIWltcG9ydGVkTW9kdWxlU3ltYm9sKSB7XG4gICAgICAgICAgICBtb2R1bGVUeXBlVHJhbnNsYXRvci5lcnJvcihleHBvcnREZWNsLCBgZXhwb3J0ICogd2l0aG91dCBtb2R1bGUgc3ltYm9sYCk7XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0RGVjbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZXhwb3J0ZWRTeW1ib2xzID0gdHlwZUNoZWNrZXIuZ2V0RXhwb3J0c09mTW9kdWxlKGltcG9ydGVkTW9kdWxlU3ltYm9sKTtcbiAgICAgICAgICBjb25zdCBleHBvcnRTcGVjaWZpZXJzOiB0cy5FeHBvcnRTcGVjaWZpZXJbXSA9IFtdO1xuICAgICAgICAgIGZvciAoY29uc3Qgc3ltIG9mIGV4cG9ydGVkU3ltYm9scykge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRNb2R1bGVFeHBvcnRzICYmIGN1cnJlbnRNb2R1bGVFeHBvcnRzLmhhcyhzeW0uZXNjYXBlZE5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgICAgIC8vIFdlIG1pZ2h0IGhhdmUgYWxyZWFkeSBnZW5lcmF0ZWQgYW4gZXhwb3J0IGZvciB0aGUgZ2l2ZW4gc3ltYm9sLlxuICAgICAgICAgICAgaWYgKGV4cGFuZGVkU3RhckltcG9ydHMuaGFzKHN5bS5uYW1lKSkgY29udGludWU7XG4gICAgICAgICAgICBleHBhbmRlZFN0YXJJbXBvcnRzLmFkZChzeW0ubmFtZSk7XG4gICAgICAgICAgICAvLyBPbmx5IGNyZWF0ZSBhbiBleHBvcnQgc3BlY2lmaWVyIGZvciB2YWx1ZXMgdGhhdCBhcmUgZXhwb3J0ZWQuIEZvciB0eXBlcywgdGhlIGNvZGVcbiAgICAgICAgICAgIC8vIGJlbG93IGNyZWF0ZXMgc3BlY2lmaWMgZXhwb3J0IHN0YXRlbWVudHMgdGhhdCBtYXRjaCBDbG9zdXJlJ3MgZXhwZWN0YXRpb25zLlxuICAgICAgICAgICAgaWYgKHNob3VsZEVtaXRWYWx1ZUV4cG9ydEZvclN5bWJvbChzeW0pKSB7XG4gICAgICAgICAgICAgIGV4cG9ydFNwZWNpZmllcnMucHVzaCh0cy5jcmVhdGVFeHBvcnRTcGVjaWZpZXIodW5kZWZpbmVkLCBzeW0ubmFtZSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHlwZXNUb0V4cG9ydC5wdXNoKFtzeW0ubmFtZSwgc3ltXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydERlY2wgPSB0cy51cGRhdGVFeHBvcnREZWNsYXJhdGlvbihcbiAgICAgICAgICAgICAgZXhwb3J0RGVjbCwgZXhwb3J0RGVjbC5kZWNvcmF0b3JzLCBleHBvcnREZWNsLm1vZGlmaWVycyxcbiAgICAgICAgICAgICAgdHMuY3JlYXRlTmFtZWRFeHBvcnRzKGV4cG9ydFNwZWNpZmllcnMpLCBleHBvcnREZWNsLm1vZHVsZVNwZWNpZmllcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChjb25zdCBleHAgb2YgZXhwb3J0RGVjbC5leHBvcnRDbGF1c2UuZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cG9ydGVkTmFtZSA9IHRyYW5zZm9ybWVyVXRpbC5nZXRJZGVudGlmaWVyVGV4dChleHAubmFtZSk7XG4gICAgICAgICAgICB0eXBlc1RvRXhwb3J0LnB1c2goXG4gICAgICAgICAgICAgICAgW2V4cG9ydGVkTmFtZSwgbW9kdWxlVHlwZVRyYW5zbGF0b3IubXVzdEdldFN5bWJvbEF0TG9jYXRpb24oZXhwLm5hbWUpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIERvIG5vdCBlbWl0IHR5cGVkZWYgcmUtZXhwb3J0cyBpbiB1bnR5cGVkIG1vZGUuXG4gICAgICAgIGlmIChob3N0LnVudHlwZWQpIHJldHVybiBleHBvcnREZWNsO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdDogdHMuTm9kZVtdID0gW2V4cG9ydERlY2xdO1xuICAgICAgICBmb3IgKGNvbnN0IFtleHBvcnRlZE5hbWUsIHN5bV0gb2YgdHlwZXNUb0V4cG9ydCkge1xuICAgICAgICAgIGxldCBhbGlhc2VkU3ltYm9sID0gc3ltO1xuICAgICAgICAgIGlmIChzeW0uZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5BbGlhcykge1xuICAgICAgICAgICAgYWxpYXNlZFN5bWJvbCA9IHR5cGVDaGVja2VyLmdldEFsaWFzZWRTeW1ib2woc3ltKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaXNUeXBlQWxpYXMgPSAoYWxpYXNlZFN5bWJvbC5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLlZhbHVlKSA9PT0gMCAmJlxuICAgICAgICAgICAgICAoYWxpYXNlZFN5bWJvbC5mbGFncyAmICh0cy5TeW1ib2xGbGFncy5UeXBlQWxpYXMgfCB0cy5TeW1ib2xGbGFncy5JbnRlcmZhY2UpKSAhPT0gMDtcbiAgICAgICAgICBpZiAoIWlzVHlwZUFsaWFzKSBjb250aW51ZTtcbiAgICAgICAgICBjb25zdCB0eXBlTmFtZSA9XG4gICAgICAgICAgICAgIG1vZHVsZVR5cGVUcmFuc2xhdG9yLnN5bWJvbHNUb0FsaWFzZWROYW1lcy5nZXQoYWxpYXNlZFN5bWJvbCkgfHwgYWxpYXNlZFN5bWJvbC5uYW1lO1xuICAgICAgICAgIGNvbnN0IHN0bXQgPSB0cy5jcmVhdGVTdGF0ZW1lbnQoXG4gICAgICAgICAgICAgIHRzLmNyZWF0ZVByb3BlcnR5QWNjZXNzKHRzLmNyZWF0ZUlkZW50aWZpZXIoJ2V4cG9ydHMnKSwgZXhwb3J0ZWROYW1lKSk7XG4gICAgICAgICAgYWRkQ29tbWVudE9uKHN0bXQsIFt7dGFnTmFtZTogJ3R5cGVkZWYnLCB0eXBlOiAnIScgKyB0eXBlTmFtZX1dKTtcbiAgICAgICAgICB0cy5hZGRTeW50aGV0aWNUcmFpbGluZ0NvbW1lbnQoXG4gICAgICAgICAgICAgIHN0bXQsIHRzLlN5bnRheEtpbmQuU2luZ2xlTGluZUNvbW1lbnRUcml2aWEsICcgcmUtZXhwb3J0IHR5cGVkZWYnLCB0cnVlKTtcbiAgICAgICAgICByZXN1bHQucHVzaChzdG10KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIGlkZW50aWZpZXJzIGV4cG9ydGVkIGluIGEgc2luZ2xlIGV4cG9ydGVkIHN0YXRlbWVudCAtIHR5cGljYWxseSBqdXN0IG9uZVxuICAgICAgICogaWRlbnRpZmllciAoZS5nLiBmb3IgYGV4cG9ydCBmdW5jdGlvbiBmb28oKWApLCBidXQgbXVsdGlwbGUgZm9yIGBleHBvcnQgZGVjbGFyZSB2YXIgYSwgYmAuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGdldEV4cG9ydERlY2xhcmF0aW9uTmFtZXMobm9kZTogdHMuTm9kZSk6IHRzLklkZW50aWZpZXJbXSB7XG4gICAgICAgIHN3aXRjaCAobm9kZS5raW5kKSB7XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlZhcmlhYmxlU3RhdGVtZW50OlxuICAgICAgICAgICAgY29uc3QgdmFyRGVjbCA9IG5vZGUgYXMgdHMuVmFyaWFibGVTdGF0ZW1lbnQ7XG4gICAgICAgICAgICByZXR1cm4gdmFyRGVjbC5kZWNsYXJhdGlvbkxpc3QuZGVjbGFyYXRpb25zLm1hcCgoZCkgPT4gZ2V0RXhwb3J0RGVjbGFyYXRpb25OYW1lcyhkKVswXSk7XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlZhcmlhYmxlRGVjbGFyYXRpb246XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkZ1bmN0aW9uRGVjbGFyYXRpb246XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkludGVyZmFjZURlY2xhcmF0aW9uOlxuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5DbGFzc0RlY2xhcmF0aW9uOlxuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5Nb2R1bGVEZWNsYXJhdGlvbjpcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuRW51bURlY2xhcmF0aW9uOlxuICAgICAgICAgICAgY29uc3QgZGVjbCA9IG5vZGUgYXMgdHMuTmFtZWREZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIGlmICghZGVjbC5uYW1lIHx8IGRlY2wubmFtZS5raW5kICE9PSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW2RlY2wubmFtZV07XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlR5cGVBbGlhc0RlY2xhcmF0aW9uOlxuICAgICAgICAgICAgY29uc3QgdHlwZUFsaWFzID0gbm9kZSBhcyB0cy5UeXBlQWxpYXNEZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBbdHlwZUFsaWFzLm5hbWVdO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBtb2R1bGVUeXBlVHJhbnNsYXRvci5lcnJvcihcbiAgICAgICAgICAgIG5vZGUsIGB1bnN1cHBvcnRlZCBleHBvcnQgZGVjbGFyYXRpb24gJHt0cy5TeW50YXhLaW5kW25vZGUua2luZF19OiAke25vZGUuZ2V0VGV4dCgpfWApO1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQW1iaWVudCBkZWNsYXJhdGlvbnMgZGVjbGFyZSB0eXBlcyBmb3IgVHlwZVNjcmlwdCdzIGJlbmVmaXQsIGFuZCB3aWxsIGJlIHJlbW92ZWQgYnlcbiAgICAgICAqIFR5cGVTY3JpcHQgZHVyaW5nIGl0cyBlbWl0IHBoYXNlLiBEb3duc3RyZWFtIENsb3N1cmUgY29kZSBob3dldmVyIG1pZ2h0IGJlIGltcG9ydGluZ1xuICAgICAgICogc3ltYm9scyBmcm9tIHRoaXMgbW9kdWxlLCBzbyB0c2lja2xlIG11c3QgZW1pdCBhIENsb3N1cmUtY29tcGF0aWJsZSBleHBvcnRzIGRlY2xhcmF0aW9uLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiB2aXNpdEV4cG9ydGVkQW1iaWVudChub2RlOiB0cy5Ob2RlKTogdHMuTm9kZVtdIHtcbiAgICAgICAgaWYgKGhvc3QudW50eXBlZCB8fCAhc2hvdWxkRW1pdEV4cG9ydHNBc3NpZ25tZW50cygpKSByZXR1cm4gW25vZGVdO1xuXG4gICAgICAgIGNvbnN0IGRlY2xOYW1lcyA9IGdldEV4cG9ydERlY2xhcmF0aW9uTmFtZXMobm9kZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogdHMuTm9kZVtdID0gW25vZGVdO1xuICAgICAgICBmb3IgKGNvbnN0IGRlY2wgb2YgZGVjbE5hbWVzKSB7XG4gICAgICAgICAgY29uc3Qgc3ltID0gdHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbihkZWNsKSE7XG4gICAgICAgICAgLy8gTm9uLXZhbHVlIG9iamVjdHMgZG8gbm90IGV4aXN0IGF0IHJ1bnRpbWUsIHNvIHdlIGNhbm5vdCBhY2Nlc3MgdGhlIHN5bWJvbCAoaXQgb25seVxuICAgICAgICAgIC8vIGV4aXN0cyBpbiBleHRlcm5zKS4gRXhwb3J0IHRoZW0gYXMgYSB0eXBlZGVmLCB3aGljaCBmb3J3YXJkcyB0byB0aGUgdHlwZSBpbiBleHRlcm5zLlxuICAgICAgICAgIC8vIE5vdGU6IFR5cGVTY3JpcHQgZW1pdHMgb2RkIGNvZGUgZm9yIGV4cG9ydGVkIGFtYmllbnRzIChleHBvcnRzLnggZm9yIHZhcmlhYmxlcywganVzdCB4XG4gICAgICAgICAgLy8gZm9yIGV2ZXJ5dGhpbmcgZWxzZSkuIFRoYXQgc2VlbXMgYnVnZ3ksIGFuZCBpbiBlaXRoZXIgY2FzZSB0aGlzIGNvZGUgc2hvdWxkIG5vdCBhdHRlbXB0XG4gICAgICAgICAgLy8gdG8gZml4IGl0LlxuICAgICAgICAgIC8vIFNlZSBhbHNvIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvODAxNS5cbiAgICAgICAgICBpZiAoIXN5bWJvbElzVmFsdWUodHlwZUNoZWNrZXIsIHN5bSkpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCBlbWl0IHJlLWV4cG9ydHMgZm9yIE1vZHVsZURlY2xhcmF0aW9ucy5cbiAgICAgICAgICAgIC8vIEFtYmllbnQgTW9kdWxlRGVjbGFyYXRpb25zIGFyZSBhbHdheXMgcmVmZXJlbmNlZCBhcyBnbG9iYWwgc3ltYm9scywgc28gdGhleSBkb24ndFxuICAgICAgICAgICAgLy8gbmVlZCB0byBiZSBleHBvcnRlZC5cbiAgICAgICAgICAgIGlmIChub2RlLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuTW9kdWxlRGVjbGFyYXRpb24pIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgbWFuZ2xlZE5hbWUgPSBtb2R1bGVOYW1lQXNJZGVudGlmaWVyKGhvc3QsIHNvdXJjZUZpbGUuZmlsZU5hbWUpO1xuICAgICAgICAgICAgY29uc3QgZGVjbE5hbWUgPSB0cmFuc2Zvcm1lclV0aWwuZ2V0SWRlbnRpZmllclRleHQoZGVjbCk7XG4gICAgICAgICAgICBjb25zdCBzdG10ID0gdHMuY3JlYXRlU3RhdGVtZW50KFxuICAgICAgICAgICAgICAgIHRzLmNyZWF0ZVByb3BlcnR5QWNjZXNzKHRzLmNyZWF0ZUlkZW50aWZpZXIoJ2V4cG9ydHMnKSwgZGVjbE5hbWUpKTtcbiAgICAgICAgICAgIGFkZENvbW1lbnRPbihzdG10LCBbe3RhZ05hbWU6ICd0eXBlZGVmJywgdHlwZTogYCEke21hbmdsZWROYW1lfS4ke2RlY2xOYW1lfWB9XSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChzdG10KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdmlzaXRvcihub2RlOiB0cy5Ob2RlKTogdHMuTm9kZXx0cy5Ob2RlW10ge1xuICAgICAgICBpZiAodHJhbnNmb3JtZXJVdGlsLmlzQW1iaWVudChub2RlKSkge1xuICAgICAgICAgIGlmICghdHJhbnNmb3JtZXJVdGlsLmhhc01vZGlmaWVyRmxhZyhub2RlIGFzIHRzLkRlY2xhcmF0aW9uLCB0cy5Nb2RpZmllckZsYWdzLkV4cG9ydCkpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmlzaXRFeHBvcnRlZEFtYmllbnQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChub2RlLmtpbmQpIHtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuSW1wb3J0RGVjbGFyYXRpb246XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRJbXBvcnREZWNsYXJhdGlvbihub2RlIGFzIHRzLkltcG9ydERlY2xhcmF0aW9uKTtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuRXhwb3J0RGVjbGFyYXRpb246XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRFeHBvcnREZWNsYXJhdGlvbihub2RlIGFzIHRzLkV4cG9ydERlY2xhcmF0aW9uKTtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuQ2xhc3NEZWNsYXJhdGlvbjpcbiAgICAgICAgICAgIHJldHVybiB2aXNpdENsYXNzRGVjbGFyYXRpb24obm9kZSBhcyB0cy5DbGFzc0RlY2xhcmF0aW9uKTtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuSW50ZXJmYWNlRGVjbGFyYXRpb246XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRJbnRlcmZhY2VEZWNsYXJhdGlvbihub2RlIGFzIHRzLkludGVyZmFjZURlY2xhcmF0aW9uKTtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuSGVyaXRhZ2VDbGF1c2U6XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRIZXJpdGFnZUNsYXVzZShub2RlIGFzIHRzLkhlcml0YWdlQ2xhdXNlKTtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuQXJyb3dGdW5jdGlvbjpcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuRnVuY3Rpb25FeHByZXNzaW9uOlxuICAgICAgICAgICAgLy8gSW5zZXJ0aW5nIGEgY29tbWVudCBiZWZvcmUgYW4gZXhwcmVzc2lvbiBjYW4gdHJpZ2dlciBhdXRvbWF0aWMgc2VtaWNvbG9uIGluc2VydGlvbixcbiAgICAgICAgICAgIC8vIGUuZy4gaWYgdGhlIGZ1bmN0aW9uIGJlbG93IGlzIHRoZSBleHByZXNzaW9uIGluIGEgYHJldHVybmAgc3RhdGVtZW50LiBQYXJlbnRoZXNpemluZ1xuICAgICAgICAgICAgLy8gcHJldmVudHMgQVNJLCBhcyBsb25nIGFzIHRoZSBvcGVuaW5nIHBhcmVuIHJlbWFpbnMgb24gdGhlIHNhbWUgbGluZSAod2hpY2ggaXQgZG9lcykuXG4gICAgICAgICAgICByZXR1cm4gdHMuY3JlYXRlUGFyZW4oXG4gICAgICAgICAgICAgICAgdmlzaXRGdW5jdGlvbkxpa2VEZWNsYXJhdGlvbihub2RlIGFzIHRzLkFycm93RnVuY3Rpb24gfCB0cy5GdW5jdGlvbkV4cHJlc3Npb24pKTtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuQ29uc3RydWN0b3I6XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkZ1bmN0aW9uRGVjbGFyYXRpb246XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLk1ldGhvZERlY2xhcmF0aW9uOlxuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5HZXRBY2Nlc3NvcjpcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuU2V0QWNjZXNzb3I6XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRGdW5jdGlvbkxpa2VEZWNsYXJhdGlvbihub2RlIGFzIHRzLkZ1bmN0aW9uTGlrZURlY2xhcmF0aW9uKTtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuVGhpc0tleXdvcmQ6XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRUaGlzRXhwcmVzc2lvbihub2RlIGFzIHRzLlRoaXNFeHByZXNzaW9uKTtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuVmFyaWFibGVTdGF0ZW1lbnQ6XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRWYXJpYWJsZVN0YXRlbWVudChub2RlIGFzIHRzLlZhcmlhYmxlU3RhdGVtZW50KTtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuUHJvcGVydHlEZWNsYXJhdGlvbjpcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuUHJvcGVydHlBc3NpZ25tZW50OlxuICAgICAgICAgICAgZXNjYXBlSWxsZWdhbEpTRG9jKG5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlBhcmFtZXRlcjpcbiAgICAgICAgICAgIC8vIFBhcmFtZXRlciBwcm9wZXJ0aWVzIChlLmcuIGBjb25zdHJ1Y3RvcigvKiogZG9jcyAqLyBwcml2YXRlIGZvbzogc3RyaW5nKWApIG1pZ2h0IGhhdmVcbiAgICAgICAgICAgIC8vIEpTRG9jIGNvbW1lbnRzLCBpbmNsdWRpbmcgSlNEb2MgdGFncyByZWNvZ25pemVkIGJ5IENsb3N1cmUgQ29tcGlsZXIuIFByZXZlbnQgZW1pdHRpbmdcbiAgICAgICAgICAgIC8vIGFueSBjb21tZW50cyBvbiB0aGVtLCBzbyB0aGF0IENsb3N1cmUgZG9lc24ndCBlcnJvciBvbiB0aGVtLlxuICAgICAgICAgICAgLy8gU2VlIHRlc3RfZmlsZXMvcGFyYW1ldGVyX3Byb3BlcnRpZXMudHMuXG4gICAgICAgICAgICBjb25zdCBwYXJhbURlY2wgPSBub2RlIGFzIHRzLlBhcmFtZXRlckRlY2xhcmF0aW9uO1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybWVyVXRpbC5oYXNNb2RpZmllckZsYWcoXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtRGVjbCwgdHMuTW9kaWZpZXJGbGFncy5QYXJhbWV0ZXJQcm9wZXJ0eU1vZGlmaWVyKSkge1xuICAgICAgICAgICAgICB0cy5zZXRTeW50aGV0aWNMZWFkaW5nQ29tbWVudHMocGFyYW1EZWNsLCBbXSk7XG4gICAgICAgICAgICAgIGpzZG9jLnN1cHByZXNzTGVhZGluZ0NvbW1lbnRzUmVjdXJzaXZlbHkocGFyYW1EZWNsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5UeXBlQWxpYXNEZWNsYXJhdGlvbjpcbiAgICAgICAgICAgIHJldHVybiB2aXNpdFR5cGVBbGlhc0RlY2xhcmF0aW9uKG5vZGUgYXMgdHMuVHlwZUFsaWFzRGVjbGFyYXRpb24pO1xuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5Bc0V4cHJlc3Npb246XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlR5cGVBc3NlcnRpb25FeHByZXNzaW9uOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0QXNzZXJ0aW9uRXhwcmVzc2lvbihub2RlIGFzIHRzLlR5cGVBc3NlcnRpb24pO1xuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5Ob25OdWxsRXhwcmVzc2lvbjpcbiAgICAgICAgICAgIHJldHVybiB2aXNpdE5vbk51bGxFeHByZXNzaW9uKG5vZGUgYXMgdHMuTm9uTnVsbEV4cHJlc3Npb24pO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHMudmlzaXRFYWNoQ2hpbGQobm9kZSwgdmlzaXRvciwgY29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHNvdXJjZUZpbGUgPSB0cy52aXNpdEVhY2hDaGlsZChzb3VyY2VGaWxlLCB2aXNpdG9yLCBjb250ZXh0KTtcblxuICAgICAgcmV0dXJuIG1vZHVsZVR5cGVUcmFuc2xhdG9yLmluc2VydEFkZGl0aW9uYWxJbXBvcnRzKHNvdXJjZUZpbGUpO1xuICAgIH07XG4gIH07XG59XG4iXX0=